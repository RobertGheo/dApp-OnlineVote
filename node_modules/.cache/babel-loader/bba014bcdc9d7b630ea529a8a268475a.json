{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignableMessage = exports.MESSAGE_PREFIX = void 0;\n\nconst signature_1 = require(\"./signature\");\n\nconst address_1 = require(\"./address\");\n\nconst createKeccakHash = require(\"keccak\");\n\nexports.MESSAGE_PREFIX = \"\\x17Elrond Signed Message:\\n\";\n\nclass SignableMessage {\n  constructor(init) {\n    this.message = Buffer.from([]);\n    this.signature = new signature_1.Signature();\n    this.version = 1;\n    this.signer = \"ErdJS\";\n    this.address = new address_1.Address();\n    Object.assign(this, init);\n  }\n\n  serializeForSigning() {\n    const messageSize = Buffer.from(this.message.length.toString());\n    const signableMessage = Buffer.concat([messageSize, this.message]);\n    let bytesToHash = Buffer.concat([Buffer.from(exports.MESSAGE_PREFIX), signableMessage]);\n    return createKeccakHash(\"keccak256\").update(bytesToHash).digest();\n  }\n\n  serializeForSigningRaw() {\n    return Buffer.concat([this.getMessageSize(), this.message]);\n  }\n\n  getSignature() {\n    return this.signature;\n  }\n\n  applySignature(signature) {\n    this.signature = signature;\n  }\n\n  getMessageSize() {\n    const messageSize = Buffer.alloc(4);\n    messageSize.writeUInt32BE(this.message.length, 0);\n    return messageSize;\n  }\n\n  toJSON() {\n    return {\n      address: this.address.bech32(),\n      message: \"0x\" + this.message.toString('hex'),\n      signature: \"0x\" + this.signature.hex(),\n      version: this.version,\n      signer: this.signer\n    };\n  }\n\n}\n\nexports.SignableMessage = SignableMessage;","map":{"version":3,"sources":["../src/signableMessage.ts"],"names":[],"mappings":";;;;;;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,MAAM,gBAAgB,GAAG,OAAO,CAAC,QAAD,CAAhC;;AAEa,OAAA,CAAA,cAAA,GAAiB,8BAAjB;;AAEb,MAAa,eAAb,CAA4B;AA0B1B,EAAA,WAAA,CAAmB,IAAnB,EAAkD;AAChD,SAAK,OAAL,GAAe,MAAM,CAAC,IAAP,CAAY,EAAZ,CAAf;AACA,SAAK,SAAL,GAAiB,IAAI,WAAA,CAAA,SAAJ,EAAjB;AACA,SAAK,OAAL,GAAe,CAAf;AACA,SAAK,MAAL,GAAc,OAAd;AACA,SAAK,OAAL,GAAe,IAAI,SAAA,CAAA,OAAJ,EAAf;AAEA,IAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB,IAApB;AACD;;AAED,EAAA,mBAAmB,GAAA;AACjB,UAAM,WAAW,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,OAAL,CAAa,MAAb,CAAoB,QAApB,EAAZ,CAApB;AACA,UAAM,eAAe,GAAG,MAAM,CAAC,MAAP,CAAc,CAAC,WAAD,EAAc,KAAK,OAAnB,CAAd,CAAxB;AACA,QAAI,WAAW,GAAG,MAAM,CAAC,MAAP,CAAc,CAAC,MAAM,CAAC,IAAP,CAAY,OAAA,CAAA,cAAZ,CAAD,EAA8B,eAA9B,CAAd,CAAlB;AAEA,WAAO,gBAAgB,CAAC,WAAD,CAAhB,CAA8B,MAA9B,CAAqC,WAArC,EAAkD,MAAlD,EAAP;AACD;;AAED,EAAA,sBAAsB,GAAA;AACpB,WAAO,MAAM,CAAC,MAAP,CAAc,CAAC,KAAK,cAAL,EAAD,EAAwB,KAAK,OAA7B,CAAd,CAAP;AACD;;AAED,EAAA,YAAY,GAAA;AACV,WAAO,KAAK,SAAZ;AACD;;AAED,EAAA,cAAc,CAAC,SAAD,EAAqB;AACjC,SAAK,SAAL,GAAiB,SAAjB;AACD;;AAED,EAAA,cAAc,GAAA;AACZ,UAAM,WAAW,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAApB;AACA,IAAA,WAAW,CAAC,aAAZ,CAA0B,KAAK,OAAL,CAAa,MAAvC,EAA+C,CAA/C;AAEA,WAAO,WAAP;AACD;;AAED,EAAA,MAAM,GAAA;AACJ,WAAO;AACL,MAAA,OAAO,EAAE,KAAK,OAAL,CAAa,MAAb,EADJ;AAEL,MAAA,OAAO,EAAE,OAAO,KAAK,OAAL,CAAa,QAAb,CAAsB,KAAtB,CAFX;AAGL,MAAA,SAAS,EAAE,OAAO,KAAK,SAAL,CAAe,GAAf,EAHb;AAIL,MAAA,OAAO,EAAE,KAAK,OAJT;AAKL,MAAA,MAAM,EAAE,KAAK;AALR,KAAP;AAOD;;AAvEyB;;AAA5B,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SignableMessage = exports.MESSAGE_PREFIX = void 0;\nconst signature_1 = require(\"./signature\");\nconst address_1 = require(\"./address\");\nconst createKeccakHash = require(\"keccak\");\nexports.MESSAGE_PREFIX = \"\\x17Elrond Signed Message:\\n\";\nclass SignableMessage {\n    constructor(init) {\n        this.message = Buffer.from([]);\n        this.signature = new signature_1.Signature();\n        this.version = 1;\n        this.signer = \"ErdJS\";\n        this.address = new address_1.Address();\n        Object.assign(this, init);\n    }\n    serializeForSigning() {\n        const messageSize = Buffer.from(this.message.length.toString());\n        const signableMessage = Buffer.concat([messageSize, this.message]);\n        let bytesToHash = Buffer.concat([Buffer.from(exports.MESSAGE_PREFIX), signableMessage]);\n        return createKeccakHash(\"keccak256\").update(bytesToHash).digest();\n    }\n    serializeForSigningRaw() {\n        return Buffer.concat([this.getMessageSize(), this.message]);\n    }\n    getSignature() {\n        return this.signature;\n    }\n    applySignature(signature) {\n        this.signature = signature;\n    }\n    getMessageSize() {\n        const messageSize = Buffer.alloc(4);\n        messageSize.writeUInt32BE(this.message.length, 0);\n        return messageSize;\n    }\n    toJSON() {\n        return {\n            address: this.address.bech32(),\n            message: \"0x\" + this.message.toString('hex'),\n            signature: \"0x\" + this.signature.hex(),\n            version: this.version,\n            signer: this.signer,\n        };\n    }\n}\nexports.SignableMessage = SignableMessage;\n//# sourceMappingURL=signableMessage.js.map"]},"metadata":{},"sourceType":"script"}