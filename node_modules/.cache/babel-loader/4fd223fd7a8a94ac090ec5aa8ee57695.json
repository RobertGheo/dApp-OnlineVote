{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _require = require('ed25519-hd-key'),\n    derivePath = _require.derivePath;\n\nvar crypto = require('crypto');\n\nvar uuid = require('uuid/v4');\n\nvar bech32 = require('bech32');\n\nvar bip39 = require('bip39');\n\nvar kd = require('./crypto/browser/keyDerivation');\n\nvar signer = require('./crypto/browser/ed25519Keypair');\n\nvar blsSigner = require('./crypto/browser/blsKeypair');\n\nvar _require2 = require('./constants'),\n    ERD = _require2.ERD,\n    MNEMONIC_LEN = _require2.MNEMONIC_LEN,\n    HD_PREFIX = _require2.HD_PREFIX;\n\nvar Account = /*#__PURE__*/function () {\n  /**\n   * Account's constructor. If a keyfile is provided, public/private key are loaded from there\n   * @param keyFile\n   * @param password\n   */\n  function Account() {\n    var keyFile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    (0, _classCallCheck2[\"default\"])(this, Account);\n    this.privateKey = null;\n    this.publicKey = null;\n\n    if (!keyFile) {\n      return;\n    }\n\n    if (!password) {\n      console.warn(\"empty password provided for the keyfile\");\n      return;\n    }\n\n    this.loadFromKeyFile(keyFile, password);\n  }\n  /**\n   * Given a keyfile, load public/private keypair\n   * @param keyFile\n   * @param password\n   */\n\n\n  (0, _createClass2[\"default\"])(Account, [{\n    key: \"loadFromKeyFile\",\n    value: function loadFromKeyFile(keyFile, password) {\n      var kdfparams = keyFile.crypto.kdfparams;\n      var derivedKey = kd.generateDerivedKey(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n      var ciphertext = Buffer.from(keyFile.crypto.ciphertext, 'hex');\n      var mac = crypto.createHmac('sha256', derivedKey.slice(16, 32)).update(ciphertext).digest();\n\n      if (mac.toString('hex') !== keyFile.crypto.mac) {\n        throw new Error('MAC mismatch, possibly wrong password');\n      }\n\n      var decipher = crypto.createDecipheriv(keyFile.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(keyFile.crypto.cipherparams.iv, 'hex'));\n      var seed = Buffer.concat([decipher.update(ciphertext), decipher[\"final\"]()]);\n\n      while (seed.length < 32) {\n        var nullBuff = Buffer.from([0x00]);\n        seed = Buffer.concat([nullBuff, seed]);\n      }\n\n      this.loadFromPrivateKey(seed);\n      return this;\n    }\n    /**\n     * Given a password, it will generate the contents for a file containing the current initialised account's private\n     *   key, passed through a password based key derivation function\n     * @param password\n     * @returns {{version: number, id: *, address: string, bech32: string, crypto: {ciphertext: String, cipherparams: {iv: string}, cipher: string, kdf: string, kdfparams: {dklen: number, salt: string, n: number, r: number, p: number}, mac: string}}}\n     */\n\n  }, {\n    key: \"generateKeyFile\",\n    value: function generateKeyFile(password) {\n      if (!this.publicKey || !this.privateKey) {\n        console.warn(\"Account is not initialised\");\n        return;\n      }\n\n      var salt = crypto.randomBytes(32);\n      var kdParams = {\n        dklen: 32,\n        salt: salt.toString('hex'),\n        n: 4096,\n        r: 8,\n        p: 1\n      };\n      var iv = crypto.randomBytes(16);\n      var derivedKey = kd.generateDerivedKey(Buffer.from(password), salt, kdParams.n, kdParams.r, kdParams.p, kdParams.dklen);\n      var cipher = crypto.createCipheriv('aes-128-ctr', derivedKey.slice(0, 16), iv);\n      var ciphertext = Buffer.concat([cipher.update(this.privateKey), cipher[\"final\"]()]);\n      var mac = crypto.createHmac('sha256', derivedKey.slice(16, 32)).update(ciphertext).digest();\n      return {\n        version: 4,\n        id: uuid({\n          random: crypto.randomBytes(16)\n        }),\n        address: this.publicKeyAsString(),\n        bech32: this.address(),\n        crypto: {\n          ciphertext: ciphertext.toString('hex'),\n          cipherparams: {\n            iv: iv.toString('hex')\n          },\n          cipher: 'aes-128-ctr',\n          kdf: 'scrypt',\n          kdfparams: kdParams,\n          mac: mac.toString('hex')\n        }\n      };\n    }\n    /**\n     * Given a plaintext private key, the current account will be initialised, and a password protected file will be\n     * generated with the provided private key\n     * @param privateKey\n     * @param password\n     * @returns {{version: number, id: *, address: string, bech32: string, crypto: {ciphertext: String, cipherparams: {iv: string}, cipher: string, kdf: string, kdfparams: {dklen: number, salt: string, n: number, r: number, p: number}, mac: string}}}\n     */\n\n  }, {\n    key: \"generateKeyFileFromPrivateKey\",\n    value: function generateKeyFileFromPrivateKey(privateKey, password) {\n      this.loadFromSeed(privateKey);\n      return this.generateKeyFile(password);\n    }\n    /**\n     * Given the private key, regenerate public key\n     * @param privateKey\n     */\n\n  }, {\n    key: \"loadFromPrivateKey\",\n    value: function loadFromPrivateKey(privateKey) {\n      this.privateKey = privateKey;\n      this.publicKey = signer.generatePublicKey(privateKey);\n    }\n    /**\n     * Given a private key, generates the public/private key pair\n     *\n     * @param privateKey\n     */\n\n  }, {\n    key: \"loadFromSeed\",\n    value: function loadFromSeed(privateKey) {\n      var _signer$generatePairF = signer.generatePairFromSeed(privateKey),\n          _signer$generatePairF2 = (0, _slicedToArray2[\"default\"])(_signer$generatePairF, 2),\n          pk = _signer$generatePairF2[0],\n          sk = _signer$generatePairF2[1];\n\n      this.publicKey = pk;\n      this.privateKey = sk;\n    }\n    /**\n     * Given a hex representation of the private key, regenerate public key\n     * @param sk\n     */\n\n  }, {\n    key: \"loadFromHexPrivateKey\",\n    value: function loadFromHexPrivateKey(sk) {\n      var privateKey = Buffer.from(sk, 'hex');\n      this.loadFromPrivateKey(privateKey);\n    }\n    /**\n     * Return the hex representation of the public key\n     * @returns {string}\n     */\n\n  }, {\n    key: \"publicKeyAsString\",\n    value: function publicKeyAsString() {\n      return Buffer.from(this.publicKey).toString('hex');\n    }\n    /**\n     * Return the bech32 representation of the public key\n     * @returns {string}\n     */\n\n  }, {\n    key: \"address\",\n    value: function address() {\n      var words = bech32.toWords(Buffer.from(this.publicKey));\n      return bech32.encode(ERD, words);\n    }\n    /**\n     * Returns the hex representation from the bech32 string\n     * @returns {string}\n     */\n\n  }, {\n    key: \"hexPublicKeyFromAddress\",\n    value: function hexPublicKeyFromAddress(bech32addr) {\n      var dec = bech32.decode(bech32addr, 256);\n      return Buffer.from(bech32.fromWords(dec.words)).toString('hex');\n    }\n    /**\n     * Returns the bech32 representation of the provided public key\n     * @param publicKey\n     * @returns {string}\n     */\n\n  }, {\n    key: \"addressFromHexPublicKey\",\n    value: function addressFromHexPublicKey(publicKey) {\n      var words = bech32.toWords(Buffer.from(publicKey, 'hex'));\n      return bech32.encode(ERD, words);\n    }\n    /**\n     * Return the hex representation of the public key\n     * @returns {string}\n     */\n\n  }, {\n    key: \"privateKeyAsString\",\n    value: function privateKeyAsString() {\n      return Buffer.from(this.privateKey).toString('hex');\n    }\n    /**\n     * Generates a new EdDSA25519 keypair\n     * @returns {*[]}\n     */\n\n  }, {\n    key: \"initNewKeyPair\",\n    value: function initNewKeyPair() {\n      var _signer$keyPair = signer.keyPair(),\n          _signer$keyPair2 = (0, _slicedToArray2[\"default\"])(_signer$keyPair, 2),\n          publicKey = _signer$keyPair2[0],\n          privateKey = _signer$keyPair2[1];\n\n      this.publicKey = publicKey;\n      this.privateKey = privateKey;\n      return [this.publicKey, this.privateKey];\n    }\n    /**\n     * Generate a new account file given a password\n     * @param password\n     * @returns {{version: number, id: *, address: string, crypto: {ciphertext: string, cipherparams: {iv: string}, cipher: string, kdf: string, kdfparams: {dklen: number, salt: string, n: number, r: number, p: number}, mac: string}}}\n     */\n\n  }, {\n    key: \"initNewAccountFromPassword\",\n    value: function initNewAccountFromPassword(password) {\n      this.initNewKeyPair();\n      return this.generateKeyFile(password);\n    }\n    /**\n     * Generate a new mnemonic phrase\n     * @returns {string}\n     */\n\n  }, {\n    key: \"generateMnemonic\",\n    value: function generateMnemonic() {\n      return bip39.generateMnemonic(MNEMONIC_LEN);\n    }\n    /**\n     * Generate private key given a mnemonic. If derive is set to true, it will return the index account\n     * from the derivation path\n     *\n     * @param mnemonic\n     * @param derive\n     * @param index\n     * @param password\n     * @returns {string}\n     */\n\n  }, {\n    key: \"privateKeyFromMnemonic\",\n    value: function privateKeyFromMnemonic(mnemonic) {\n      var derive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var password = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n      if (!bip39.validateMnemonic(mnemonic)) {\n        throw new Error(\"wrong mnemonic format\");\n      }\n\n      var seed = bip39.mnemonicToSeedSync(mnemonic, password);\n\n      var _derivePath = derivePath(\"\".concat(HD_PREFIX, \"/\").concat(index, \"'\"), seed),\n          key = _derivePath.key;\n\n      return key.toString(\"hex\");\n    }\n    /**\n     * Loads an account from a given a mnemonic phrase\n     *\n     * @param mnemonic\n     */\n\n  }, {\n    key: \"loadFromMnemonic\",\n    value: function loadFromMnemonic(mnemonic) {\n      var sk = this.privateKeyFromMnemonic(mnemonic);\n      return this.loadFromSeed(Buffer.from(sk, 'hex'));\n    }\n    /**\n     * Creates a signature over a message using Schnorr signature scheme\n     * @param message\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(message) {\n      if (!this.privateKey) {\n        console.warn(\"account is not initialized, cannot sign message\");\n        return;\n      }\n\n      var sig = signer.sign(message, this.privateKey);\n      return Buffer.from(sig).toString('hex');\n    }\n  }, {\n    key: \"initBLS\",\n    value: function () {\n      var _initBLS = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", blsSigner.init());\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function initBLS() {\n        return _initBLS.apply(this, arguments);\n      }\n\n      return initBLS;\n    }()\n  }, {\n    key: \"generateBLSKeypair\",\n    value: function generateBLSKeypair(privateKey) {\n      return blsSigner.generatePairFromSeed(privateKey);\n    }\n  }, {\n    key: \"computeBLSSig\",\n    value: function computeBLSSig(message, privateKey) {\n      return blsSigner.sign(message, privateKey);\n    }\n  }]);\n  return Account;\n}();\n\nmodule.exports = Account;","map":{"version":3,"sources":["/home/robert/Final Project/dApp-OnlineVote/node_modules/@elrondnetwork/elrond-core-js/dist/account.js"],"names":["_interopRequireDefault","require","_regenerator","_asyncToGenerator2","_slicedToArray2","_classCallCheck2","_createClass2","_require","derivePath","crypto","uuid","bech32","bip39","kd","signer","blsSigner","_require2","ERD","MNEMONIC_LEN","HD_PREFIX","Account","keyFile","arguments","length","undefined","password","privateKey","publicKey","console","warn","loadFromKeyFile","key","value","kdfparams","derivedKey","generateDerivedKey","Buffer","from","salt","n","r","p","dklen","ciphertext","mac","createHmac","slice","update","digest","toString","Error","decipher","createDecipheriv","cipher","cipherparams","iv","seed","concat","nullBuff","loadFromPrivateKey","generateKeyFile","randomBytes","kdParams","createCipheriv","version","id","random","address","publicKeyAsString","kdf","generateKeyFileFromPrivateKey","loadFromSeed","generatePublicKey","_signer$generatePairF","generatePairFromSeed","_signer$generatePairF2","pk","sk","loadFromHexPrivateKey","words","toWords","encode","hexPublicKeyFromAddress","bech32addr","dec","decode","fromWords","addressFromHexPublicKey","privateKeyAsString","initNewKeyPair","_signer$keyPair","keyPair","_signer$keyPair2","initNewAccountFromPassword","generateMnemonic","privateKeyFromMnemonic","mnemonic","derive","index","validateMnemonic","mnemonicToSeedSync","_derivePath","loadFromMnemonic","sign","message","sig","_initBLS","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","init","stop","initBLS","apply","generateBLSKeypair","computeBLSSig","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _require = require('ed25519-hd-key'),\n    derivePath = _require.derivePath;\n\nvar crypto = require('crypto');\n\nvar uuid = require('uuid/v4');\n\nvar bech32 = require('bech32');\n\nvar bip39 = require('bip39');\n\nvar kd = require('./crypto/browser/keyDerivation');\n\nvar signer = require('./crypto/browser/ed25519Keypair');\n\nvar blsSigner = require('./crypto/browser/blsKeypair');\n\nvar _require2 = require('./constants'),\n    ERD = _require2.ERD,\n    MNEMONIC_LEN = _require2.MNEMONIC_LEN,\n    HD_PREFIX = _require2.HD_PREFIX;\n\nvar Account =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Account's constructor. If a keyfile is provided, public/private key are loaded from there\n   * @param keyFile\n   * @param password\n   */\n  function Account() {\n    var keyFile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    (0, _classCallCheck2[\"default\"])(this, Account);\n    this.privateKey = null;\n    this.publicKey = null;\n\n    if (!keyFile) {\n      return;\n    }\n\n    if (!password) {\n      console.warn(\"empty password provided for the keyfile\");\n      return;\n    }\n\n    this.loadFromKeyFile(keyFile, password);\n  }\n  /**\n   * Given a keyfile, load public/private keypair\n   * @param keyFile\n   * @param password\n   */\n\n\n  (0, _createClass2[\"default\"])(Account, [{\n    key: \"loadFromKeyFile\",\n    value: function loadFromKeyFile(keyFile, password) {\n      var kdfparams = keyFile.crypto.kdfparams;\n      var derivedKey = kd.generateDerivedKey(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n      var ciphertext = Buffer.from(keyFile.crypto.ciphertext, 'hex');\n      var mac = crypto.createHmac('sha256', derivedKey.slice(16, 32)).update(ciphertext).digest();\n\n      if (mac.toString('hex') !== keyFile.crypto.mac) {\n        throw new Error('MAC mismatch, possibly wrong password');\n      }\n\n      var decipher = crypto.createDecipheriv(keyFile.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(keyFile.crypto.cipherparams.iv, 'hex'));\n      var seed = Buffer.concat([decipher.update(ciphertext), decipher[\"final\"]()]);\n\n      while (seed.length < 32) {\n        var nullBuff = Buffer.from([0x00]);\n        seed = Buffer.concat([nullBuff, seed]);\n      }\n\n      this.loadFromPrivateKey(seed);\n      return this;\n    }\n    /**\n     * Given a password, it will generate the contents for a file containing the current initialised account's private\n     *   key, passed through a password based key derivation function\n     * @param password\n     * @returns {{version: number, id: *, address: string, bech32: string, crypto: {ciphertext: String, cipherparams: {iv: string}, cipher: string, kdf: string, kdfparams: {dklen: number, salt: string, n: number, r: number, p: number}, mac: string}}}\n     */\n\n  }, {\n    key: \"generateKeyFile\",\n    value: function generateKeyFile(password) {\n      if (!this.publicKey || !this.privateKey) {\n        console.warn(\"Account is not initialised\");\n        return;\n      }\n\n      var salt = crypto.randomBytes(32);\n      var kdParams = {\n        dklen: 32,\n        salt: salt.toString('hex'),\n        n: 4096,\n        r: 8,\n        p: 1\n      };\n      var iv = crypto.randomBytes(16);\n      var derivedKey = kd.generateDerivedKey(Buffer.from(password), salt, kdParams.n, kdParams.r, kdParams.p, kdParams.dklen);\n      var cipher = crypto.createCipheriv('aes-128-ctr', derivedKey.slice(0, 16), iv);\n      var ciphertext = Buffer.concat([cipher.update(this.privateKey), cipher[\"final\"]()]);\n      var mac = crypto.createHmac('sha256', derivedKey.slice(16, 32)).update(ciphertext).digest();\n      return {\n        version: 4,\n        id: uuid({\n          random: crypto.randomBytes(16)\n        }),\n        address: this.publicKeyAsString(),\n        bech32: this.address(),\n        crypto: {\n          ciphertext: ciphertext.toString('hex'),\n          cipherparams: {\n            iv: iv.toString('hex')\n          },\n          cipher: 'aes-128-ctr',\n          kdf: 'scrypt',\n          kdfparams: kdParams,\n          mac: mac.toString('hex')\n        }\n      };\n    }\n    /**\n     * Given a plaintext private key, the current account will be initialised, and a password protected file will be\n     * generated with the provided private key\n     * @param privateKey\n     * @param password\n     * @returns {{version: number, id: *, address: string, bech32: string, crypto: {ciphertext: String, cipherparams: {iv: string}, cipher: string, kdf: string, kdfparams: {dklen: number, salt: string, n: number, r: number, p: number}, mac: string}}}\n     */\n\n  }, {\n    key: \"generateKeyFileFromPrivateKey\",\n    value: function generateKeyFileFromPrivateKey(privateKey, password) {\n      this.loadFromSeed(privateKey);\n      return this.generateKeyFile(password);\n    }\n    /**\n     * Given the private key, regenerate public key\n     * @param privateKey\n     */\n\n  }, {\n    key: \"loadFromPrivateKey\",\n    value: function loadFromPrivateKey(privateKey) {\n      this.privateKey = privateKey;\n      this.publicKey = signer.generatePublicKey(privateKey);\n    }\n    /**\n     * Given a private key, generates the public/private key pair\n     *\n     * @param privateKey\n     */\n\n  }, {\n    key: \"loadFromSeed\",\n    value: function loadFromSeed(privateKey) {\n      var _signer$generatePairF = signer.generatePairFromSeed(privateKey),\n          _signer$generatePairF2 = (0, _slicedToArray2[\"default\"])(_signer$generatePairF, 2),\n          pk = _signer$generatePairF2[0],\n          sk = _signer$generatePairF2[1];\n\n      this.publicKey = pk;\n      this.privateKey = sk;\n    }\n    /**\n     * Given a hex representation of the private key, regenerate public key\n     * @param sk\n     */\n\n  }, {\n    key: \"loadFromHexPrivateKey\",\n    value: function loadFromHexPrivateKey(sk) {\n      var privateKey = Buffer.from(sk, 'hex');\n      this.loadFromPrivateKey(privateKey);\n    }\n    /**\n     * Return the hex representation of the public key\n     * @returns {string}\n     */\n\n  }, {\n    key: \"publicKeyAsString\",\n    value: function publicKeyAsString() {\n      return Buffer.from(this.publicKey).toString('hex');\n    }\n    /**\n     * Return the bech32 representation of the public key\n     * @returns {string}\n     */\n\n  }, {\n    key: \"address\",\n    value: function address() {\n      var words = bech32.toWords(Buffer.from(this.publicKey));\n      return bech32.encode(ERD, words);\n    }\n    /**\n     * Returns the hex representation from the bech32 string\n     * @returns {string}\n     */\n\n  }, {\n    key: \"hexPublicKeyFromAddress\",\n    value: function hexPublicKeyFromAddress(bech32addr) {\n      var dec = bech32.decode(bech32addr, 256);\n      return Buffer.from(bech32.fromWords(dec.words)).toString('hex');\n    }\n    /**\n     * Returns the bech32 representation of the provided public key\n     * @param publicKey\n     * @returns {string}\n     */\n\n  }, {\n    key: \"addressFromHexPublicKey\",\n    value: function addressFromHexPublicKey(publicKey) {\n      var words = bech32.toWords(Buffer.from(publicKey, 'hex'));\n      return bech32.encode(ERD, words);\n    }\n    /**\n     * Return the hex representation of the public key\n     * @returns {string}\n     */\n\n  }, {\n    key: \"privateKeyAsString\",\n    value: function privateKeyAsString() {\n      return Buffer.from(this.privateKey).toString('hex');\n    }\n    /**\n     * Generates a new EdDSA25519 keypair\n     * @returns {*[]}\n     */\n\n  }, {\n    key: \"initNewKeyPair\",\n    value: function initNewKeyPair() {\n      var _signer$keyPair = signer.keyPair(),\n          _signer$keyPair2 = (0, _slicedToArray2[\"default\"])(_signer$keyPair, 2),\n          publicKey = _signer$keyPair2[0],\n          privateKey = _signer$keyPair2[1];\n\n      this.publicKey = publicKey;\n      this.privateKey = privateKey;\n      return [this.publicKey, this.privateKey];\n    }\n    /**\n     * Generate a new account file given a password\n     * @param password\n     * @returns {{version: number, id: *, address: string, crypto: {ciphertext: string, cipherparams: {iv: string}, cipher: string, kdf: string, kdfparams: {dklen: number, salt: string, n: number, r: number, p: number}, mac: string}}}\n     */\n\n  }, {\n    key: \"initNewAccountFromPassword\",\n    value: function initNewAccountFromPassword(password) {\n      this.initNewKeyPair();\n      return this.generateKeyFile(password);\n    }\n    /**\n     * Generate a new mnemonic phrase\n     * @returns {string}\n     */\n\n  }, {\n    key: \"generateMnemonic\",\n    value: function generateMnemonic() {\n      return bip39.generateMnemonic(MNEMONIC_LEN);\n    }\n    /**\n     * Generate private key given a mnemonic. If derive is set to true, it will return the index account\n     * from the derivation path\n     *\n     * @param mnemonic\n     * @param derive\n     * @param index\n     * @param password\n     * @returns {string}\n     */\n\n  }, {\n    key: \"privateKeyFromMnemonic\",\n    value: function privateKeyFromMnemonic(mnemonic) {\n      var derive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var password = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n      if (!bip39.validateMnemonic(mnemonic)) {\n        throw new Error(\"wrong mnemonic format\");\n      }\n\n      var seed = bip39.mnemonicToSeedSync(mnemonic, password);\n\n      var _derivePath = derivePath(\"\".concat(HD_PREFIX, \"/\").concat(index, \"'\"), seed),\n          key = _derivePath.key;\n\n      return key.toString(\"hex\");\n    }\n    /**\n     * Loads an account from a given a mnemonic phrase\n     *\n     * @param mnemonic\n     */\n\n  }, {\n    key: \"loadFromMnemonic\",\n    value: function loadFromMnemonic(mnemonic) {\n      var sk = this.privateKeyFromMnemonic(mnemonic);\n      return this.loadFromSeed(Buffer.from(sk, 'hex'));\n    }\n    /**\n     * Creates a signature over a message using Schnorr signature scheme\n     * @param message\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(message) {\n      if (!this.privateKey) {\n        console.warn(\"account is not initialized, cannot sign message\");\n        return;\n      }\n\n      var sig = signer.sign(message, this.privateKey);\n      return Buffer.from(sig).toString('hex');\n    }\n  }, {\n    key: \"initBLS\",\n    value: function () {\n      var _initBLS = (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee() {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", blsSigner.init());\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function initBLS() {\n        return _initBLS.apply(this, arguments);\n      }\n\n      return initBLS;\n    }()\n  }, {\n    key: \"generateBLSKeypair\",\n    value: function generateBLSKeypair(privateKey) {\n      return blsSigner.generatePairFromSeed(privateKey);\n    }\n  }, {\n    key: \"computeBLSSig\",\n    value: function computeBLSSig(message, privateKey) {\n      return blsSigner.sign(message, privateKey);\n    }\n  }]);\n  return Account;\n}();\n\nmodule.exports = Account;"]},"metadata":{},"sourceType":"script"}