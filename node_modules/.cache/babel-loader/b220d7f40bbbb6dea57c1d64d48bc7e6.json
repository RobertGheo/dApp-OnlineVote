{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HWProvider = void 0;\n\nconst hw_transport_webusb_1 = __importDefault(require(\"@ledgerhq/hw-transport-webusb\"));\n\nconst hw_transport_webhid_1 = __importDefault(require(\"@ledgerhq/hw-transport-webhid\"));\n\nconst hw_transport_u2f_1 = __importDefault(require(\"@ledgerhq/hw-transport-u2f\")); // @ts-ignore\n\n\nconst hw_app_elrond_1 = __importDefault(require(\"@elrondnetwork/hw-app-elrond\"));\n\nconst platform_1 = __importDefault(require(\"platform\"));\n\nconst address_1 = require(\"../address\");\n\nconst signature_1 = require(\"../signature\");\n\nconst versioning_1 = require(\"../versioning\");\n\nconst constants_1 = require(\"./constants\");\n\nconst networkParams_1 = require(\"../networkParams\");\n\nclass HWProvider {\n  constructor(httpProvider) {\n    this.addressIndex = 0;\n    this.provider = httpProvider;\n  }\n  /**\n   * Creates transport and initialises ledger app.\n   */\n\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const transport = yield this.getTransport();\n        this.hwApp = new hw_app_elrond_1.default(transport);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    });\n  }\n\n  getTransport() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let webUSBSupported = yield hw_transport_webusb_1.default.isSupported();\n      webUSBSupported = webUSBSupported && platform_1.default.name !== \"Opera\";\n\n      if (webUSBSupported) {\n        return yield hw_transport_webusb_1.default.create();\n      }\n\n      let webHIDSupported = yield hw_transport_webhid_1.default.isSupported();\n\n      if (webHIDSupported) {\n        return yield hw_transport_webhid_1.default.open(\"\");\n      }\n\n      return yield hw_transport_u2f_1.default.create();\n    });\n  }\n  /**\n   * Returns true if init() was previously called successfully\n   */\n\n\n  isInitialized() {\n    return !!this.hwApp;\n  }\n  /**\n   * Mocked function, returns isInitialized as an async function\n   */\n\n\n  isConnected() {\n    return new Promise((resolve, _) => resolve(this.isInitialized()));\n  }\n  /**\n   * Performs a login request by setting the selected index in Ledger and returning that address\n   */\n\n\n  login(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      if (options && options.addressIndex) {\n        this.addressIndex = options.addressIndex;\n      }\n\n      yield this.hwApp.setAddress(0, this.addressIndex);\n      const {\n        address\n      } = yield this.hwApp.getAddress(0, this.addressIndex, true);\n      return address;\n    });\n  }\n\n  getAccounts() {\n    let page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let pageSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const addresses = [];\n      const startIndex = page * pageSize;\n\n      for (let index = startIndex; index < startIndex + pageSize; index++) {\n        const {\n          address\n        } = yield this.hwApp.getAddress(0, index);\n        addresses.push(address);\n      }\n\n      return addresses;\n    });\n  }\n  /**\n   * Mocks a logout request by returning true\n   */\n\n\n  logout() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Fetches current selected ledger address\n   */\n\n\n  getAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.getCurrentAddress();\n    });\n  }\n  /**\n   * Signs and sends a transaction. Returns the transaction hash\n   * @param transaction\n   */\n\n\n  sendTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      transaction = yield this.signTransaction(transaction);\n      yield transaction.send(this.provider);\n      return transaction;\n    });\n  }\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const address = yield this.getCurrentAddress();\n      let signUsingHash = yield this.shouldSignUsingHash();\n\n      if (signUsingHash) {\n        transaction.options = networkParams_1.TransactionOptions.withTxHashSignOptions();\n        transaction.version = networkParams_1.TransactionVersion.withTxHashSignVersion();\n      }\n\n      const sig = yield this.hwApp.signTransaction(transaction.serializeForSigning(new address_1.Address(address)), signUsingHash);\n      transaction.applySignature(new signature_1.Signature(sig), new address_1.Address(address));\n      return transaction;\n    });\n  }\n\n  signTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let retTx = [];\n\n      for (let tx of transactions) {\n        retTx.push(yield this.signTransaction(tx));\n      }\n\n      return retTx;\n    });\n  }\n\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const signature = yield this.hwApp.signMessage(message.serializeForSigningRaw());\n      message.applySignature(new signature_1.Signature(signature));\n      return message;\n    });\n  }\n\n  tokenLogin(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      if (options && options.addressIndex) {\n        this.addressIndex = options.addressIndex;\n      }\n\n      yield this.hwApp.setAddress(0, this.addressIndex);\n      const {\n        signature,\n        address\n      } = yield this.hwApp.getAddressAndSignAuthToken(0, this.addressIndex, options.token);\n      return {\n        signature: new signature_1.Signature(signature),\n        address\n      };\n    });\n  }\n\n  shouldSignUsingHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const config = yield this.hwApp.getAppConfiguration();\n      let diff = versioning_1.compareVersions(config.version, constants_1.LEDGER_TX_HASH_SIGN_MIN_VERSION);\n      return diff >= 0;\n    });\n  }\n\n  getCurrentAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const {\n        address\n      } = yield this.hwApp.getAddress(0, this.addressIndex);\n      return address;\n    });\n  }\n\n}\n\nexports.HWProvider = HWProvider;","map":{"version":3,"sources":["../../src/dapp/hwProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HWProvider = void 0;\nconst hw_transport_webusb_1 = __importDefault(require(\"@ledgerhq/hw-transport-webusb\"));\nconst hw_transport_webhid_1 = __importDefault(require(\"@ledgerhq/hw-transport-webhid\"));\nconst hw_transport_u2f_1 = __importDefault(require(\"@ledgerhq/hw-transport-u2f\"));\n// @ts-ignore\nconst hw_app_elrond_1 = __importDefault(require(\"@elrondnetwork/hw-app-elrond\"));\nconst platform_1 = __importDefault(require(\"platform\"));\nconst address_1 = require(\"../address\");\nconst signature_1 = require(\"../signature\");\nconst versioning_1 = require(\"../versioning\");\nconst constants_1 = require(\"./constants\");\nconst networkParams_1 = require(\"../networkParams\");\nclass HWProvider {\n    constructor(httpProvider) {\n        this.addressIndex = 0;\n        this.provider = httpProvider;\n    }\n    /**\n     * Creates transport and initialises ledger app.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const transport = yield this.getTransport();\n                this.hwApp = new hw_app_elrond_1.default(transport);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        });\n    }\n    getTransport() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let webUSBSupported = yield hw_transport_webusb_1.default.isSupported();\n            webUSBSupported =\n                webUSBSupported &&\n                    platform_1.default.name !== \"Opera\";\n            if (webUSBSupported) {\n                return yield hw_transport_webusb_1.default.create();\n            }\n            let webHIDSupported = yield hw_transport_webhid_1.default.isSupported();\n            if (webHIDSupported) {\n                return yield hw_transport_webhid_1.default.open(\"\");\n            }\n            return yield hw_transport_u2f_1.default.create();\n        });\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n    isInitialized() {\n        return !!this.hwApp;\n    }\n    /**\n     * Mocked function, returns isInitialized as an async function\n     */\n    isConnected() {\n        return new Promise((resolve, _) => resolve(this.isInitialized()));\n    }\n    /**\n     * Performs a login request by setting the selected index in Ledger and returning that address\n     */\n    login(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            if (options && options.addressIndex) {\n                this.addressIndex = options.addressIndex;\n            }\n            yield this.hwApp.setAddress(0, this.addressIndex);\n            const { address } = yield this.hwApp.getAddress(0, this.addressIndex, true);\n            return address;\n        });\n    }\n    getAccounts(page = 0, pageSize = 10) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const addresses = [];\n            const startIndex = page * pageSize;\n            for (let index = startIndex; index < startIndex + pageSize; index++) {\n                const { address } = yield this.hwApp.getAddress(0, index);\n                addresses.push(address);\n            }\n            return addresses;\n        });\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n    logout() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            return true;\n        });\n    }\n    /**\n     * Fetches current selected ledger address\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getCurrentAddress();\n        });\n    }\n    /**\n     * Signs and sends a transaction. Returns the transaction hash\n     * @param transaction\n     */\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            transaction = yield this.signTransaction(transaction);\n            yield transaction.send(this.provider);\n            return transaction;\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const address = yield this.getCurrentAddress();\n            let signUsingHash = yield this.shouldSignUsingHash();\n            if (signUsingHash) {\n                transaction.options = networkParams_1.TransactionOptions.withTxHashSignOptions();\n                transaction.version = networkParams_1.TransactionVersion.withTxHashSignVersion();\n            }\n            const sig = yield this.hwApp.signTransaction(transaction.serializeForSigning(new address_1.Address(address)), signUsingHash);\n            transaction.applySignature(new signature_1.Signature(sig), new address_1.Address(address));\n            return transaction;\n        });\n    }\n    signTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let retTx = [];\n            for (let tx of transactions) {\n                retTx.push(yield this.signTransaction(tx));\n            }\n            return retTx;\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const signature = yield this.hwApp.signMessage(message.serializeForSigningRaw());\n            message.applySignature(new signature_1.Signature(signature));\n            return message;\n        });\n    }\n    tokenLogin(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            if (options && options.addressIndex) {\n                this.addressIndex = options.addressIndex;\n            }\n            yield this.hwApp.setAddress(0, this.addressIndex);\n            const { signature, address } = yield this.hwApp.getAddressAndSignAuthToken(0, this.addressIndex, options.token);\n            return {\n                signature: new signature_1.Signature(signature),\n                address\n            };\n        });\n    }\n    shouldSignUsingHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const config = yield this.hwApp.getAppConfiguration();\n            let diff = versioning_1.compareVersions(config.version, constants_1.LEDGER_TX_HASH_SIGN_MIN_VERSION);\n            return diff >= 0;\n        });\n    }\n    getCurrentAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const { address } = yield this.hwApp.getAddress(0, this.addressIndex);\n            return address;\n        });\n    }\n}\nexports.HWProvider = HWProvider;\n//# sourceMappingURL=hwProvider.js.map"]},"metadata":{},"sourceType":"script"}