{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EnumBinaryCodec = void 0;\n\nconst typesystem_1 = require(\"../typesystem\");\n\nconst fields_1 = require(\"./fields\");\n\nclass EnumBinaryCodec {\n  constructor(binaryCodec) {\n    this.binaryCodec = binaryCodec;\n    this.fieldsCodec = new fields_1.FieldsBinaryCodec(binaryCodec);\n  }\n\n  decodeTopLevel(buffer, type) {\n    // This handles enums without fields, with discriminant = 0, as well.\n    let [enumValue] = this.decodeNested(buffer, type);\n    return enumValue;\n  }\n\n  decodeNested(buffer, type) {\n    let [discriminant, lengthOfDiscriminant] = this.readDiscriminant(buffer);\n    buffer = buffer.slice(lengthOfDiscriminant);\n    let variant = type.getVariantByDiscriminant(discriminant);\n    let fieldDefinitions = variant.getFieldsDefinitions();\n    let [fields, lengthOfFields] = this.fieldsCodec.decodeNested(buffer, fieldDefinitions);\n    let enumValue = new typesystem_1.EnumValue(type, variant, fields);\n    return [enumValue, lengthOfDiscriminant + lengthOfFields];\n  }\n\n  readDiscriminant(buffer) {\n    let [value, length] = this.binaryCodec.decodeNested(buffer, new typesystem_1.U8Type());\n    let discriminant = value.valueOf();\n    return [discriminant, length];\n  }\n\n  encodeNested(enumValue) {\n    let discriminant = new typesystem_1.U8Value(enumValue.discriminant);\n    let discriminantBuffer = this.binaryCodec.encodeNested(discriminant);\n    let fields = enumValue.getFields();\n    let fieldsBuffer = this.fieldsCodec.encodeNested(fields);\n    return Buffer.concat([discriminantBuffer, fieldsBuffer]);\n  }\n\n  encodeTopLevel(enumValue) {\n    let fields = enumValue.getFields();\n    let hasFields = fields.length > 0;\n    let fieldsBuffer = this.fieldsCodec.encodeNested(fields);\n    let discriminant = new typesystem_1.U8Value(enumValue.discriminant);\n    let discriminantBuffer = hasFields ? this.binaryCodec.encodeNested(discriminant) : this.binaryCodec.encodeTopLevel(discriminant);\n    return Buffer.concat([discriminantBuffer, fieldsBuffer]);\n  }\n\n}\n\nexports.EnumBinaryCodec = EnumBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/enum.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,YAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAa,eAAb,CAA4B;AAIxB,EAAA,WAAA,CAAY,WAAZ,EAAoC;AAChC,SAAK,WAAL,GAAmB,WAAnB;AACA,SAAK,WAAL,GAAmB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,WAAtB,CAAnB;AACH;;AAED,EAAA,cAAc,CAAC,MAAD,EAAiB,IAAjB,EAA+B;AACzC;AACA,QAAI,CAAC,SAAD,IAAc,KAAK,YAAL,CAAkB,MAAlB,EAA0B,IAA1B,CAAlB;AACA,WAAO,SAAP;AACH;;AAED,EAAA,YAAY,CAAC,MAAD,EAAiB,IAAjB,EAA+B;AACvC,QAAI,CAAC,YAAD,EAAe,oBAAf,IAAuC,KAAK,gBAAL,CAAsB,MAAtB,CAA3C;AACA,IAAA,MAAM,GAAG,MAAM,CAAC,KAAP,CAAa,oBAAb,CAAT;AAEA,QAAI,OAAO,GAAG,IAAI,CAAC,wBAAL,CAA8B,YAA9B,CAAd;AACA,QAAI,gBAAgB,GAAG,OAAO,CAAC,oBAAR,EAAvB;AAEA,QAAI,CAAC,MAAD,EAAS,cAAT,IAA8C,KAAK,WAAL,CAAiB,YAAjB,CAA8B,MAA9B,EAAsC,gBAAtC,CAAlD;AACA,QAAI,SAAS,GAAG,IAAI,YAAA,CAAA,SAAJ,CAAc,IAAd,EAAoB,OAApB,EAA6B,MAA7B,CAAhB;AAEA,WAAO,CAAC,SAAD,EAAY,oBAAoB,GAAG,cAAnC,CAAP;AACH;;AAEO,EAAA,gBAAgB,CAAC,MAAD,EAAe;AACnC,QAAI,CAAC,KAAD,EAAQ,MAAR,IAAkB,KAAK,WAAL,CAAiB,YAAjB,CAA8B,MAA9B,EAAsC,IAAI,YAAA,CAAA,MAAJ,EAAtC,CAAtB;AACA,QAAI,YAAY,GAAG,KAAK,CAAC,OAAN,EAAnB;AAEA,WAAO,CAAC,YAAD,EAAe,MAAf,CAAP;AACH;;AAED,EAAA,YAAY,CAAC,SAAD,EAAqB;AAC7B,QAAI,YAAY,GAAG,IAAI,YAAA,CAAA,OAAJ,CAAY,SAAS,CAAC,YAAtB,CAAnB;AACA,QAAI,kBAAkB,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAA8B,YAA9B,CAAzB;AAEA,QAAI,MAAM,GAAG,SAAS,CAAC,SAAV,EAAb;AACA,QAAI,YAAY,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAA8B,MAA9B,CAAnB;AAEA,WAAO,MAAM,CAAC,MAAP,CAAc,CAAC,kBAAD,EAAqB,YAArB,CAAd,CAAP;AACH;;AAED,EAAA,cAAc,CAAC,SAAD,EAAqB;AAC/B,QAAI,MAAM,GAAG,SAAS,CAAC,SAAV,EAAb;AACA,QAAI,SAAS,GAAG,MAAM,CAAC,MAAP,GAAgB,CAAhC;AACA,QAAI,YAAY,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAA8B,MAA9B,CAAnB;AAEA,QAAI,YAAY,GAAG,IAAI,YAAA,CAAA,OAAJ,CAAY,SAAS,CAAC,YAAtB,CAAnB;AACA,QAAI,kBAAkB,GAAG,SAAS,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAA8B,YAA9B,CAAH,GAAiD,KAAK,WAAL,CAAiB,cAAjB,CAAgC,YAAhC,CAAnF;AAEA,WAAO,MAAM,CAAC,MAAP,CAAc,CAAC,kBAAD,EAAqB,YAArB,CAAd,CAAP;AACH;;AAtDuB;;AAA5B,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EnumBinaryCodec = void 0;\nconst typesystem_1 = require(\"../typesystem\");\nconst fields_1 = require(\"./fields\");\nclass EnumBinaryCodec {\n    constructor(binaryCodec) {\n        this.binaryCodec = binaryCodec;\n        this.fieldsCodec = new fields_1.FieldsBinaryCodec(binaryCodec);\n    }\n    decodeTopLevel(buffer, type) {\n        // This handles enums without fields, with discriminant = 0, as well.\n        let [enumValue] = this.decodeNested(buffer, type);\n        return enumValue;\n    }\n    decodeNested(buffer, type) {\n        let [discriminant, lengthOfDiscriminant] = this.readDiscriminant(buffer);\n        buffer = buffer.slice(lengthOfDiscriminant);\n        let variant = type.getVariantByDiscriminant(discriminant);\n        let fieldDefinitions = variant.getFieldsDefinitions();\n        let [fields, lengthOfFields] = this.fieldsCodec.decodeNested(buffer, fieldDefinitions);\n        let enumValue = new typesystem_1.EnumValue(type, variant, fields);\n        return [enumValue, lengthOfDiscriminant + lengthOfFields];\n    }\n    readDiscriminant(buffer) {\n        let [value, length] = this.binaryCodec.decodeNested(buffer, new typesystem_1.U8Type());\n        let discriminant = value.valueOf();\n        return [discriminant, length];\n    }\n    encodeNested(enumValue) {\n        let discriminant = new typesystem_1.U8Value(enumValue.discriminant);\n        let discriminantBuffer = this.binaryCodec.encodeNested(discriminant);\n        let fields = enumValue.getFields();\n        let fieldsBuffer = this.fieldsCodec.encodeNested(fields);\n        return Buffer.concat([discriminantBuffer, fieldsBuffer]);\n    }\n    encodeTopLevel(enumValue) {\n        let fields = enumValue.getFields();\n        let hasFields = fields.length > 0;\n        let fieldsBuffer = this.fieldsCodec.encodeNested(fields);\n        let discriminant = new typesystem_1.U8Value(enumValue.discriminant);\n        let discriminantBuffer = hasFields ? this.binaryCodec.encodeNested(discriminant) : this.binaryCodec.encodeTopLevel(discriminant);\n        return Buffer.concat([discriminantBuffer, fieldsBuffer]);\n    }\n}\nexports.EnumBinaryCodec = EnumBinaryCodec;\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}