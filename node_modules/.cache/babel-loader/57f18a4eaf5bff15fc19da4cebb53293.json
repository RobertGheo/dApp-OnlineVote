{"ast":null,"code":"const SIGN_RAW_TX_INS = 0x04;\nconst SIGN_HASH_TX_INS = 0x07;\nconst SIGN_MESSAGE_INS = 0x06;\nconst GET_ADDRESS_AUTH_TOKEN_INS = 0x09;\nconst ACTIVE_SIGNERS = [SIGN_RAW_TX_INS, SIGN_HASH_TX_INS, SIGN_MESSAGE_INS, GET_ADDRESS_AUTH_TOKEN_INS];\nexport default class Elrond {\n  constructor(transport) {\n    let scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"eGLD\";\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"setAddress\", \"signTransaction\", \"signMessage\", \"getAppConfiguration\", \"getAddressAndSignAuthToken\"], scrambleKey);\n  }\n\n  async getAddress(account, index, display) {\n    const cla = 0xed;\n    const ins = 0x03;\n    const p1 = display ? 0x01 : 0x00;\n    const p2 = 0x00;\n    const data = Buffer.alloc(8);\n    data.writeInt32BE(account, 0);\n    data.writeUInt32BE(index, 4);\n    const response = await this.transport.send(cla, ins, p1, p2, data);\n    const addressLength = response[0];\n    const address = response.slice(1, 1 + addressLength).toString(\"ascii\");\n    return {\n      address\n    };\n  }\n\n  async setAddress(account, index, display) {\n    const cla = 0xed;\n    const ins = 0x05;\n    const p1 = display ? 0x01 : 0x00;\n    const p2 = 0x00;\n    const data = Buffer.alloc(8);\n    data.writeInt32BE(account, 0);\n    data.writeUInt32BE(index, 4);\n    return await this.transport.send(cla, ins, p1, p2, data);\n  }\n\n  async signTransaction(rawTx, usingHash) {\n    return usingHash ? this.sign(rawTx, SIGN_HASH_TX_INS) : this.sign(rawTx, SIGN_RAW_TX_INS);\n  }\n\n  async signMessage(message) {\n    return this.sign(message, SIGN_MESSAGE_INS);\n  }\n\n  async getAddressAndSignAuthToken(account, index, token) {\n    const data = Buffer.alloc(12);\n    data.writeInt32BE(account, 0);\n    data.writeUInt32BE(index, 4);\n    data.writeUInt32BE(token.length, 8);\n    let buffersArray = [data, token];\n    let result = await this.sign(Buffer.concat(buffersArray), GET_ADDRESS_AUTH_TOKEN_INS);\n    let splitRes = result.split(\"|\");\n    return {\n      address: splitRes[0],\n      signature: splitRes[1]\n    };\n  }\n\n  async getAppConfiguration() {\n    const response = await this.transport.send(0xed, 0x02, 0x00, 0x00);\n    return {\n      contractData: response[0],\n      accountIndex: response[1],\n      addressIndex: response[2],\n      version: `${response[3]}.${response[4]}.${response[5]}`\n    };\n  }\n\n  async sign(message, type) {\n    if (!ACTIVE_SIGNERS.includes(type)) {\n      throw new Error(`invalid sign instruction called: ${type}`);\n    }\n\n    const apdus = [];\n    let offset = 0;\n\n    while (offset !== message.length) {\n      const isFirst = offset === 0;\n      const maxChunkSize = 150;\n      const hasMore = offset + maxChunkSize < message.length;\n      const chunkSize = hasMore ? maxChunkSize : message.length - offset;\n      const apdu = {\n        cla: 0xed,\n        ins: type,\n        p1: isFirst ? 0x00 : 0x80,\n        p2: 0x00,\n        data: Buffer.alloc(chunkSize)\n      };\n      message.copy(apdu.data, 0, offset, offset + chunkSize);\n      apdus.push(apdu);\n      offset += chunkSize;\n    }\n\n    let response = Buffer.alloc(0);\n\n    for (let apdu of apdus) {\n      response = await this.transport.send(apdu.cla, apdu.ins, apdu.p1, apdu.p2, apdu.data);\n    }\n\n    if (GET_ADDRESS_AUTH_TOKEN_INS === type) {\n      return this.handleAuthTokenResponse(response);\n    }\n\n    if (response.length !== 67 || response[0] !== 64) {\n      throw new Error(\"invalid signature received from ledger device\");\n    }\n\n    return response.slice(1, response.length - 2).toString(\"hex\");\n  }\n\n  handleAuthTokenResponse(response) {\n    if (response.length !== 129 && response[0] !== 126) {\n      throw new Error(\"invalid address and token signature received from ledger device\");\n    }\n\n    const address = response.slice(1, 63).toString(\"ascii\");\n    const signature = response.slice(63, response.length - 2).toString(\"hex\");\n    return address + \"|\" + signature;\n  }\n\n}","map":{"version":3,"sources":["../src/Elrond.js"],"names":["SIGN_RAW_TX_INS","SIGN_HASH_TX_INS","SIGN_MESSAGE_INS","GET_ADDRESS_AUTH_TOKEN_INS","ACTIVE_SIGNERS","transport","constructor","scrambleKey","getAddress","cla","ins","p1","display","p2","data","Buffer","response","addressLength","address","setAddress","signTransaction","usingHash","signMessage","getAddressAndSignAuthToken","token","buffersArray","result","splitRes","signature","getAppConfiguration","contractData","accountIndex","addressIndex","version","sign","type","apdus","offset","message","isFirst","maxChunkSize","hasMore","chunkSize","apdu","handleAuthTokenResponse"],"mappings":"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","sourcesContent":["//@flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\n\nconst SIGN_RAW_TX_INS = 0x04;\nconst SIGN_HASH_TX_INS = 0x07;\nconst SIGN_MESSAGE_INS = 0x06;\nconst GET_ADDRESS_AUTH_TOKEN_INS = 0x09;\n\nconst ACTIVE_SIGNERS = [\n    SIGN_RAW_TX_INS,\n    SIGN_HASH_TX_INS,\n    SIGN_MESSAGE_INS,\n    GET_ADDRESS_AUTH_TOKEN_INS\n];\n\nexport default class Elrond {\n    transport: Transport<*>;\n\n    constructor(transport: Transport<*>, scrambleKey: string = \"eGLD\") {\n        this.transport = transport;\n        transport.decorateAppAPIMethods(\n            this,\n            [\"getAddress\", \"setAddress\", \"signTransaction\", \"signMessage\", \"getAppConfiguration\", \"getAddressAndSignAuthToken\"],\n            scrambleKey\n        );\n    }\n\n    async getAddress(\n        account: number,\n        index: number,\n        display?: boolean,\n    ): Promise<{\n        publicKey: string,\n        address: string,\n        chainCode?: string,\n    }> {\n        const cla = 0xed;\n        const ins = 0x03;\n        const p1 = display ? 0x01 : 0x00;\n        const p2 = 0x00;\n        const data = Buffer.alloc(8);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n\n        const response = await this.transport.send(cla, ins, p1, p2, data);\n\n        const addressLength = response[0];\n        const address = response.slice(1, 1 + addressLength).toString(\"ascii\");\n\n        return {address};\n    }\n\n    async setAddress(\n        account: number,\n        index: number,\n        display?: boolean,\n    ) {\n        const cla = 0xed;\n        const ins = 0x05;\n        const p1 = display ? 0x01 : 0x00;\n        const p2 = 0x00;\n        const data = Buffer.alloc(8);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n\n        return await this.transport.send(cla, ins, p1, p2, data);\n    }\n\n    async signTransaction(\n        rawTx: Buffer,\n        usingHash: boolean,\n    ): Promise<string> {\n        return usingHash ? this.sign(rawTx, SIGN_HASH_TX_INS) :\n            this.sign(rawTx, SIGN_RAW_TX_INS);\n    }\n\n    async signMessage(message: Buffer): Promise<string> {\n        return this.sign(message, SIGN_MESSAGE_INS);\n    }\n\n    async getAddressAndSignAuthToken(\n        account: number,\n        index: number,\n        token: Buffer,\n    ): Promise<{\n        address: string,\n        signature: string,\n    }> {\n        const data = Buffer.alloc(12);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n        data.writeUInt32BE(token.length, 8);\n\n        let buffersArray = [data, token];\n        let result = await this.sign(Buffer.concat(buffersArray), GET_ADDRESS_AUTH_TOKEN_INS);\n\n        let splitRes = result.split(\"|\");\n        return {\n            address: splitRes[0],\n            signature: splitRes[1]\n        }\n    }\n\n    async getAppConfiguration(): Promise<{\n        version: string,\n    }> {\n        const response = await this.transport.send(0xed, 0x02, 0x00, 0x00);\n        return {\n            contractData: response[0],\n            accountIndex: response[1],\n            addressIndex: response[2],\n            version: `${response[3]}.${response[4]}.${response[5]}`\n        }\n    }\n\n    async sign(message: Buffer, type: number): Promise<string> {\n        if (!ACTIVE_SIGNERS.includes(type)) {\n            throw new Error(`invalid sign instruction called: ${type}`);\n        }\n\n        const apdus = [];\n        let offset = 0;\n\n        while (offset !== message.length) {\n            const isFirst = offset === 0;\n            const maxChunkSize = 150;\n\n            const hasMore = offset + maxChunkSize < message.length;\n            const chunkSize = hasMore ? maxChunkSize : message.length - offset;\n\n            const apdu = {\n                cla: 0xed,\n                ins: type,\n                p1: isFirst ? 0x00 : 0x80,\n                p2: 0x00,\n                data: Buffer.alloc(chunkSize),\n            };\n\n            message.copy(apdu.data, 0, offset, offset + chunkSize);\n\n            apdus.push(apdu);\n            offset += chunkSize;\n        }\n\n        let response = Buffer.alloc(0);\n        for (let apdu of apdus) {\n            response = await this.transport.send(\n                apdu.cla,\n                apdu.ins,\n                apdu.p1,\n                apdu.p2,\n                apdu.data\n            );\n        }\n\n        if (GET_ADDRESS_AUTH_TOKEN_INS === type) {\n            return this.handleAuthTokenResponse(response);\n        }\n\n        if (response.length !== 67 || response[0] !== 64) {\n            throw new Error(\"invalid signature received from ledger device\")\n        }\n\n        return response.slice(1, response.length - 2).toString(\"hex\");\n    }\n\n    handleAuthTokenResponse(response: Buffer) : Promise<string> {\n        if (response.length !== 129 && response[0] !== 126) {\n            throw new Error(\"invalid address and token signature received from ledger device\")\n        }\n\n        const address = response.slice(1, 63).toString(\"ascii\");\n        const signature = response.slice(63, response.length - 2).toString(\"hex\");\n        return address + \"|\" + signature;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}