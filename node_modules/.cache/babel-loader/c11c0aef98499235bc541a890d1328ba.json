{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefaultInteractionRunner = void 0;\n/**\n * An interaction runner suitable for backends or wallets.\n * Not suitable for dapps, which depend on external signers (wallets, ledger etc.).\n */\n\nclass DefaultInteractionRunner {\n  constructor(checker, signer, provider) {\n    this.checker = checker;\n    this.signer = signer;\n    this.provider = provider;\n  }\n  /**\n   * Given an interaction, broadcasts its compiled transaction.\n   */\n\n\n  run(interaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.checkInteraction(interaction);\n      let transaction = interaction.buildTransaction();\n      yield this.signer.sign(transaction);\n      yield transaction.send(this.provider);\n      return transaction;\n    });\n  }\n  /**\n   * Given an interaction, broadcasts its compiled transaction (and also waits for its execution on the Network).\n   */\n\n\n  runAwaitExecution(interaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.checkInteraction(interaction);\n      let transaction = yield this.run(interaction);\n      yield transaction.awaitExecuted(this.provider); // This will wait until the transaction is notarized, as well (so that SCRs are returned by the API).\n\n      let transactionOnNetwork = yield transaction.getAsOnNetwork(this.provider);\n      let bundle = interaction.interpretExecutionResults(transactionOnNetwork);\n      return bundle;\n    });\n  }\n\n  runQuery(interaction, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.checkInteraction(interaction);\n      let query = interaction.buildQuery();\n      query.caller = caller || this.signer.getAddress();\n      let response = yield this.provider.queryContract(query);\n      let bundle = interaction.interpretQueryResponse(response);\n      return bundle;\n    });\n  }\n\n  runSimulation(interaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.checkInteraction(interaction);\n      let transaction = interaction.buildTransaction();\n      yield this.signer.sign(transaction);\n      return yield transaction.simulate(this.provider);\n    });\n  }\n\n  checkInteraction(interaction) {\n    this.checker.checkInteraction(interaction);\n  }\n\n}\n\nexports.DefaultInteractionRunner = DefaultInteractionRunner;","map":{"version":3,"sources":["../../src/smartcontracts/defaultRunner.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;AAGG;;AACH,MAAa,wBAAb,CAAqC;AAKjC,EAAA,WAAA,CAAY,OAAZ,EAA0C,MAA1C,EAA2D,QAA3D,EAA8E;AAC1E,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,QAAL,GAAgB,QAAhB;AACH;AAED;;AAEG;;;AACG,EAAA,GAAG,CAAC,WAAD,EAAyB;;AAC9B,WAAK,gBAAL,CAAsB,WAAtB;AAEA,UAAI,WAAW,GAAG,WAAW,CAAC,gBAAZ,EAAlB;AACA,YAAM,KAAK,MAAL,CAAY,IAAZ,CAAiB,WAAjB,CAAN;AACA,YAAM,WAAW,CAAC,IAAZ,CAAiB,KAAK,QAAtB,CAAN;AACA,aAAO,WAAP;AACH,K;AAAA;AAED;;AAEG;;;AACG,EAAA,iBAAiB,CAAC,WAAD,EAAyB;;AAC5C,WAAK,gBAAL,CAAsB,WAAtB;AAEA,UAAI,WAAW,GAAG,MAAM,KAAK,GAAL,CAAS,WAAT,CAAxB;AACA,YAAM,WAAW,CAAC,aAAZ,CAA0B,KAAK,QAA/B,CAAN,C,CACA;;AACA,UAAI,oBAAoB,GAAG,MAAM,WAAW,CAAC,cAAZ,CAA2B,KAAK,QAAhC,CAAjC;AACA,UAAI,MAAM,GAAG,WAAW,CAAC,yBAAZ,CAAsC,oBAAtC,CAAb;AACA,aAAO,MAAP;AACH,K;AAAA;;AAEK,EAAA,QAAQ,CAAC,WAAD,EAA2B,MAA3B,EAA2C;;AACrD,WAAK,gBAAL,CAAsB,WAAtB;AAEA,UAAI,KAAK,GAAG,WAAW,CAAC,UAAZ,EAAZ;AACA,MAAA,KAAK,CAAC,MAAN,GAAe,MAAM,IAAI,KAAK,MAAL,CAAY,UAAZ,EAAzB;AACA,UAAI,QAAQ,GAAG,MAAM,KAAK,QAAL,CAAc,aAAd,CAA4B,KAA5B,CAArB;AACA,UAAI,MAAM,GAAG,WAAW,CAAC,sBAAZ,CAAmC,QAAnC,CAAb;AACA,aAAO,MAAP;AACH,K;AAAA;;AAEK,EAAA,aAAa,CAAC,WAAD,EAAyB;;AACxC,WAAK,gBAAL,CAAsB,WAAtB;AAEA,UAAI,WAAW,GAAG,WAAW,CAAC,gBAAZ,EAAlB;AACA,YAAM,KAAK,MAAL,CAAY,IAAZ,CAAiB,WAAjB,CAAN;AACA,aAAO,MAAM,WAAW,CAAC,QAAZ,CAAqB,KAAK,QAA1B,CAAb;AACH,K;AAAA;;AAEO,EAAA,gBAAgB,CAAC,WAAD,EAAyB;AAC7C,SAAK,OAAL,CAAa,gBAAb,CAA8B,WAA9B;AACH;;AAzDgC;;AAArC,OAAA,CAAA,wBAAA,GAAA,wBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultInteractionRunner = void 0;\n/**\n * An interaction runner suitable for backends or wallets.\n * Not suitable for dapps, which depend on external signers (wallets, ledger etc.).\n */\nclass DefaultInteractionRunner {\n    constructor(checker, signer, provider) {\n        this.checker = checker;\n        this.signer = signer;\n        this.provider = provider;\n    }\n    /**\n     * Given an interaction, broadcasts its compiled transaction.\n     */\n    run(interaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.checkInteraction(interaction);\n            let transaction = interaction.buildTransaction();\n            yield this.signer.sign(transaction);\n            yield transaction.send(this.provider);\n            return transaction;\n        });\n    }\n    /**\n     * Given an interaction, broadcasts its compiled transaction (and also waits for its execution on the Network).\n     */\n    runAwaitExecution(interaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.checkInteraction(interaction);\n            let transaction = yield this.run(interaction);\n            yield transaction.awaitExecuted(this.provider);\n            // This will wait until the transaction is notarized, as well (so that SCRs are returned by the API).\n            let transactionOnNetwork = yield transaction.getAsOnNetwork(this.provider);\n            let bundle = interaction.interpretExecutionResults(transactionOnNetwork);\n            return bundle;\n        });\n    }\n    runQuery(interaction, caller) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.checkInteraction(interaction);\n            let query = interaction.buildQuery();\n            query.caller = caller || this.signer.getAddress();\n            let response = yield this.provider.queryContract(query);\n            let bundle = interaction.interpretQueryResponse(response);\n            return bundle;\n        });\n    }\n    runSimulation(interaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.checkInteraction(interaction);\n            let transaction = interaction.buildTransaction();\n            yield this.signer.sign(transaction);\n            return yield transaction.simulate(this.provider);\n        });\n    }\n    checkInteraction(interaction) {\n        this.checker.checkInteraction(interaction);\n    }\n}\nexports.DefaultInteractionRunner = DefaultInteractionRunner;\n//# sourceMappingURL=defaultRunner.js.map"]},"metadata":{},"sourceType":"script"}