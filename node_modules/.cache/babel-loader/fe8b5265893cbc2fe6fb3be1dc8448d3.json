{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Struct = exports.StructType = void 0;\n\nconst fields_1 = require(\"./fields\");\n\nconst types_1 = require(\"./types\");\n\nclass StructType extends types_1.CustomType {\n  constructor(name, fieldsDefinitions) {\n    super(name);\n    this.fieldsDefinitions = [];\n    this.fieldsDefinitions = fieldsDefinitions;\n  }\n\n  static fromJSON(json) {\n    let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n    return new StructType(json.name, definitions);\n  }\n\n  getFieldsDefinitions() {\n    return this.fieldsDefinitions;\n  }\n\n}\n\nexports.StructType = StructType; // TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\n\nclass Struct extends types_1.TypedValue {\n  /**\n   * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n   */\n  constructor(type, fields) {\n    super(type);\n    this.fields = [];\n    this.fields = fields;\n    this.checkTyping();\n  }\n\n  checkTyping() {\n    let type = this.getType();\n    let definitions = type.getFieldsDefinitions();\n    fields_1.Fields.checkTyping(this.fields, definitions);\n  }\n\n  getFields() {\n    return this.fields;\n  }\n\n  valueOf() {\n    let result = {};\n\n    for (const field of this.fields) {\n      result[field.name] = field.value.valueOf();\n    }\n\n    return result;\n  }\n\n  equals(other) {\n    if (!this.getType().equals(other.getType())) {\n      return false;\n    }\n\n    let selfFields = this.getFields();\n    let otherFields = other.getFields();\n    return fields_1.Fields.equals(selfFields, otherFields);\n  }\n\n}\n\nexports.Struct = Struct;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/struct.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAa,UAAb,SAAgC,OAAA,CAAA,UAAhC,CAA0C;AAGtC,EAAA,WAAA,CAAY,IAAZ,EAA0B,iBAA1B,EAA8D;AAC1D,UAAM,IAAN;AAHa,SAAA,iBAAA,GAAuC,EAAvC;AAIb,SAAK,iBAAL,GAAyB,iBAAzB;AACH;;AAEc,SAAR,QAAQ,CAAC,IAAD,EAAsC;AACjD,QAAI,WAAW,GAAG,CAAC,IAAI,CAAC,MAAL,IAAe,EAAhB,EAAoB,GAApB,CAAwB,UAAU,IAAI,QAAA,CAAA,eAAA,CAAgB,QAAhB,CAAyB,UAAzB,CAAtC,CAAlB;AACA,WAAO,IAAI,UAAJ,CAAe,IAAI,CAAC,IAApB,EAA0B,WAA1B,CAAP;AACH;;AAED,EAAA,oBAAoB,GAAA;AAChB,WAAO,KAAK,iBAAZ;AACH;;AAfqC;;AAA1C,OAAA,CAAA,UAAA,GAAA,UAAA,C,CAkBA;AACA;;AACA,MAAa,MAAb,SAA4B,OAAA,CAAA,UAA5B,CAAsC;AAGlC;;AAEG;AACH,EAAA,WAAA,CAAY,IAAZ,EAA8B,MAA9B,EAA6C;AACzC,UAAM,IAAN;AANa,SAAA,MAAA,GAAkB,EAAlB;AAOb,SAAK,MAAL,GAAc,MAAd;AAEA,SAAK,WAAL;AACH;;AAEO,EAAA,WAAW,GAAA;AACf,QAAI,IAAI,GAAe,KAAK,OAAL,EAAvB;AACA,QAAI,WAAW,GAAG,IAAI,CAAC,oBAAL,EAAlB;AACA,IAAA,QAAA,CAAA,MAAA,CAAO,WAAP,CAAmB,KAAK,MAAxB,EAAgC,WAAhC;AACH;;AAED,EAAA,SAAS,GAAA;AACL,WAAO,KAAK,MAAZ;AACH;;AAED,EAAA,OAAO,GAAA;AACH,QAAI,MAAM,GAAQ,EAAlB;;AAEA,SAAK,MAAM,KAAX,IAAoB,KAAK,MAAzB,EAAiC;AAC7B,MAAA,MAAM,CAAC,KAAK,CAAC,IAAP,CAAN,GAAqB,KAAK,CAAC,KAAN,CAAY,OAAZ,EAArB;AACH;;AAED,WAAO,MAAP;AACH;;AAED,EAAA,MAAM,CAAC,KAAD,EAAc;AAChB,QAAI,CAAC,KAAK,OAAL,GAAe,MAAf,CAAsB,KAAK,CAAC,OAAN,EAAtB,CAAL,EAA6C;AACzC,aAAO,KAAP;AACH;;AAED,QAAI,UAAU,GAAG,KAAK,SAAL,EAAjB;AACA,QAAI,WAAW,GAAG,KAAK,CAAC,SAAN,EAAlB;AAEA,WAAO,QAAA,CAAA,MAAA,CAAO,MAAP,CAAc,UAAd,EAA0B,WAA1B,CAAP;AACH;;AA1CiC;;AAAtC,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Struct = exports.StructType = void 0;\nconst fields_1 = require(\"./fields\");\nconst types_1 = require(\"./types\");\nclass StructType extends types_1.CustomType {\n    constructor(name, fieldsDefinitions) {\n        super(name);\n        this.fieldsDefinitions = [];\n        this.fieldsDefinitions = fieldsDefinitions;\n    }\n    static fromJSON(json) {\n        let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n        return new StructType(json.name, definitions);\n    }\n    getFieldsDefinitions() {\n        return this.fieldsDefinitions;\n    }\n}\nexports.StructType = StructType;\n// TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\nclass Struct extends types_1.TypedValue {\n    /**\n     * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n     */\n    constructor(type, fields) {\n        super(type);\n        this.fields = [];\n        this.fields = fields;\n        this.checkTyping();\n    }\n    checkTyping() {\n        let type = this.getType();\n        let definitions = type.getFieldsDefinitions();\n        fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n    getFields() {\n        return this.fields;\n    }\n    valueOf() {\n        let result = {};\n        for (const field of this.fields) {\n            result[field.name] = field.value.valueOf();\n        }\n        return result;\n    }\n    equals(other) {\n        if (!this.getType().equals(other.getType())) {\n            return false;\n        }\n        let selfFields = this.getFields();\n        let otherFields = other.getFields();\n        return fields_1.Fields.equals(selfFields, otherFields);\n    }\n}\nexports.Struct = Struct;\n//# sourceMappingURL=struct.js.map"]},"metadata":{},"sourceType":"script"}