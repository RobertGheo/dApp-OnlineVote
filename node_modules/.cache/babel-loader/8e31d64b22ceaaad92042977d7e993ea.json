{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserPublicKey = exports.UserSecretKey = exports.USER_PUBKEY_LENGTH = exports.USER_SEED_LENGTH = void 0;\n\nconst tweetnacl = __importStar(require(\"tweetnacl\"));\n\nconst address_1 = require(\"../address\");\n\nconst utils_1 = require(\"../utils\");\n\nconst pem_1 = require(\"./pem\");\n\nconst logger_1 = require(\"../logger\");\n\nexports.USER_SEED_LENGTH = 32;\nexports.USER_PUBKEY_LENGTH = 32;\n\nclass UserSecretKey {\n  constructor(buffer) {\n    utils_1.guardLength(buffer, exports.USER_SEED_LENGTH);\n    this.buffer = buffer;\n  }\n\n  static fromString(value) {\n    utils_1.guardLength(value, exports.USER_SEED_LENGTH * 2);\n    let buffer = Buffer.from(value, \"hex\");\n    return new UserSecretKey(buffer);\n  }\n\n  static fromPem(text) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return pem_1.parseUserKey(text, index);\n  }\n\n  generatePublicKey() {\n    let keyPair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\n    let buffer = Buffer.from(keyPair.publicKey);\n    return new UserPublicKey(buffer);\n  }\n\n  sign(message) {\n    let pair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\n    let signingKey = pair.secretKey;\n    let signature = tweetnacl.sign(new Uint8Array(message), signingKey); // \"tweetnacl.sign()\" returns the concatenated [signature, message], therfore we remove the appended message:\n\n    signature = signature.slice(0, signature.length - message.length);\n    return Buffer.from(signature);\n  }\n\n  hex() {\n    return this.buffer.toString(\"hex\");\n  }\n\n  valueOf() {\n    return this.buffer;\n  }\n\n}\n\nexports.UserSecretKey = UserSecretKey;\n\nclass UserPublicKey {\n  constructor(buffer) {\n    utils_1.guardLength(buffer, exports.USER_PUBKEY_LENGTH);\n    this.buffer = buffer;\n  }\n\n  verify(message, signature) {\n    try {\n      const unopenedMessage = Buffer.concat([signature, message]);\n      const unsignedMessage = tweetnacl.sign.open(unopenedMessage, this.buffer);\n      return unsignedMessage != null;\n    } catch (err) {\n      logger_1.Logger.error(err);\n      return false;\n    }\n  }\n\n  hex() {\n    return this.buffer.toString(\"hex\");\n  }\n\n  toAddress() {\n    return new address_1.Address(this.buffer);\n  }\n\n  valueOf() {\n    return this.buffer;\n  }\n\n}\n\nexports.UserPublicKey = UserPublicKey;","map":{"version":3,"sources":["../../src/walletcore/userKeys.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UserPublicKey = exports.UserSecretKey = exports.USER_PUBKEY_LENGTH = exports.USER_SEED_LENGTH = void 0;\nconst tweetnacl = __importStar(require(\"tweetnacl\"));\nconst address_1 = require(\"../address\");\nconst utils_1 = require(\"../utils\");\nconst pem_1 = require(\"./pem\");\nconst logger_1 = require(\"../logger\");\nexports.USER_SEED_LENGTH = 32;\nexports.USER_PUBKEY_LENGTH = 32;\nclass UserSecretKey {\n    constructor(buffer) {\n        utils_1.guardLength(buffer, exports.USER_SEED_LENGTH);\n        this.buffer = buffer;\n    }\n    static fromString(value) {\n        utils_1.guardLength(value, exports.USER_SEED_LENGTH * 2);\n        let buffer = Buffer.from(value, \"hex\");\n        return new UserSecretKey(buffer);\n    }\n    static fromPem(text, index = 0) {\n        return pem_1.parseUserKey(text, index);\n    }\n    generatePublicKey() {\n        let keyPair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\n        let buffer = Buffer.from(keyPair.publicKey);\n        return new UserPublicKey(buffer);\n    }\n    sign(message) {\n        let pair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\n        let signingKey = pair.secretKey;\n        let signature = tweetnacl.sign(new Uint8Array(message), signingKey);\n        // \"tweetnacl.sign()\" returns the concatenated [signature, message], therfore we remove the appended message:\n        signature = signature.slice(0, signature.length - message.length);\n        return Buffer.from(signature);\n    }\n    hex() {\n        return this.buffer.toString(\"hex\");\n    }\n    valueOf() {\n        return this.buffer;\n    }\n}\nexports.UserSecretKey = UserSecretKey;\nclass UserPublicKey {\n    constructor(buffer) {\n        utils_1.guardLength(buffer, exports.USER_PUBKEY_LENGTH);\n        this.buffer = buffer;\n    }\n    verify(message, signature) {\n        try {\n            const unopenedMessage = Buffer.concat([signature, message]);\n            const unsignedMessage = tweetnacl.sign.open(unopenedMessage, this.buffer);\n            return unsignedMessage != null;\n        }\n        catch (err) {\n            logger_1.Logger.error(err);\n            return false;\n        }\n    }\n    hex() {\n        return this.buffer.toString(\"hex\");\n    }\n    toAddress() {\n        return new address_1.Address(this.buffer);\n    }\n    valueOf() {\n        return this.buffer;\n    }\n}\nexports.UserPublicKey = UserPublicKey;\n//# sourceMappingURL=userKeys.js.map"]},"metadata":{},"sourceType":"script"}