{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectProvider = void 0;\n\nconst client_1 = __importDefault(require(\"@walletconnect/client\"));\n\nconst address_1 = require(\"../address\");\n\nconst signature_1 = require(\"../signature\");\n\nconst constants_1 = require(\"./constants\");\n\nconst logger_1 = require(\"../logger\");\n\nconst errors_1 = require(\"../errors\");\n\nclass WalletConnectProvider {\n  constructor(httpProvider) {\n    let walletConnectBridge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let onClientConnect = arguments.length > 2 ? arguments[2] : undefined;\n    this.address = \"\";\n    this.signature = \"\";\n    this.provider = httpProvider;\n    this.walletConnectBridge = walletConnectBridge;\n    this.onClientConnect = onClientConnect;\n  }\n  /**\n   * Initiates wallet connect client.\n   */\n\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.walletConnector = new client_1.default({\n        bridge: this.walletConnectBridge\n      });\n      this.walletConnector.on(\"connect\", this.onConnect.bind(this));\n      this.walletConnector.on(\"session_update\", this.onDisconnect.bind(this));\n      this.walletConnector.on(\"disconnect\", this.onDisconnect.bind(this));\n\n      if (this.walletConnector.connected && this.walletConnector.accounts.length) {\n        const [account] = this.walletConnector.accounts;\n        const [address, signature] = account.split(\".\");\n        yield this.loginAccount(address, signature);\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Returns true if init() was previously called successfully\n   */\n\n\n  isInitialized() {\n    return !!this.walletConnector;\n  }\n  /**\n   * Mocked function, returns isInitialized as an async function\n   */\n\n\n  isConnected() {\n    return new Promise((resolve, _) => resolve(this.isInitialized()));\n  }\n  /**\n   *\n   */\n\n\n  login() {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        yield this.init();\n      }\n\n      if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n        yield this.walletConnector.killSession();\n        logger_1.Logger.trace(\"WalletConnect login started but walletConnect not initialized\");\n        return \"\";\n      }\n\n      yield (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.createSession({\n        chainId: constants_1.WALLETCONNECT_ELROND_CHAIN_ID\n      });\n\n      if (!((_c = this.walletConnector) === null || _c === void 0 ? void 0 : _c.uri)) {\n        return \"\";\n      }\n\n      return (_d = this.walletConnector) === null || _d === void 0 ? void 0 : _d.uri;\n    });\n  }\n  /**\n   * Mocks a logout request by returning true\n   */\n\n\n  logout() {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"logout: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n        yield (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession();\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Fetches the wallet connect address\n   */\n\n\n  getAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"getAddress: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      return this.address;\n    });\n  }\n  /**\n   * Fetches the wallet connect signature\n   */\n\n\n  getSignature() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"getSignature: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      return this.signature;\n    });\n  }\n  /**\n   * Signs and sends a transaction. Returns the transaction hash\n   * @param transaction\n   */\n\n\n  sendTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"sendTransaction: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      transaction = yield this.signTransaction(transaction);\n      yield transaction.send(this.provider);\n      return transaction;\n    });\n  }\n  /**\n   * Method will be available once the Maiar wallet connect hook is implemented\n   * @param _\n   */\n\n\n  signMessage(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new errors_1.ErrNotImplemented();\n    });\n  }\n  /**\n   * Signs a transaction and returns it\n   * @param transaction\n   */\n\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"signTransaction: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      const address = yield this.getAddress();\n      const sig = yield this.walletConnector.sendCustomRequest({\n        method: \"erd_sign\",\n        params: this.prepareWalletConnectMessage(transaction, address)\n      });\n\n      if (!sig || !sig.signature) {\n        logger_1.Logger.error(\"signTransaction: Wallet Connect could not sign the transaction\");\n        throw new Error(\"Wallet Connect could not sign the transaction\");\n      }\n\n      transaction.applySignature(new signature_1.Signature(sig.signature), new address_1.Address(address));\n      return transaction;\n    });\n  }\n  /**\n   * Signs an array of transactions and returns it\n   * @param transactions\n   */\n\n\n  signTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"signTransactions: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      const address = yield this.getAddress();\n      const params = transactions.map(transaction => this.prepareWalletConnectMessage(transaction, address));\n      const signatures = yield this.walletConnector.sendCustomRequest({\n        method: \"erd_batch_sign\",\n        params\n      });\n\n      if (!signatures) {\n        logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions\");\n        throw new Error(\"Wallet Connect could not sign the transactions\");\n      }\n\n      if (Array.isArray(signatures)) {\n        if (transactions.length !== signatures.length) {\n          logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions. Invalid signatures.\");\n          throw new Error(\"Wallet Connect could not sign the transactions. Invalid signatures.\");\n        }\n\n        transactions.map((transaction, key) => transaction.applySignature(new signature_1.Signature(signatures[key].signature), new address_1.Address(address)));\n        return transactions;\n      }\n\n      transactions[0].applySignature(new signature_1.Signature(signatures.signature), new address_1.Address(address));\n      return transactions;\n    });\n  }\n  /**\n   * Sends a custom method and params and returns the response object\n   */\n\n\n  sendCustomMessage(_ref) {\n    let {\n      method,\n      params\n    } = _ref;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"sendCustomMessage: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      const customMessageResponse = yield this.walletConnector.sendCustomRequest({\n        method,\n        params\n      });\n\n      if (!customMessageResponse) {\n        logger_1.Logger.error(\"sendCustomMessage: Wallet Connect could not send the message\");\n        throw new Error(\"Wallet Connect could not send the message\");\n      }\n\n      return customMessageResponse;\n    });\n  }\n\n  onConnect(error, _ref2) {\n    let {\n      params\n    } = _ref2;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (error) {\n        throw error;\n      }\n\n      if (!params || !params[0]) {\n        logger_1.Logger.error(\"Wallet Connect missing payload\");\n        throw new Error(\"missing payload\");\n      }\n\n      const {\n        accounts: [account]\n      } = params[0];\n      const [address, signature] = account.split(\".\");\n      yield this.loginAccount(address, signature);\n    });\n  }\n\n  onDisconnect(error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (error) {\n        throw error;\n      }\n\n      this.onClientConnect.onClientLogout();\n    });\n  }\n\n  loginAccount(address, signature) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.addressIsValid(address)) {\n        this.address = address;\n\n        if (signature) {\n          this.signature = signature;\n        }\n\n        this.onClientConnect.onClientLogin();\n        return;\n      }\n\n      logger_1.Logger.error(`Wallet Connect invalid address ${address}`);\n\n      if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n        yield (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession();\n      }\n    });\n  }\n\n  prepareWalletConnectMessage(transaction, address) {\n    return {\n      nonce: transaction.getNonce().valueOf(),\n      from: address,\n      to: transaction.getReceiver().toString(),\n      amount: transaction.getValue().toString(),\n      gasPrice: transaction.getGasPrice().valueOf().toString(),\n      gasLimit: transaction.getGasLimit().valueOf().toString(),\n      data: Buffer.from(transaction.getData().toString().trim()).toString(),\n      chainId: transaction.getChainID().valueOf(),\n      version: transaction.getVersion().valueOf()\n    };\n  }\n\n  addressIsValid(destinationAddress) {\n    try {\n      const addr = new address_1.Address(destinationAddress);\n      return !!addr;\n    } catch (_a) {\n      return false;\n    }\n  }\n\n}\n\nexports.WalletConnectProvider = WalletConnectProvider;","map":{"version":3,"sources":["../../src/dapp/walletConnectProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletConnectProvider = void 0;\nconst client_1 = __importDefault(require(\"@walletconnect/client\"));\nconst address_1 = require(\"../address\");\nconst signature_1 = require(\"../signature\");\nconst constants_1 = require(\"./constants\");\nconst logger_1 = require(\"../logger\");\nconst errors_1 = require(\"../errors\");\nclass WalletConnectProvider {\n    constructor(httpProvider, walletConnectBridge = \"\", onClientConnect) {\n        this.address = \"\";\n        this.signature = \"\";\n        this.provider = httpProvider;\n        this.walletConnectBridge = walletConnectBridge;\n        this.onClientConnect = onClientConnect;\n    }\n    /**\n     * Initiates wallet connect client.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.walletConnector = new client_1.default({\n                bridge: this.walletConnectBridge,\n            });\n            this.walletConnector.on(\"connect\", this.onConnect.bind(this));\n            this.walletConnector.on(\"session_update\", this.onDisconnect.bind(this));\n            this.walletConnector.on(\"disconnect\", this.onDisconnect.bind(this));\n            if (this.walletConnector.connected &&\n                this.walletConnector.accounts.length) {\n                const [account] = this.walletConnector.accounts;\n                const [address, signature] = account.split(\".\");\n                yield this.loginAccount(address, signature);\n            }\n            return true;\n        });\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n    isInitialized() {\n        return !!this.walletConnector;\n    }\n    /**\n     * Mocked function, returns isInitialized as an async function\n     */\n    isConnected() {\n        return new Promise((resolve, _) => resolve(this.isInitialized()));\n    }\n    /**\n     *\n     */\n    login() {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                yield this.init();\n            }\n            if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n                yield this.walletConnector.killSession();\n                logger_1.Logger.trace(\"WalletConnect login started but walletConnect not initialized\");\n                return \"\";\n            }\n            yield ((_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.createSession({ chainId: constants_1.WALLETCONNECT_ELROND_CHAIN_ID }));\n            if (!((_c = this.walletConnector) === null || _c === void 0 ? void 0 : _c.uri)) {\n                return \"\";\n            }\n            return (_d = this.walletConnector) === null || _d === void 0 ? void 0 : _d.uri;\n        });\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n    logout() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"logout: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n                yield ((_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession());\n            }\n            return true;\n        });\n    }\n    /**\n     * Fetches the wallet connect address\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"getAddress: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            return this.address;\n        });\n    }\n    /**\n     * Fetches the wallet connect signature\n     */\n    getSignature() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"getSignature: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            return this.signature;\n        });\n    }\n    /**\n     * Signs and sends a transaction. Returns the transaction hash\n     * @param transaction\n     */\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"sendTransaction: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            transaction = yield this.signTransaction(transaction);\n            yield transaction.send(this.provider);\n            return transaction;\n        });\n    }\n    /**\n     * Method will be available once the Maiar wallet connect hook is implemented\n     * @param _\n     */\n    signMessage(_) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new errors_1.ErrNotImplemented();\n        });\n    }\n    /**\n     * Signs a transaction and returns it\n     * @param transaction\n     */\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"signTransaction: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            const address = yield this.getAddress();\n            const sig = yield this.walletConnector.sendCustomRequest({\n                method: \"erd_sign\",\n                params: this.prepareWalletConnectMessage(transaction, address)\n            });\n            if (!sig || !sig.signature) {\n                logger_1.Logger.error(\"signTransaction: Wallet Connect could not sign the transaction\");\n                throw new Error(\"Wallet Connect could not sign the transaction\");\n            }\n            transaction.applySignature(new signature_1.Signature(sig.signature), new address_1.Address(address));\n            return transaction;\n        });\n    }\n    /**\n     * Signs an array of transactions and returns it\n     * @param transactions\n     */\n    signTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"signTransactions: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            const address = yield this.getAddress();\n            const params = transactions.map((transaction) => this.prepareWalletConnectMessage(transaction, address));\n            const signatures = yield this.walletConnector.sendCustomRequest({\n                method: \"erd_batch_sign\",\n                params\n            });\n            if (!signatures) {\n                logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions\");\n                throw new Error(\"Wallet Connect could not sign the transactions\");\n            }\n            if (Array.isArray(signatures)) {\n                if (transactions.length !== signatures.length) {\n                    logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions. Invalid signatures.\");\n                    throw new Error(\"Wallet Connect could not sign the transactions. Invalid signatures.\");\n                }\n                transactions.map((transaction, key) => transaction.applySignature(new signature_1.Signature(signatures[key].signature), new address_1.Address(address)));\n                return transactions;\n            }\n            transactions[0].applySignature(new signature_1.Signature(signatures.signature), new address_1.Address(address));\n            return transactions;\n        });\n    }\n    /**\n     * Sends a custom method and params and returns the response object\n     */\n    sendCustomMessage({ method, params, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            const customMessageResponse = yield this.walletConnector.sendCustomRequest({\n                method,\n                params,\n            });\n            if (!customMessageResponse) {\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect could not send the message\");\n                throw new Error(\"Wallet Connect could not send the message\");\n            }\n            return customMessageResponse;\n        });\n    }\n    onConnect(error, { params }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (error) {\n                throw error;\n            }\n            if (!params || !params[0]) {\n                logger_1.Logger.error(\"Wallet Connect missing payload\");\n                throw new Error(\"missing payload\");\n            }\n            const { accounts: [account], } = params[0];\n            const [address, signature] = account.split(\".\");\n            yield this.loginAccount(address, signature);\n        });\n    }\n    onDisconnect(error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (error) {\n                throw error;\n            }\n            this.onClientConnect.onClientLogout();\n        });\n    }\n    loginAccount(address, signature) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.addressIsValid(address)) {\n                this.address = address;\n                if (signature) {\n                    this.signature = signature;\n                }\n                this.onClientConnect.onClientLogin();\n                return;\n            }\n            logger_1.Logger.error(`Wallet Connect invalid address ${address}`);\n            if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n                yield ((_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession());\n            }\n        });\n    }\n    prepareWalletConnectMessage(transaction, address) {\n        return {\n            nonce: transaction.getNonce().valueOf(),\n            from: address,\n            to: transaction.getReceiver().toString(),\n            amount: transaction.getValue().toString(),\n            gasPrice: transaction\n                .getGasPrice()\n                .valueOf()\n                .toString(),\n            gasLimit: transaction\n                .getGasLimit()\n                .valueOf()\n                .toString(),\n            data: Buffer.from(transaction\n                .getData()\n                .toString()\n                .trim()).toString(),\n            chainId: transaction.getChainID().valueOf(),\n            version: transaction.getVersion().valueOf(),\n        };\n    }\n    addressIsValid(destinationAddress) {\n        try {\n            const addr = new address_1.Address(destinationAddress);\n            return !!addr;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n}\nexports.WalletConnectProvider = WalletConnectProvider;\n//# sourceMappingURL=walletConnectProvider.js.map"]},"metadata":{},"sourceType":"script"}