{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Fields = exports.Field = exports.FieldDefinition = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst typeExpressionParser_1 = require(\"./typeExpressionParser\");\n\nclass FieldDefinition {\n  constructor(name, description, type) {\n    this.name = name;\n    this.description = description;\n    this.type = type;\n  }\n\n  static fromJSON(json) {\n    let parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);\n    return new FieldDefinition(json.name, json.description, parsedType);\n  }\n\n}\n\nexports.FieldDefinition = FieldDefinition;\n\nclass Field {\n  constructor(value) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    this.value = value;\n    this.name = name;\n  }\n\n  checkTyping(expectedDefinition) {\n    const actualType = this.value.getType();\n\n    if (!actualType.equals(expectedDefinition.type)) {\n      throw new errors.ErrTypingSystem(`check type of field \"${expectedDefinition.name}; expected: ${expectedDefinition.type}, actual: ${actualType}\"`);\n    }\n\n    if (this.name != expectedDefinition.name) {\n      throw new errors.ErrTypingSystem(`check name of field \"${expectedDefinition.name}\"`);\n    }\n  }\n\n  equals(other) {\n    return this.name == other.name && this.value.equals(other.value);\n  }\n\n}\n\nexports.Field = Field;\n\nclass Fields {\n  static checkTyping(fields, definitions) {\n    if (fields.length != definitions.length) {\n      throw new errors.ErrTypingSystem(\"fields length vs. field definitions length\");\n    }\n\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i];\n      let definition = definitions[i];\n      field.checkTyping(definition);\n    }\n  }\n\n  static equals(actual, expected) {\n    if (actual.length != expected.length) {\n      return false;\n    }\n\n    for (let i = 0; i < actual.length; i++) {\n      let selfField = actual[i];\n      let otherField = expected[i];\n\n      if (!selfField.equals(otherField)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nexports.Fields = Fields;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAGA,MAAaA,eAAb,CAA4B;AAKxBC,cAAYC,IAAZ,EAA0BC,WAA1B,EAA+CC,IAA/C,EAAyD;AACrD,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACH;;AAEc,SAARC,QAAQ,CAACC,IAAD,EAA0D;AACrE,QAAIC,UAAU,GAAG,IAAIC,2CAAJ,GAA2BC,KAA3B,CAAiCH,IAAI,CAACF,IAAtC,CAAjB;AACA,WAAO,IAAIJ,eAAJ,CAAoBM,IAAI,CAACJ,IAAzB,EAA+BI,IAAI,CAACH,WAApC,EAAiDI,UAAjD,CAAP;AACH;;AAduB;;AAA5BG;;AAiBA,MAAaC,KAAb,CAAkB;AAIdV,cAAYW,KAAZ,EAAgD;AAAA,QAAjBV,IAAiB,uEAAF,EAAE;AAC5C,SAAKU,KAAL,GAAaA,KAAb;AACA,SAAKV,IAAL,GAAYA,IAAZ;AACH;;AAEDW,aAAW,CAACC,kBAAD,EAAoC;AAC3C,UAAMC,UAAU,GAAS,KAAKH,KAAL,CAAWI,OAAX,EAAzB;;AAEA,QAAI,CAACD,UAAU,CAACE,MAAX,CAAkBH,kBAAkB,CAACV,IAArC,CAAL,EAAiD;AAC7C,YAAM,IAAIc,MAAM,CAACC,eAAX,CAA2B,wBAAwBL,kBAAkB,CAACZ,IAAI,eAAeY,kBAAkB,CAACV,IAAI,aAAaW,UAAU,GAAvI,CAAN;AACH;;AACD,QAAI,KAAKb,IAAL,IAAaY,kBAAkB,CAACZ,IAApC,EAA0C;AACtC,YAAM,IAAIgB,MAAM,CAACC,eAAX,CAA2B,wBAAwBL,kBAAkB,CAACZ,IAAI,GAA1E,CAAN;AACH;AACJ;;AAEDe,QAAM,CAACG,KAAD,EAAa;AACf,WAAO,KAAKlB,IAAL,IAAakB,KAAK,CAAClB,IAAnB,IAA2B,KAAKU,KAAL,CAAWK,MAAX,CAAkBG,KAAK,CAACR,KAAxB,CAAlC;AACH;;AAtBa;;AAAlBF;;AAyBA,MAAaW,MAAb,CAAmB;AACG,SAAXR,WAAW,CAACS,MAAD,EAAkBC,WAAlB,EAAgD;AAC9D,QAAID,MAAM,CAACE,MAAP,IAAiBD,WAAW,CAACC,MAAjC,EAAyC;AACrC,YAAM,IAAIN,MAAM,CAACC,eAAX,CAA2B,4CAA3B,CAAN;AACH;;AAED,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACE,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;AACpC,UAAIC,KAAK,GAAGJ,MAAM,CAACG,CAAD,CAAlB;AACA,UAAIE,UAAU,GAAGJ,WAAW,CAACE,CAAD,CAA5B;AAEAC,WAAK,CAACb,WAAN,CAAkBc,UAAlB;AACH;AACJ;;AAEY,SAANV,MAAM,CAACW,MAAD,EAA+BC,QAA/B,EAA6D;AACtE,QAAID,MAAM,CAACJ,MAAP,IAAiBK,QAAQ,CAACL,MAA9B,EAAsC;AAClC,aAAO,KAAP;AACH;;AAED,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,MAAM,CAACJ,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;AACpC,UAAIK,SAAS,GAAGF,MAAM,CAACH,CAAD,CAAtB;AACA,UAAIM,UAAU,GAAGF,QAAQ,CAACJ,CAAD,CAAzB;;AAEA,UAAI,CAACK,SAAS,CAACb,MAAV,CAAiBc,UAAjB,CAAL,EAAmC;AAC/B,eAAO,KAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;AA7Bc;;AAAnBrB","names":["FieldDefinition","constructor","name","description","type","fromJSON","json","parsedType","typeExpressionParser_1","parse","exports","Field","value","checkTyping","expectedDefinition","actualType","getType","equals","errors","ErrTypingSystem","other","Fields","fields","definitions","length","i","field","definition","actual","expected","selfField","otherField"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/fields.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}