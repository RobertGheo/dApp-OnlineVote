{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NumericalBinaryCodec = void 0;\n\nconst typesystem_1 = require(\"../typesystem\");\n\nconst utils_1 = require(\"./utils\");\n\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nconst constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"NumericalValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\n\n\nclass NumericalBinaryCodec {\n  decodeNested(buffer, type) {\n    let offset = 0;\n    let length = type.sizeInBytes;\n\n    if (!length) {\n      // Size of type is not known: arbitrary-size big integer.\n      // Therefore, we must read the length from the header.\n      offset = constants_1.SizeOfU32;\n      length = buffer.readUInt32BE(0);\n    }\n\n    let payload = buffer.slice(offset, offset + length);\n    let result = this.decodeTopLevel(payload, type);\n    let decodedLength = length + offset;\n    return [result, decodedLength];\n  }\n\n  decodeTopLevel(buffer, type) {\n    let payload = utils_1.cloneBuffer(buffer);\n    let empty = buffer.length == 0;\n\n    if (empty) {\n      return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));\n    }\n\n    let isPositive = !type.withSign || utils_1.isMsbZero(payload);\n\n    if (isPositive) {\n      let value = utils_1.bufferToBigInt(payload);\n      return new typesystem_1.NumericalValue(type, value);\n    } // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/twos2bigint.go\n\n\n    utils_1.flipBufferBitsInPlace(payload);\n    let value = utils_1.bufferToBigInt(payload);\n    let negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));\n    let negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));\n    return new typesystem_1.NumericalValue(type, negativeValueMinusOne);\n  }\n\n  encodeNested(primitive) {\n    if (primitive.sizeInBytes) {\n      return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);\n    } // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.\n\n\n    let buffer = this.encodeTopLevel(primitive);\n    let length = Buffer.alloc(constants_1.SizeOfU32);\n    length.writeUInt32BE(buffer.length);\n    return Buffer.concat([length, buffer]);\n  }\n\n  encodeNestedFixedSize(primitive, size) {\n    if (primitive.value.isZero()) {\n      return Buffer.alloc(size, 0x00);\n    }\n\n    if (!primitive.withSign) {\n      const buffer = utils_1.bigIntToBuffer(primitive.value);\n      const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n      return Buffer.concat([paddingBytes, buffer]);\n    }\n\n    if (primitive.value.isPositive()) {\n      let buffer = utils_1.bigIntToBuffer(primitive.value); // Fix ambiguity if any\n\n      if (utils_1.isMsbOne(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n      }\n\n      const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n      return Buffer.concat([paddingBytes, buffer]);\n    } // Negative:\n    // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n\n\n    let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n    let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n    utils_1.flipBufferBitsInPlace(buffer); // Fix ambiguity if any\n\n    if (utils_1.isMsbZero(buffer)) {\n      buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n    }\n\n    const paddingBytes = Buffer.alloc(size - buffer.length, 0xff);\n    return Buffer.concat([paddingBytes, buffer]);\n  }\n\n  encodeTopLevel(primitive) {\n    let withSign = primitive.withSign; // Nothing or Zero:\n\n    if (primitive.value.isZero()) {\n      return Buffer.alloc(0);\n    } // I don't care about the sign:\n\n\n    if (!withSign) {\n      return utils_1.bigIntToBuffer(primitive.value);\n    }\n\n    return this.encodePrimitive(primitive);\n  }\n\n  encodePrimitive(primitive) {\n    // Positive:\n    if (primitive.value.isPositive()) {\n      let buffer = utils_1.bigIntToBuffer(primitive.value); // Fix ambiguity if any\n\n      if (utils_1.isMsbOne(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n      }\n\n      return buffer;\n    } // Negative:\n    // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n\n\n    let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n    let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n    utils_1.flipBufferBitsInPlace(buffer); // Fix ambiguity if any\n\n    if (utils_1.isMsbZero(buffer)) {\n      buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n    }\n\n    return buffer;\n  }\n\n}\n\nexports.NumericalBinaryCodec = NumericalBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/numerical.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NumericalBinaryCodec = void 0;\nconst typesystem_1 = require(\"../typesystem\");\nconst utils_1 = require(\"./utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"NumericalValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nclass NumericalBinaryCodec {\n    decodeNested(buffer, type) {\n        let offset = 0;\n        let length = type.sizeInBytes;\n        if (!length) {\n            // Size of type is not known: arbitrary-size big integer.\n            // Therefore, we must read the length from the header.\n            offset = constants_1.SizeOfU32;\n            length = buffer.readUInt32BE(0);\n        }\n        let payload = buffer.slice(offset, offset + length);\n        let result = this.decodeTopLevel(payload, type);\n        let decodedLength = length + offset;\n        return [result, decodedLength];\n    }\n    decodeTopLevel(buffer, type) {\n        let payload = utils_1.cloneBuffer(buffer);\n        let empty = buffer.length == 0;\n        if (empty) {\n            return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));\n        }\n        let isPositive = !type.withSign || utils_1.isMsbZero(payload);\n        if (isPositive) {\n            let value = utils_1.bufferToBigInt(payload);\n            return new typesystem_1.NumericalValue(type, value);\n        }\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/twos2bigint.go\n        utils_1.flipBufferBitsInPlace(payload);\n        let value = utils_1.bufferToBigInt(payload);\n        let negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));\n        let negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));\n        return new typesystem_1.NumericalValue(type, negativeValueMinusOne);\n    }\n    encodeNested(primitive) {\n        if (primitive.sizeInBytes) {\n            return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);\n        }\n        // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.\n        let buffer = this.encodeTopLevel(primitive);\n        let length = Buffer.alloc(constants_1.SizeOfU32);\n        length.writeUInt32BE(buffer.length);\n        return Buffer.concat([length, buffer]);\n    }\n    encodeNestedFixedSize(primitive, size) {\n        if (primitive.value.isZero()) {\n            return Buffer.alloc(size, 0x00);\n        }\n        if (!primitive.withSign) {\n            const buffer = utils_1.bigIntToBuffer(primitive.value);\n            const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n            return Buffer.concat([paddingBytes, buffer]);\n        }\n        if (primitive.value.isPositive()) {\n            let buffer = utils_1.bigIntToBuffer(primitive.value);\n            // Fix ambiguity if any\n            if (utils_1.isMsbOne(buffer)) {\n                buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n            }\n            const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n            return Buffer.concat([paddingBytes, buffer]);\n        }\n        // Negative:\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n        let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n        utils_1.flipBufferBitsInPlace(buffer);\n        // Fix ambiguity if any\n        if (utils_1.isMsbZero(buffer)) {\n            buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n        }\n        const paddingBytes = Buffer.alloc(size - buffer.length, 0xff);\n        return Buffer.concat([paddingBytes, buffer]);\n    }\n    encodeTopLevel(primitive) {\n        let withSign = primitive.withSign;\n        // Nothing or Zero:\n        if (primitive.value.isZero()) {\n            return Buffer.alloc(0);\n        }\n        // I don't care about the sign:\n        if (!withSign) {\n            return utils_1.bigIntToBuffer(primitive.value);\n        }\n        return this.encodePrimitive(primitive);\n    }\n    encodePrimitive(primitive) {\n        // Positive:\n        if (primitive.value.isPositive()) {\n            let buffer = utils_1.bigIntToBuffer(primitive.value);\n            // Fix ambiguity if any\n            if (utils_1.isMsbOne(buffer)) {\n                buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n            }\n            return buffer;\n        }\n        // Negative:\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n        let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n        utils_1.flipBufferBitsInPlace(buffer);\n        // Fix ambiguity if any\n        if (utils_1.isMsbZero(buffer)) {\n            buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n        }\n        return buffer;\n    }\n}\nexports.NumericalBinaryCodec = NumericalBinaryCodec;\n//# sourceMappingURL=numerical.js.map"]},"metadata":{},"sourceType":"script"}