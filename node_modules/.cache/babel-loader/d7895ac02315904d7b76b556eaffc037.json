{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Struct = exports.StructType = void 0;\n\nconst fields_1 = require(\"./fields\");\n\nconst types_1 = require(\"./types\");\n\nclass StructType extends types_1.CustomType {\n  constructor(name, fieldsDefinitions) {\n    super(name);\n    this.fieldsDefinitions = [];\n    this.fieldsDefinitions = fieldsDefinitions;\n  }\n\n  static fromJSON(json) {\n    let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n    return new StructType(json.name, definitions);\n  }\n\n  getFieldsDefinitions() {\n    return this.fieldsDefinitions;\n  }\n\n}\n\nexports.StructType = StructType; // TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\n\nclass Struct extends types_1.TypedValue {\n  /**\n   * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n   */\n  constructor(type, fields) {\n    super(type);\n    this.fields = [];\n    this.fields = fields;\n    this.checkTyping();\n  }\n\n  checkTyping() {\n    let type = this.getType();\n    let definitions = type.getFieldsDefinitions();\n    fields_1.Fields.checkTyping(this.fields, definitions);\n  }\n\n  getFields() {\n    return this.fields;\n  }\n\n  valueOf() {\n    let result = {};\n\n    for (const field of this.fields) {\n      result[field.name] = field.value.valueOf();\n    }\n\n    return result;\n  }\n\n  equals(other) {\n    if (!this.getType().equals(other.getType())) {\n      return false;\n    }\n\n    let selfFields = this.getFields();\n    let otherFields = other.getFields();\n    return fields_1.Fields.equals(selfFields, otherFields);\n  }\n\n}\n\nexports.Struct = Struct;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAEA,MAAaA,UAAb,SAAgCC,kBAAhC,CAA0C;AAGtCC,cAAYC,IAAZ,EAA0BC,iBAA1B,EAA8D;AAC1D,UAAMD,IAAN;AAHa,6BAAuC,EAAvC;AAIb,SAAKC,iBAAL,GAAyBA,iBAAzB;AACH;;AAEc,SAARC,QAAQ,CAACC,IAAD,EAAsC;AACjD,QAAIC,WAAW,GAAG,CAACD,IAAI,CAACE,MAAL,IAAe,EAAhB,EAAoBC,GAApB,CAAwBC,UAAU,IAAIC,yBAAgBN,QAAhB,CAAyBK,UAAzB,CAAtC,CAAlB;AACA,WAAO,IAAIV,UAAJ,CAAeM,IAAI,CAACH,IAApB,EAA0BI,WAA1B,CAAP;AACH;;AAEDK,sBAAoB;AAChB,WAAO,KAAKR,iBAAZ;AACH;;AAfqC;;AAA1CS,gC,CAkBA;AACA;;AACA,MAAaC,MAAb,SAA4Bb,kBAA5B,CAAsC;AAGlC;;;AAGAC,cAAYa,IAAZ,EAA8BP,MAA9B,EAA6C;AACzC,UAAMO,IAAN;AANa,kBAAkB,EAAlB;AAOb,SAAKP,MAAL,GAAcA,MAAd;AAEA,SAAKQ,WAAL;AACH;;AAEOA,aAAW;AACf,QAAID,IAAI,GAAe,KAAKE,OAAL,EAAvB;AACA,QAAIV,WAAW,GAAGQ,IAAI,CAACH,oBAAL,EAAlB;AACAD,oBAAOK,WAAP,CAAmB,KAAKR,MAAxB,EAAgCD,WAAhC;AACH;;AAEDW,WAAS;AACL,WAAO,KAAKV,MAAZ;AACH;;AAEDW,SAAO;AACH,QAAIC,MAAM,GAAQ,EAAlB;;AAEA,SAAK,MAAMC,KAAX,IAAoB,KAAKb,MAAzB,EAAiC;AAC7BY,YAAM,CAACC,KAAK,CAAClB,IAAP,CAAN,GAAqBkB,KAAK,CAACC,KAAN,CAAYH,OAAZ,EAArB;AACH;;AAED,WAAOC,MAAP;AACH;;AAEDG,QAAM,CAACC,KAAD,EAAc;AAChB,QAAI,CAAC,KAAKP,OAAL,GAAeM,MAAf,CAAsBC,KAAK,CAACP,OAAN,EAAtB,CAAL,EAA6C;AACzC,aAAO,KAAP;AACH;;AAED,QAAIQ,UAAU,GAAG,KAAKP,SAAL,EAAjB;AACA,QAAIQ,WAAW,GAAGF,KAAK,CAACN,SAAN,EAAlB;AAEA,WAAOP,gBAAOY,MAAP,CAAcE,UAAd,EAA0BC,WAA1B,CAAP;AACH;;AA1CiC;;AAAtCb","names":["StructType","types_1","constructor","name","fieldsDefinitions","fromJSON","json","definitions","fields","map","definition","fields_1","getFieldsDefinitions","exports","Struct","type","checkTyping","getType","getFields","valueOf","result","field","value","equals","other","selfFields","otherFields"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/struct.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}