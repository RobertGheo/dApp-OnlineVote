{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryCodecConstraints = exports.BinaryCodec = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst typesystem_1 = require(\"../typesystem\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst option_1 = require(\"./option\");\n\nconst primitive_1 = require(\"./primitive\");\n\nconst list_1 = require(\"./list\");\n\nconst struct_1 = require(\"./struct\");\n\nconst enum_1 = require(\"./enum\");\n\nconst tuple_1 = require(\"./tuple\");\n\nconst arrayVec_1 = require(\"./arrayVec\");\n\nclass BinaryCodec {\n  constructor() {\n    let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.constraints = constraints || new BinaryCodecConstraints();\n    this.optionCodec = new option_1.OptionValueBinaryCodec(this);\n    this.listCodec = new list_1.ListBinaryCodec(this);\n    this.arrayCodec = new arrayVec_1.ArrayVecBinaryCodec(this);\n    this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this);\n    this.structCodec = new struct_1.StructBinaryCodec(this);\n    this.tupleCodec = new tuple_1.TupleBinaryCodec(this);\n    this.enumCodec = new enum_1.EnumBinaryCodec(this);\n  }\n\n  decodeTopLevel(buffer, type) {\n    this.constraints.checkBufferLength(buffer);\n    let typedValue = typesystem_1.onTypeSelect(type, {\n      onOption: () => this.optionCodec.decodeTopLevel(buffer, type.getFirstTypeParameter()),\n      onList: () => this.listCodec.decodeTopLevel(buffer, type),\n      onArray: () => this.arrayCodec.decodeTopLevel(buffer, type),\n      onPrimitive: () => this.primitiveCodec.decodeTopLevel(buffer, type),\n      onStruct: () => this.structCodec.decodeTopLevel(buffer, type),\n      onTuple: () => this.tupleCodec.decodeTopLevel(buffer, type),\n      onEnum: () => this.enumCodec.decodeTopLevel(buffer, type)\n    });\n    return typedValue;\n  }\n\n  decodeNested(buffer, type) {\n    this.constraints.checkBufferLength(buffer);\n    let [typedResult, decodedLength] = typesystem_1.onTypeSelect(type, {\n      onOption: () => this.optionCodec.decodeNested(buffer, type.getFirstTypeParameter()),\n      onList: () => this.listCodec.decodeNested(buffer, type),\n      onArray: () => this.arrayCodec.decodeNested(buffer, type),\n      onPrimitive: () => this.primitiveCodec.decodeNested(buffer, type),\n      onStruct: () => this.structCodec.decodeNested(buffer, type),\n      onTuple: () => this.tupleCodec.decodeNested(buffer, type),\n      onEnum: () => this.enumCodec.decodeNested(buffer, type)\n    });\n    return [typedResult, decodedLength];\n  }\n\n  encodeNested(typedValue) {\n    utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n    return typesystem_1.onTypedValueSelect(typedValue, {\n      onPrimitive: () => this.primitiveCodec.encodeNested(typedValue),\n      onOption: () => this.optionCodec.encodeNested(typedValue),\n      onList: () => this.listCodec.encodeNested(typedValue),\n      onArray: () => this.arrayCodec.encodeNested(typedValue),\n      onStruct: () => this.structCodec.encodeNested(typedValue),\n      onTuple: () => this.tupleCodec.encodeNested(typedValue),\n      onEnum: () => this.enumCodec.encodeNested(typedValue)\n    });\n  }\n\n  encodeTopLevel(typedValue) {\n    utils_1.guardType(\"value\", typesystem_1.TypedValue, typedValue, false);\n    utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n    return typesystem_1.onTypedValueSelect(typedValue, {\n      onPrimitive: () => this.primitiveCodec.encodeTopLevel(typedValue),\n      onOption: () => this.optionCodec.encodeTopLevel(typedValue),\n      onList: () => this.listCodec.encodeTopLevel(typedValue),\n      onArray: () => this.arrayCodec.encodeTopLevel(typedValue),\n      onStruct: () => this.structCodec.encodeTopLevel(typedValue),\n      onTuple: () => this.tupleCodec.encodeTopLevel(typedValue),\n      onEnum: () => this.enumCodec.encodeTopLevel(typedValue)\n    });\n  }\n\n}\n\nexports.BinaryCodec = BinaryCodec;\n\nclass BinaryCodecConstraints {\n  constructor(init) {\n    this.maxBufferLength = (init === null || init === void 0 ? void 0 : init.maxBufferLength) || 4096;\n    this.maxListLength = (init === null || init === void 0 ? void 0 : init.maxListLength) || 1024;\n  }\n\n  checkBufferLength(buffer) {\n    if (buffer.length > this.maxBufferLength) {\n      throw new errors.ErrCodec(`Buffer too large: ${buffer.length} > ${this.maxBufferLength}`);\n    }\n  }\n  /**\n   * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).\n   */\n\n\n  checkListLength(length) {\n    if (length > this.maxListLength) {\n      throw new errors.ErrCodec(`List too large: ${length} > ${this.maxListLength}`);\n    }\n  }\n\n}\n\nexports.BinaryCodecConstraints = BinaryCodecConstraints;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/binary.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryCodecConstraints = exports.BinaryCodec = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst typesystem_1 = require(\"../typesystem\");\nconst utils_1 = require(\"../../utils\");\nconst option_1 = require(\"./option\");\nconst primitive_1 = require(\"./primitive\");\nconst list_1 = require(\"./list\");\nconst struct_1 = require(\"./struct\");\nconst enum_1 = require(\"./enum\");\nconst tuple_1 = require(\"./tuple\");\nconst arrayVec_1 = require(\"./arrayVec\");\nclass BinaryCodec {\n    constructor(constraints = null) {\n        this.constraints = constraints || new BinaryCodecConstraints();\n        this.optionCodec = new option_1.OptionValueBinaryCodec(this);\n        this.listCodec = new list_1.ListBinaryCodec(this);\n        this.arrayCodec = new arrayVec_1.ArrayVecBinaryCodec(this);\n        this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this);\n        this.structCodec = new struct_1.StructBinaryCodec(this);\n        this.tupleCodec = new tuple_1.TupleBinaryCodec(this);\n        this.enumCodec = new enum_1.EnumBinaryCodec(this);\n    }\n    decodeTopLevel(buffer, type) {\n        this.constraints.checkBufferLength(buffer);\n        let typedValue = typesystem_1.onTypeSelect(type, {\n            onOption: () => this.optionCodec.decodeTopLevel(buffer, type.getFirstTypeParameter()),\n            onList: () => this.listCodec.decodeTopLevel(buffer, type),\n            onArray: () => this.arrayCodec.decodeTopLevel(buffer, type),\n            onPrimitive: () => this.primitiveCodec.decodeTopLevel(buffer, type),\n            onStruct: () => this.structCodec.decodeTopLevel(buffer, type),\n            onTuple: () => this.tupleCodec.decodeTopLevel(buffer, type),\n            onEnum: () => this.enumCodec.decodeTopLevel(buffer, type),\n        });\n        return typedValue;\n    }\n    decodeNested(buffer, type) {\n        this.constraints.checkBufferLength(buffer);\n        let [typedResult, decodedLength] = typesystem_1.onTypeSelect(type, {\n            onOption: () => this.optionCodec.decodeNested(buffer, type.getFirstTypeParameter()),\n            onList: () => this.listCodec.decodeNested(buffer, type),\n            onArray: () => this.arrayCodec.decodeNested(buffer, type),\n            onPrimitive: () => this.primitiveCodec.decodeNested(buffer, type),\n            onStruct: () => this.structCodec.decodeNested(buffer, type),\n            onTuple: () => this.tupleCodec.decodeNested(buffer, type),\n            onEnum: () => this.enumCodec.decodeNested(buffer, type),\n        });\n        return [typedResult, decodedLength];\n    }\n    encodeNested(typedValue) {\n        utils_1.guardTrue(typedValue\n            .getType()\n            .getCardinality()\n            .isSingular(), \"singular cardinality, thus encodable type\");\n        return typesystem_1.onTypedValueSelect(typedValue, {\n            onPrimitive: () => this.primitiveCodec.encodeNested(typedValue),\n            onOption: () => this.optionCodec.encodeNested(typedValue),\n            onList: () => this.listCodec.encodeNested(typedValue),\n            onArray: () => this.arrayCodec.encodeNested(typedValue),\n            onStruct: () => this.structCodec.encodeNested(typedValue),\n            onTuple: () => this.tupleCodec.encodeNested(typedValue),\n            onEnum: () => this.enumCodec.encodeNested(typedValue),\n        });\n    }\n    encodeTopLevel(typedValue) {\n        utils_1.guardType(\"value\", typesystem_1.TypedValue, typedValue, false);\n        utils_1.guardTrue(typedValue\n            .getType()\n            .getCardinality()\n            .isSingular(), \"singular cardinality, thus encodable type\");\n        return typesystem_1.onTypedValueSelect(typedValue, {\n            onPrimitive: () => this.primitiveCodec.encodeTopLevel(typedValue),\n            onOption: () => this.optionCodec.encodeTopLevel(typedValue),\n            onList: () => this.listCodec.encodeTopLevel(typedValue),\n            onArray: () => this.arrayCodec.encodeTopLevel(typedValue),\n            onStruct: () => this.structCodec.encodeTopLevel(typedValue),\n            onTuple: () => this.tupleCodec.encodeTopLevel(typedValue),\n            onEnum: () => this.enumCodec.encodeTopLevel(typedValue),\n        });\n    }\n}\nexports.BinaryCodec = BinaryCodec;\nclass BinaryCodecConstraints {\n    constructor(init) {\n        this.maxBufferLength = (init === null || init === void 0 ? void 0 : init.maxBufferLength) || 4096;\n        this.maxListLength = (init === null || init === void 0 ? void 0 : init.maxListLength) || 1024;\n    }\n    checkBufferLength(buffer) {\n        if (buffer.length > this.maxBufferLength) {\n            throw new errors.ErrCodec(`Buffer too large: ${buffer.length} > ${this.maxBufferLength}`);\n        }\n    }\n    /**\n     * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).\n     */\n    checkListLength(length) {\n        if (length > this.maxListLength) {\n            throw new errors.ErrCodec(`List too large: ${length} > ${this.maxListLength}`);\n        }\n    }\n}\nexports.BinaryCodecConstraints = BinaryCodecConstraints;\n//# sourceMappingURL=binary.js.map"]},"metadata":{},"sourceType":"script"}