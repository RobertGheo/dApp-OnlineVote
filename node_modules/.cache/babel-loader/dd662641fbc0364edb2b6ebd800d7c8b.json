{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\n\nconst utils_1 = require(\"../../utils\");\n\nconst collections_1 = require(\"./collections\");\n\nconst types_1 = require(\"./types\"); // TODO: Move to a new file, \"genericOption.ts\"\n\n\nclass OptionType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"Option\", [typeParameter]);\n  }\n\n  isAssignableFrom(type) {\n    if (!(type instanceof OptionType)) {\n      return false;\n    }\n\n    let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n    let fakeCovarianceToNull = type.getFirstTypeParameter() instanceof types_1.NullType;\n    return invariantTypeParameters || fakeCovarianceToNull;\n  }\n\n}\n\nexports.OptionType = OptionType; // TODO: Move to a new file, \"genericList.ts\"\n\nclass ListType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"List\", [typeParameter]);\n  }\n\n}\n\nexports.ListType = ListType; // TODO: Move to a new file, \"genericOption.ts\"\n\nclass OptionValue extends types_1.TypedValue {\n  constructor(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(type); // TODO: assert value is of type type.getFirstTypeParameter()\n\n    this.value = value;\n  }\n  /**\n   * Creates an OptionValue, as a missing option argument.\n   */\n\n\n  static newMissing() {\n    let type = new OptionType(new types_1.NullType());\n    return new OptionValue(type);\n  }\n\n  static newMissingType(type) {\n    return new OptionValue(new OptionType(type));\n  }\n  /**\n   * Creates an OptionValue, as a provided option argument.\n   */\n\n\n  static newProvided(typedValue) {\n    let type = new OptionType(typedValue.getType());\n    return new OptionValue(type, typedValue);\n  }\n\n  isSet() {\n    return this.value ? true : false;\n  }\n\n  getTypedValue() {\n    utils_1.guardValueIsSet(\"value\", this.value);\n    return this.value;\n  }\n\n  valueOf() {\n    return this.value ? this.value.valueOf() : null;\n  }\n\n  equals(other) {\n    var _a;\n\n    return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n  }\n\n}\n\nexports.OptionValue = OptionValue; // TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\n\nclass List extends types_1.TypedValue {\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  constructor(type, items) {\n    super(type); // TODO: assert items are of type type.getFirstTypeParameter()\n\n    this.backingCollection = new collections_1.CollectionOfTypedValues(items);\n  }\n\n  static fromItems(items) {\n    if (items.length == 0) {\n      return new List(new types_1.TypePlaceholder(), []);\n    }\n\n    let typeParameter = items[0].getType();\n    let listType = new ListType(typeParameter);\n    return new List(listType, items);\n  }\n\n  getLength() {\n    return this.backingCollection.getLength();\n  }\n\n  getItems() {\n    return this.backingCollection.getItems();\n  }\n\n  valueOf() {\n    return this.backingCollection.valueOf();\n  }\n\n  equals(other) {\n    return this.backingCollection.equals(other.backingCollection);\n  }\n\n}\n\nexports.List = List;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA,mC,CAEA;;;AACA,MAAaA,UAAb,SAAgCC,YAAhC,CAAoC;AAChCC,cAAYC,aAAZ,EAA+B;AAC3B,UAAM,QAAN,EAAgB,CAACA,aAAD,CAAhB;AACH;;AAEDC,kBAAgB,CAACC,IAAD,EAAW;AACvB,QAAI,EAAEA,IAAI,YAAYL,UAAlB,CAAJ,EAAmC;AAC/B,aAAO,KAAP;AACH;;AAED,QAAIM,uBAAuB,GAAG,KAAKC,qBAAL,GAA6BC,MAA7B,CAAoCH,IAAI,CAACE,qBAAL,EAApC,CAA9B;AACA,QAAIE,oBAAoB,GAAGJ,IAAI,CAACE,qBAAL,cAAwCN,gBAAnE;AACA,WAAOK,uBAAuB,IAAIG,oBAAlC;AACH;;AAb+B;;AAApCC,gC,CAgBA;;AACA,MAAaC,QAAb,SAA8BV,YAA9B,CAAkC;AAC9BC,cAAYC,aAAZ,EAA+B;AAC3B,UAAM,MAAN,EAAc,CAACA,aAAD,CAAd;AACH;;AAH6B;;AAAlCO,4B,CAMA;;AACA,MAAaE,WAAb,SAAiCX,kBAAjC,CAA2C;AAGvCC,cAAYG,IAAZ,EAA6D;AAAA,QAA/BQ,KAA+B,uEAAJ,IAAI;AACzD,UAAMR,IAAN,EADyD,CAGzD;;AAEA,SAAKQ,KAAL,GAAaA,KAAb;AACH;AAED;;;;;AAGiB,SAAVC,UAAU;AACb,QAAIT,IAAI,GAAG,IAAIL,UAAJ,CAAe,IAAIC,gBAAJ,EAAf,CAAX;AACA,WAAO,IAAIW,WAAJ,CAAgBP,IAAhB,CAAP;AACH;;AAEoB,SAAdU,cAAc,CAACV,IAAD,EAAW;AAC5B,WAAO,IAAIO,WAAJ,CAAgB,IAAIZ,UAAJ,CAAeK,IAAf,CAAhB,CAAP;AACH;AAED;;;;;AAGkB,SAAXW,WAAW,CAACC,UAAD,EAAuB;AACrC,QAAIZ,IAAI,GAAG,IAAIL,UAAJ,CAAeiB,UAAU,CAACC,OAAX,EAAf,CAAX;AACA,WAAO,IAAIN,WAAJ,CAAgBP,IAAhB,EAAsBY,UAAtB,CAAP;AACH;;AAEDE,OAAK;AACD,WAAO,KAAKN,KAAL,GAAa,IAAb,GAAoB,KAA3B;AACH;;AAEDO,eAAa;AACTC,4BAAgB,OAAhB,EAAyB,KAAKR,KAA9B;AACA,WAAO,KAAKA,KAAZ;AACH;;AAEDS,SAAO;AACH,WAAO,KAAKT,KAAL,GAAa,KAAKA,KAAL,CAAWS,OAAX,EAAb,GAAoC,IAA3C;AACH;;AAEDd,QAAM,CAACe,KAAD,EAAmB;;;AACrB,WAAO,YAAKV,KAAL,MAAU,IAAV,IAAUW,aAAV,GAAU,MAAV,GAAUA,GAAEhB,MAAF,CAASe,KAAK,CAACV,KAAf,CAAV,KAAmC,KAA1C;AACH;;AA9CsC;;AAA3CH,kC,CAiDA;AACA;AACA;;AACA,MAAae,IAAb,SAA0BxB,kBAA1B,CAAoC;AAGhC;;;;;AAKAC,cAAYG,IAAZ,EAA4BqB,KAA5B,EAA+C;AAC3C,UAAMrB,IAAN,EAD2C,CAG3C;;AAEA,SAAKsB,iBAAL,GAAyB,IAAIC,qCAAJ,CAA4BF,KAA5B,CAAzB;AACH;;AAEe,SAATG,SAAS,CAACH,KAAD,EAAoB;AAChC,QAAIA,KAAK,CAACI,MAAN,IAAgB,CAApB,EAAuB;AACnB,aAAO,IAAIL,IAAJ,CAAS,IAAIxB,uBAAJ,EAAT,EAAgC,EAAhC,CAAP;AACH;;AAED,QAAIE,aAAa,GAAGuB,KAAK,CAAC,CAAD,CAAL,CAASR,OAAT,EAApB;AACA,QAAIa,QAAQ,GAAG,IAAIpB,QAAJ,CAAaR,aAAb,CAAf;AACA,WAAO,IAAIsB,IAAJ,CAASM,QAAT,EAAmBL,KAAnB,CAAP;AACH;;AAEDM,WAAS;AACL,WAAO,KAAKL,iBAAL,CAAuBK,SAAvB,EAAP;AACH;;AAEDC,UAAQ;AACJ,WAAO,KAAKN,iBAAL,CAAuBM,QAAvB,EAAP;AACH;;AAEDX,SAAO;AACH,WAAO,KAAKK,iBAAL,CAAuBL,OAAvB,EAAP;AACH;;AAEDd,QAAM,CAACe,KAAD,EAAY;AACd,WAAO,KAAKI,iBAAL,CAAuBnB,MAAvB,CAA8Be,KAAK,CAACI,iBAApC,CAAP;AACH;;AAxC+B;;AAApCjB","names":["OptionType","types_1","constructor","typeParameter","isAssignableFrom","type","invariantTypeParameters","getFirstTypeParameter","equals","fakeCovarianceToNull","exports","ListType","OptionValue","value","newMissing","newMissingType","newProvided","typedValue","getType","isSet","getTypedValue","utils_1","valueOf","other","_a","List","items","backingCollection","collections_1","fromItems","length","listType","getLength","getItems"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/generic.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}