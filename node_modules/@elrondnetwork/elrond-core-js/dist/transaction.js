"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var bech32 = require('bech32');

var BigNumber = require('bignumber.js');

var Transaction =
/*#__PURE__*/
function () {
  function Transaction(_ref) {
    var _ref$nonce = _ref.nonce,
        nonce = _ref$nonce === void 0 ? 0 : _ref$nonce,
        _ref$from = _ref.from,
        from = _ref$from === void 0 ? '' : _ref$from,
        _ref$to = _ref.to,
        to = _ref$to === void 0 ? '' : _ref$to,
        _ref$senderUsername = _ref.senderUsername,
        senderUsername = _ref$senderUsername === void 0 ? '' : _ref$senderUsername,
        _ref$receiverUsername = _ref.receiverUsername,
        receiverUsername = _ref$receiverUsername === void 0 ? '' : _ref$receiverUsername,
        _ref$value = _ref.value,
        value = _ref$value === void 0 ? '' : _ref$value,
        _ref$gasPrice = _ref.gasPrice,
        gasPrice = _ref$gasPrice === void 0 ? '' : _ref$gasPrice,
        _ref$gasLimit = _ref.gasLimit,
        gasLimit = _ref$gasLimit === void 0 ? '' : _ref$gasLimit,
        _ref$data = _ref.data,
        data = _ref$data === void 0 ? '' : _ref$data,
        _ref$chainID = _ref.chainID,
        chainID = _ref$chainID === void 0 ? '' : _ref$chainID,
        _ref$version = _ref.version,
        version = _ref$version === void 0 ? 0 : _ref$version;
    (0, _classCallCheck2["default"])(this, Transaction);
    Transaction.validateAddresses([from, to]);
    this.nonce = nonce;
    this.sender = from;
    this.receiver = to;
    this.senderUsername = senderUsername;
    this.receiverUsername = receiverUsername;
    this.value = value;
    this.gasPrice = gasPrice;
    this.gasLimit = gasLimit;
    this.data = data;
    this.chainID = chainID;
    this.version = version; // Set an empty signature for start

    this.signature = '';
  }
  /**
   * Returns the Buffer representation of the current transaction in order for it to be signed
   * @returns {Buffer}
   */


  (0, _createClass2["default"])(Transaction, [{
    key: "prepareForSigning",
    value: function prepareForSigning() {
      var mainTx = {
        nonce: this.nonce,
        value: this.value,
        receiver: this.receiver,
        sender: this.sender
      }; // The following properties which are optional are added only if they are set up

      if (this.senderUsername) {
        mainTx.senderUsername = this.senderUsername;
      }

      if (this.receiverUsername) {
        mainTx.receiverUsername = this.receiverUsername;
      }

      if (this.gasPrice) {
        mainTx.gasPrice = this.gasPrice;
      }

      if (this.gasLimit) {
        mainTx.gasLimit = this.gasLimit;
      }

      if (this.data) {
        mainTx.data = Buffer.from(this.data).toString('base64');
      }

      if (this.chainID) {
        mainTx.chainID = this.chainID;
      }

      if (this.version) {
        mainTx.version = this.version;
      }

      var mainTxJSON = JSON.stringify(mainTx);
      return Buffer.from(mainTxJSON);
    }
  }, {
    key: "prepareForNode",
    value: function prepareForNode() {
      return {
        nonce: this.nonce,
        value: this.value,
        receiver: this.receiver,
        sender: this.sender,
        senderUsername: this.senderUsername,
        receiverUsername: this.receiverUsername,
        gasPrice: this.gasPrice,
        gasLimit: this.gasLimit,
        data: Buffer.from(this.data).toString('base64'),
        chainID: this.chainID,
        version: this.version,
        signature: this.signature
      };
    }
  }, {
    key: "computeFee",
    value: function computeFee(_ref2) {
      var minGasLimit = _ref2.minGasLimit,
          gasPerDataByte = _ref2.gasPerDataByte,
          gasPriceModifier = _ref2.gasPriceModifier;
      var moveBalanceGas = minGasLimit + Buffer.from(this.data).length * gasPerDataByte;
      var intGasLimit = parseInt(this.gasLimit);
      var intGasPrice = parseInt(this.gasPrice);

      if (moveBalanceGas > intGasLimit) {
        throw new Error("Not enough gas provided ".concat(intGasLimit));
      }

      var gasPrice = new BigNumber(intGasPrice);
      var feeForMove = new BigNumber(moveBalanceGas).multipliedBy(gasPrice);

      if (moveBalanceGas === intGasLimit) {
        return feeForMove;
      }

      var diff = new BigNumber(intGasLimit - moveBalanceGas);
      var modifiedGasPrice = gasPrice.multipliedBy(new BigNumber(gasPriceModifier));
      var processingFee = diff.multipliedBy(modifiedGasPrice);
      return feeForMove.plus(processingFee);
    }
  }], [{
    key: "validateAddresses",
    value: function validateAddresses(addresses) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = addresses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var address = _step.value;

          try {
            bech32.decode(address);
          } catch (e) {
            throw new Error("invalid bech32 address");
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return Transaction;
}();

module.exports = Transaction;