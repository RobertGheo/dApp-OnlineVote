'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _require = require('ed25519-hd-key'),
    derivePath = _require.derivePath;

var crypto = require('crypto');

var uuid = require('uuid/v4');

var bech32 = require('bech32');

var bip39 = require('bip39');

var kd = require('./crypto/browser/keyDerivation');

var signer = require('./crypto/browser/ed25519Keypair');

var blsSigner = require('./crypto/browser/blsKeypair');

var _require2 = require('./constants'),
    ERD = _require2.ERD,
    MNEMONIC_LEN = _require2.MNEMONIC_LEN,
    HD_PREFIX = _require2.HD_PREFIX;

var Account =
/*#__PURE__*/
function () {
  /**
   * Account's constructor. If a keyfile is provided, public/private key are loaded from there
   * @param keyFile
   * @param password
   */
  function Account() {
    var keyFile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck2["default"])(this, Account);
    this.privateKey = null;
    this.publicKey = null;

    if (!keyFile) {
      return;
    }

    if (!password) {
      console.warn("empty password provided for the keyfile");
      return;
    }

    this.loadFromKeyFile(keyFile, password);
  }
  /**
   * Given a keyfile, load public/private keypair
   * @param keyFile
   * @param password
   */


  (0, _createClass2["default"])(Account, [{
    key: "loadFromKeyFile",
    value: function loadFromKeyFile(keyFile, password) {
      var kdfparams = keyFile.crypto.kdfparams;
      var derivedKey = kd.generateDerivedKey(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
      var ciphertext = Buffer.from(keyFile.crypto.ciphertext, 'hex');
      var mac = crypto.createHmac('sha256', derivedKey.slice(16, 32)).update(ciphertext).digest();

      if (mac.toString('hex') !== keyFile.crypto.mac) {
        throw new Error('MAC mismatch, possibly wrong password');
      }

      var decipher = crypto.createDecipheriv(keyFile.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(keyFile.crypto.cipherparams.iv, 'hex'));
      var seed = Buffer.concat([decipher.update(ciphertext), decipher["final"]()]);

      while (seed.length < 32) {
        var nullBuff = Buffer.from([0x00]);
        seed = Buffer.concat([nullBuff, seed]);
      }

      this.loadFromPrivateKey(seed);
      return this;
    }
    /**
     * Given a password, it will generate the contents for a file containing the current initialised account's private
     *   key, passed through a password based key derivation function
     * @param password
     * @returns {{version: number, id: *, address: string, bech32: string, crypto: {ciphertext: String, cipherparams: {iv: string}, cipher: string, kdf: string, kdfparams: {dklen: number, salt: string, n: number, r: number, p: number}, mac: string}}}
     */

  }, {
    key: "generateKeyFile",
    value: function generateKeyFile(password) {
      if (!this.publicKey || !this.privateKey) {
        console.warn("Account is not initialised");
        return;
      }

      var salt = crypto.randomBytes(32);
      var kdParams = {
        dklen: 32,
        salt: salt.toString('hex'),
        n: 4096,
        r: 8,
        p: 1
      };
      var iv = crypto.randomBytes(16);
      var derivedKey = kd.generateDerivedKey(Buffer.from(password), salt, kdParams.n, kdParams.r, kdParams.p, kdParams.dklen);
      var cipher = crypto.createCipheriv('aes-128-ctr', derivedKey.slice(0, 16), iv);
      var ciphertext = Buffer.concat([cipher.update(this.privateKey), cipher["final"]()]);
      var mac = crypto.createHmac('sha256', derivedKey.slice(16, 32)).update(ciphertext).digest();
      return {
        version: 4,
        id: uuid({
          random: crypto.randomBytes(16)
        }),
        address: this.publicKeyAsString(),
        bech32: this.address(),
        crypto: {
          ciphertext: ciphertext.toString('hex'),
          cipherparams: {
            iv: iv.toString('hex')
          },
          cipher: 'aes-128-ctr',
          kdf: 'scrypt',
          kdfparams: kdParams,
          mac: mac.toString('hex')
        }
      };
    }
    /**
     * Given a plaintext private key, the current account will be initialised, and a password protected file will be
     * generated with the provided private key
     * @param privateKey
     * @param password
     * @returns {{version: number, id: *, address: string, bech32: string, crypto: {ciphertext: String, cipherparams: {iv: string}, cipher: string, kdf: string, kdfparams: {dklen: number, salt: string, n: number, r: number, p: number}, mac: string}}}
     */

  }, {
    key: "generateKeyFileFromPrivateKey",
    value: function generateKeyFileFromPrivateKey(privateKey, password) {
      this.loadFromSeed(privateKey);
      return this.generateKeyFile(password);
    }
    /**
     * Given the private key, regenerate public key
     * @param privateKey
     */

  }, {
    key: "loadFromPrivateKey",
    value: function loadFromPrivateKey(privateKey) {
      this.privateKey = privateKey;
      this.publicKey = signer.generatePublicKey(privateKey);
    }
    /**
     * Given a private key, generates the public/private key pair
     *
     * @param privateKey
     */

  }, {
    key: "loadFromSeed",
    value: function loadFromSeed(privateKey) {
      var _signer$generatePairF = signer.generatePairFromSeed(privateKey),
          _signer$generatePairF2 = (0, _slicedToArray2["default"])(_signer$generatePairF, 2),
          pk = _signer$generatePairF2[0],
          sk = _signer$generatePairF2[1];

      this.publicKey = pk;
      this.privateKey = sk;
    }
    /**
     * Given a hex representation of the private key, regenerate public key
     * @param sk
     */

  }, {
    key: "loadFromHexPrivateKey",
    value: function loadFromHexPrivateKey(sk) {
      var privateKey = Buffer.from(sk, 'hex');
      this.loadFromPrivateKey(privateKey);
    }
    /**
     * Return the hex representation of the public key
     * @returns {string}
     */

  }, {
    key: "publicKeyAsString",
    value: function publicKeyAsString() {
      return Buffer.from(this.publicKey).toString('hex');
    }
    /**
     * Return the bech32 representation of the public key
     * @returns {string}
     */

  }, {
    key: "address",
    value: function address() {
      var words = bech32.toWords(Buffer.from(this.publicKey));
      return bech32.encode(ERD, words);
    }
    /**
     * Returns the hex representation from the bech32 string
     * @returns {string}
     */

  }, {
    key: "hexPublicKeyFromAddress",
    value: function hexPublicKeyFromAddress(bech32addr) {
      var dec = bech32.decode(bech32addr, 256);
      return Buffer.from(bech32.fromWords(dec.words)).toString('hex');
    }
    /**
     * Returns the bech32 representation of the provided public key
     * @param publicKey
     * @returns {string}
     */

  }, {
    key: "addressFromHexPublicKey",
    value: function addressFromHexPublicKey(publicKey) {
      var words = bech32.toWords(Buffer.from(publicKey, 'hex'));
      return bech32.encode(ERD, words);
    }
    /**
     * Return the hex representation of the public key
     * @returns {string}
     */

  }, {
    key: "privateKeyAsString",
    value: function privateKeyAsString() {
      return Buffer.from(this.privateKey).toString('hex');
    }
    /**
     * Generates a new EdDSA25519 keypair
     * @returns {*[]}
     */

  }, {
    key: "initNewKeyPair",
    value: function initNewKeyPair() {
      var _signer$keyPair = signer.keyPair(),
          _signer$keyPair2 = (0, _slicedToArray2["default"])(_signer$keyPair, 2),
          publicKey = _signer$keyPair2[0],
          privateKey = _signer$keyPair2[1];

      this.publicKey = publicKey;
      this.privateKey = privateKey;
      return [this.publicKey, this.privateKey];
    }
    /**
     * Generate a new account file given a password
     * @param password
     * @returns {{version: number, id: *, address: string, crypto: {ciphertext: string, cipherparams: {iv: string}, cipher: string, kdf: string, kdfparams: {dklen: number, salt: string, n: number, r: number, p: number}, mac: string}}}
     */

  }, {
    key: "initNewAccountFromPassword",
    value: function initNewAccountFromPassword(password) {
      this.initNewKeyPair();
      return this.generateKeyFile(password);
    }
    /**
     * Generate a new mnemonic phrase
     * @returns {string}
     */

  }, {
    key: "generateMnemonic",
    value: function generateMnemonic() {
      return bip39.generateMnemonic(MNEMONIC_LEN);
    }
    /**
     * Generate private key given a mnemonic. If derive is set to true, it will return the index account
     * from the derivation path
     *
     * @param mnemonic
     * @param derive
     * @param index
     * @param password
     * @returns {string}
     */

  }, {
    key: "privateKeyFromMnemonic",
    value: function privateKeyFromMnemonic(mnemonic) {
      var derive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var password = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

      if (!bip39.validateMnemonic(mnemonic)) {
        throw new Error("wrong mnemonic format");
      }

      var seed = bip39.mnemonicToSeedSync(mnemonic, password);

      var _derivePath = derivePath("".concat(HD_PREFIX, "/").concat(index, "'"), seed),
          key = _derivePath.key;

      return key.toString("hex");
    }
    /**
     * Loads an account from a given a mnemonic phrase
     *
     * @param mnemonic
     */

  }, {
    key: "loadFromMnemonic",
    value: function loadFromMnemonic(mnemonic) {
      var sk = this.privateKeyFromMnemonic(mnemonic);
      return this.loadFromSeed(Buffer.from(sk, 'hex'));
    }
    /**
     * Creates a signature over a message using Schnorr signature scheme
     * @param message
     */

  }, {
    key: "sign",
    value: function sign(message) {
      if (!this.privateKey) {
        console.warn("account is not initialized, cannot sign message");
        return;
      }

      var sig = signer.sign(message, this.privateKey);
      return Buffer.from(sig).toString('hex');
    }
  }, {
    key: "initBLS",
    value: function () {
      var _initBLS = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", blsSigner.init());

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function initBLS() {
        return _initBLS.apply(this, arguments);
      }

      return initBLS;
    }()
  }, {
    key: "generateBLSKeypair",
    value: function generateBLSKeypair(privateKey) {
      return blsSigner.generatePairFromSeed(privateKey);
    }
  }, {
    key: "computeBLSSig",
    value: function computeBLSSig(message, privateKey) {
      return blsSigner.sign(message, privateKey);
    }
  }]);
  return Account;
}();

module.exports = Account;