import { createAction, createSlice, combineReducers, configureStore } from '@reduxjs/toolkit';
import { ChainID, Address, ExtensionProvider, HWProvider, WalletConnectProvider, WalletProvider, ProxyProvider, ApiProvider, TransactionVersion, TransactionOptions, Transaction, Balance, TransactionPayload, GasLimit, GasPrice, Token, Nonce as Nonce$1 } from '@elrondnetwork/erdjs';
import isEqual from 'lodash/isEqual';
import { createSelectorCreator, defaultMemoize, createSelector } from 'reselect';
import { REHYDRATE, persistReducer, FLUSH, PAUSE, PERSIST, PURGE, REGISTER, persistStore } from 'redux-persist';
import storage$1 from 'redux-persist/lib/storage';
import throttle from 'lodash/throttle';
import sessionStorage$1 from 'redux-persist/lib/storage/session';
import omit from 'lodash/omit';
import BigNumber from 'bignumber.js';
import { Nonce, TransactionOptions as TransactionOptions$1, createBalanceBuilder, Token as Token$1, TokenType, Address as Address$1 } from '@elrondnetwork/erdjs/out';
import { validation, operations } from '@elrondnetwork/dapp-utils';
import React__default, { useState, useRef, useEffect, useContext, useCallback, createElement, Fragment, Component, useMemo } from 'react';
import { createStoreHook, createDispatchHook, createSelectorHook, Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';
import axios from 'axios';
import { Signature } from '@elrondnetwork/erdjs/out/signature';
import qs from 'qs';
import debounce from 'lodash/debounce';

// A type of promise-like that resolves synchronously and supports only one observer
const _Pact = /*#__PURE__*/(function() {
	function _Pact() {}
	_Pact.prototype.then = function(onFulfilled, onRejected) {
		const result = new _Pact();
		const state = this.s;
		if (state) {
			const callback = state & 1 ? onFulfilled : onRejected;
			if (callback) {
				try {
					_settle(result, 1, callback(this.v));
				} catch (e) {
					_settle(result, 2, e);
				}
				return result;
			} else {
				return this;
			}
		}
		this.o = function(_this) {
			try {
				const value = _this.v;
				if (_this.s & 1) {
					_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
				} else if (onRejected) {
					_settle(result, 1, onRejected(value));
				} else {
					_settle(result, 2, value);
				}
			} catch (e) {
				_settle(result, 2, e);
			}
		};
		return result;
	};
	return _Pact;
})();

// Settles a pact synchronously
function _settle(pact, state, value) {
	if (!pact.s) {
		if (value instanceof _Pact) {
			if (value.s) {
				if (state & 1) {
					state = value.s;
				}
				value = value.v;
			} else {
				value.o = _settle.bind(null, pact, state);
				return;
			}
		}
		if (value && value.then) {
			value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
			return;
		}
		pact.s = state;
		pact.v = value;
		const observer = pact.o;
		if (observer) {
			observer(pact);
		}
	}
}

function _isSettledPact(thenable) {
	return thenable instanceof _Pact && thenable.s & 1;
}

// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)
function _forTo(array, body, check) {
	var i = -1, pact, reject;
	function _cycle(result) {
		try {
			while (++i < array.length && (!check || !check())) {
				result = body(i);
				if (result && result.then) {
					if (_isSettledPact(result)) {
						result = result.v;
					} else {
						result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
						return;
					}
				}
			}
			if (pact) {
				_settle(pact, 1, result);
			} else {
				pact = result;
			}
		} catch (e) {
			_settle(pact || (pact = new _Pact()), 2, e);
		}
	}
	_cycle();
	return pact;
}

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

// Asynchronously iterate through an object's values
// Uses for...of if the runtime supports it, otherwise iterates until length on a copy
function _forOf(target, body, check) {
	if (typeof target[_iteratorSymbol] === "function") {
		var iterator = target[_iteratorSymbol](), step, pact, reject;
		function _cycle(result) {
			try {
				while (!(step = iterator.next()).done && (!check || !check())) {
					result = body(step.value);
					if (result && result.then) {
						if (_isSettledPact(result)) {
							result = result.v;
						} else {
							result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
							return;
						}
					}
				}
				if (pact) {
					_settle(pact, 1, result);
				} else {
					pact = result;
				}
			} catch (e) {
				_settle(pact || (pact = new _Pact()), 2, e);
			}
		}
		_cycle();
		if (iterator.return) {
			var _fixup = function(value) {
				try {
					if (!step.done) {
						iterator.return();
					}
				} catch(e) {
				}
				return value;
			};
			if (pact && pact.then) {
				return pact.then(_fixup, function(e) {
					throw _fixup(e);
				});
			}
			_fixup();
		}
		return pact;
	}
	// No support for Symbol.iterator
	if (!("length" in target)) {
		throw new TypeError("Object is not iterable");
	}
	// Handle live collections properly
	var values = [];
	for (var i = 0; i < target.length; i++) {
		values.push(target[i]);
	}
	return _forTo(values, function(i) { return body(values[i]); }, check);
}

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

// Asynchronously await a promise and pass the result to a finally continuation
function _finallyRethrows(body, finalizer) {
	try {
		var result = body();
	} catch (e) {
		return finalizer(true, e);
	}
	if (result && result.then) {
		return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
	}
	return finalizer(false, result);
}

var logoutAction = createAction('logout');
var loginAction = createAction('login', function (payload) {
  return {
    payload: payload
  };
});

var createDeepEqualSelector = createSelectorCreator(defaultMemoize, isEqual);

var networkConfigSelector = function networkConfigSelector(state) {
  return state.networkConfig;
};
var proxySelector = createDeepEqualSelector(networkConfigSelector, function (state) {
  return state.proxy;
});
var providerSelector = createDeepEqualSelector(networkConfigSelector, function (state) {
  return state.provider;
});
var chainIDSelector = createDeepEqualSelector(networkConfigSelector, function (state) {
  return new ChainID(state.chainID);
});
var apiProviderSelector = createDeepEqualSelector(networkConfigSelector, function (state) {
  return state.apiProvider;
});
var walletConnectBridgeAddressSelector = createDeepEqualSelector(networkConfigSelector, function (state) {
  return state.network.walletConnectBridgeAddress;
});
var walletConnectDeepLinkSelector = createDeepEqualSelector(networkConfigSelector, function (state) {
  return state.network.walletConnectDeepLink;
});
var networkSelector = createDeepEqualSelector(networkConfigSelector, function (state) {
  return state.network;
});
var apiNetworkSelector = createDeepEqualSelector(networkSelector, function (state) {
  return state.apiAddress;
});
var explorerAddressSelector = createDeepEqualSelector(networkSelector, function (state) {
  return state.explorerAddress;
});
var egldLabelSelector = createDeepEqualSelector(networkSelector, function (state) {
  return state.egldLabel;
});

var TransactionServerStatusesEnum;

(function (TransactionServerStatusesEnum) {
  TransactionServerStatusesEnum["pending"] = "pending";
  TransactionServerStatusesEnum["fail"] = "fail";
  TransactionServerStatusesEnum["invalid"] = "invalid";
  TransactionServerStatusesEnum["success"] = "success";
  TransactionServerStatusesEnum["executed"] = "executed";
  TransactionServerStatusesEnum["completed"] = "completed";
})(TransactionServerStatusesEnum || (TransactionServerStatusesEnum = {}));

var TransactionBatchStatusesEnum;

(function (TransactionBatchStatusesEnum) {
  TransactionBatchStatusesEnum["signed"] = "signed";
  TransactionBatchStatusesEnum["cancelled"] = "cancelled";
  TransactionBatchStatusesEnum["success"] = "success";
  TransactionBatchStatusesEnum["sent"] = "sent";
  TransactionBatchStatusesEnum["fail"] = "fail";
  TransactionBatchStatusesEnum["timedOut"] = "timedOut";
})(TransactionBatchStatusesEnum || (TransactionBatchStatusesEnum = {}));

var LoginMethodsEnum;

(function (LoginMethodsEnum) {
  LoginMethodsEnum["ledger"] = "ledger";
  LoginMethodsEnum["walletconnect"] = "walletconnect";
  LoginMethodsEnum["wallet"] = "wallet";
  LoginMethodsEnum["extension"] = "extension";
  LoginMethodsEnum["extra"] = "extra";
  LoginMethodsEnum["none"] = "";
})(LoginMethodsEnum || (LoginMethodsEnum = {}));

var NotificationTypesEnum;

(function (NotificationTypesEnum) {
  NotificationTypesEnum["warning"] = "warning";
  NotificationTypesEnum["error"] = "error";
  NotificationTypesEnum["success"] = "success";
})(NotificationTypesEnum || (NotificationTypesEnum = {}));

var TypesOfSmartContractCallsEnum;

(function (TypesOfSmartContractCallsEnum) {
  TypesOfSmartContractCallsEnum["MultiESDTNFTTransfer"] = "MultiESDTNFTTransfer";
  TypesOfSmartContractCallsEnum["ESDTNFTTransfer"] = "ESDTNFTTransfer";
})(TypesOfSmartContractCallsEnum || (TypesOfSmartContractCallsEnum = {}));

var EnvironmentsEnum;

(function (EnvironmentsEnum) {
  EnvironmentsEnum["testnet"] = "testnet";
  EnvironmentsEnum["devnet"] = "devnet";
  EnvironmentsEnum["mainnet"] = "mainnet";
})(EnvironmentsEnum || (EnvironmentsEnum = {}));

var accountInfoSelector = function accountInfoSelector(state) {
  return state.account;
};
var addressSelector = createDeepEqualSelector(accountInfoSelector, function (state) {
  return state.address;
});
var accountSelector = createDeepEqualSelector(accountInfoSelector, function (state) {
  return state.account;
});
var accountBalanceSelector = createDeepEqualSelector(accountSelector, function (account) {
  return account.balance;
});
var accountNonceSelector = createDeepEqualSelector(accountSelector, function (state) {
  var _state$nonce;

  return (state === null || state === void 0 ? void 0 : (_state$nonce = state.nonce) === null || _state$nonce === void 0 ? void 0 : _state$nonce.valueOf()) || 0;
});
var shardSelector = createDeepEqualSelector(accountInfoSelector, function (state) {
  return state.shard;
});
var ledgerAccountSelector = createDeepEqualSelector(accountInfoSelector, function (state) {
  return state.ledgerAccount;
});
var walletConnectAccountSelector = createDeepEqualSelector(accountInfoSelector, function (state) {
  return state.walletConnectAccount;
});
var isAccountLoadingSelector = createDeepEqualSelector(accountInfoSelector, function (state) {
  return state.isAccountLoading;
});
var isAccountLoadingErrorSelector = createDeepEqualSelector(accountInfoSelector, function (state) {
  return state.accountLoadingError;
});

var loginInfoSelector = function loginInfoSelector(state) {
  return state.loginInfo;
};
var loginMethodSelector = createDeepEqualSelector(loginInfoSelector, function (state) {
  return state.loginMethod;
});
var isLoggedInSelector = createDeepEqualSelector(loginInfoSelector, addressSelector, function (state, address) {
  return state.loginMethod != LoginMethodsEnum.none && Boolean(address);
});
var walletConnectLoginSelector = createDeepEqualSelector(loginInfoSelector, function (state) {
  return state.walletConnectLogin;
});
var ledgerLoginSelector = createDeepEqualSelector(loginInfoSelector, function (state) {
  return state.ledgerLogin;
});
var walletLoginSelector = createDeepEqualSelector(loginInfoSelector, function (state) {
  return state.walletLogin;
});
var loginExpiresAtSelector = createDeepEqualSelector(loginInfoSelector, function (state) {
  return state.loginExpiresAt;
});

function getNewLoginExpiresTimestamp() {
  return new Date().setHours(new Date().getHours() + 24);
}

function optionalRedirect(callbackUrl, shouldRedirect) {
  if (shouldRedirect && callbackUrl != null) {
    setTimeout(function () {
      if (!window.location.pathname.includes(callbackUrl)) {
        window.location.href = callbackUrl;
      }
    }, 200);
  }
}

function getBridgeAddressFromNetwork(walletConnectBridgeAddresses) {
  return walletConnectBridgeAddresses[Math.floor(Math.random() * walletConnectBridgeAddresses.length)];
}

var initialState = {
  loginMethod: LoginMethodsEnum.none,
  walletConnectLogin: null,
  ledgerLogin: null,
  tokenLogin: null,
  walletLogin: null,
  extensionLogin: null,
  loginExpiresAt: getNewLoginExpiresTimestamp()
};
var loginInfoSlice = createSlice({
  name: 'loginInfoSlice',
  initialState: initialState,
  reducers: {
    setLoginMethod: function setLoginMethod(state, action) {
      state.loginMethod = action.payload;
    },
    setTokenLogin: function setTokenLogin(state, action) {
      state.tokenLogin = action.payload;
    },
    setTokenLoginSignature: function setTokenLoginSignature(state, action) {
      if ((state === null || state === void 0 ? void 0 : state.tokenLogin) != null) {
        state.tokenLogin.signature = action.payload;
      }
    },
    setWalletLogin: function setWalletLogin(state, action) {
      state.walletLogin = action.payload;
    },
    setWalletConnectLogin: function setWalletConnectLogin(state, action) {
      state.walletConnectLogin = action.payload;
    },
    setLedgerLogin: function setLedgerLogin(state, action) {
      state.ledgerLogin = action.payload;
    },
    setLoginExpiresAt: function setLoginExpiresAt(state, action) {
      state.loginExpiresAt = action.payload;
    }
  },
  extraReducers: function extraReducers(builder) {
    builder.addCase(logoutAction, function () {
      return initialState;
    });
    builder.addCase(loginAction, function (state, action) {
      state.loginMethod = action.payload.loginMethod;
      state.loginExpiresAt = getNewLoginExpiresTimestamp();
    });
  }
});
var _loginInfoSlice$actio = loginInfoSlice.actions,
    setWalletConnectLogin = _loginInfoSlice$actio.setWalletConnectLogin,
    setLedgerLogin = _loginInfoSlice$actio.setLedgerLogin,
    setTokenLogin = _loginInfoSlice$actio.setTokenLogin,
    setTokenLoginSignature = _loginInfoSlice$actio.setTokenLoginSignature,
    setWalletLogin = _loginInfoSlice$actio.setWalletLogin,
    setLoginExpiresAt = _loginInfoSlice$actio.setLoginExpiresAt;
var loginInfo = loginInfoSlice.reducer;

var whitelistedActions = ['loginInfoSlice/setLoginExpiresAt', 'logout'];
var throttledSetNewToken = throttle(function (store) {
  store.dispatch(setLoginExpiresAt(getNewLoginExpiresTimestamp()));
}, 5000);
var loginSessionMiddleware = function loginSessionMiddleware(store) {
  return function (next) {
    return function (action) {
      if (whitelistedActions.includes(action.type)) {
        return next(action);
      }

      var appState = store.getState();
      var loginTimestamp = loginExpiresAtSelector(appState);
      var isLoggedIn = isLoggedInSelector(appState);

      if (!isLoggedIn) {
        return next(action);
      }

      if (loginTimestamp == null) {
        return store.dispatch(setLoginExpiresAt(getNewLoginExpiresTimestamp()));
      }

      var now = Date.now();
      var isExpired = loginTimestamp - now < 0;

      if (isExpired) {
        return setTimeout(function () {
          try {
            var provider = providerSelector(store.getState());
            console.log('session expired');
            store.dispatch(logoutAction());

            var _temp2 = _catch(function () {
              return Promise.resolve(provider.logout({
                callbackUrl: '/'
              })).then(function () {});
            }, function (err) {
              console.error('error logging out', err);
            });

            return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
          } catch (e) {
            return Promise.reject(e);
          }
        }, 1000);
      } else {
        throttledSetNewToken(store);
      }

      return next(action);
    };
  };
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var emptyAccount = {
  balance: '...',
  address: '',
  nonce: 0
};
var initialState$1 = {
  address: '',
  account: emptyAccount,
  ledgerAccount: null,
  publicKey: '',
  walletConnectAccount: null,
  isAccountLoading: true,
  accountLoadingError: null
};
var accountInfoSlice = createSlice({
  name: 'accountInfoSlice',
  initialState: initialState$1,
  reducers: {
    setAddress: function setAddress(state, action) {
      var address = action.payload;
      state.address = address;
      state.publicKey = new Address(address).hex();
    },
    setAccount: function setAccount(state, action) {
      state.account = action.payload;
      state.isAccountLoading = false;
      state.accountLoadingError = null;
    },
    setAccountNonce: function setAccountNonce(state, action) {
      state.account.nonce = action.payload;
    },
    setAccountShard: function setAccountShard(state, action) {
      state.shard = action.payload;
    },
    setLedgerAccount: function setLedgerAccount(state, action) {
      state.ledgerAccount = action.payload;
    },
    setWalletConnectAccount: function setWalletConnectAccount(state, action) {
      state.walletConnectAccount = action.payload;
    },
    setIsAccountLoading: function setIsAccountLoading(state, action) {
      state.isAccountLoading = action.payload;
      state.accountLoadingError = null;
    },
    setAccountLoadingError: function setAccountLoadingError(state, action) {
      state.accountLoadingError = action.payload;
      state.isAccountLoading = false;
    }
  },
  extraReducers: function extraReducers(builder) {
    builder.addCase(logoutAction, function () {
      return initialState$1;
    });
    builder.addCase(loginAction, function (state, action) {
      var address = action.payload.address;
      state.address = address;
      state.publicKey = new Address(address).hex();
    });
    builder.addCase(REHYDRATE, function (state, action) {
      var _action$payload;

      if (!((_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.account)) {
        return;
      }

      var accountInfo = action.payload.account;
      var address = accountInfo.address,
          shard = accountInfo.shard,
          account = accountInfo.account,
          publicKey = accountInfo.publicKey;
      state.address = address;
      state.shard = shard;
      state.account = account;
      state.publicKey = publicKey;
    });
  }
});
var _accountInfoSlice$act = accountInfoSlice.actions,
    setAccount = _accountInfoSlice$act.setAccount,
    setAccountNonce = _accountInfoSlice$act.setAccountNonce,
    setAccountShard = _accountInfoSlice$act.setAccountShard,
    setLedgerAccount = _accountInfoSlice$act.setLedgerAccount,
    setIsAccountLoading = _accountInfoSlice$act.setIsAccountLoading,
    setAccountLoadingError = _accountInfoSlice$act.setAccountLoadingError;
var account = accountInfoSlice.reducer;

var DAPP_INIT_ROUTE = '/dapp/init';
var getProviderType = function getProviderType(provider) {
  switch (provider === null || provider === void 0 ? void 0 : provider.constructor) {
    case WalletProvider:
      return LoginMethodsEnum.wallet;

    case WalletConnectProvider:
      return LoginMethodsEnum.walletconnect;

    case HWProvider:
      return LoginMethodsEnum.ledger;

    case ExtensionProvider:
      return LoginMethodsEnum.extension;

    case EmptyProvider:
      return LoginMethodsEnum.none;

    default:
      return LoginMethodsEnum.extra;
  }
};
var newWalletProvider = function newWalletProvider(walletAddress) {
  return new WalletProvider("" + walletAddress + DAPP_INIT_ROUTE);
};

var notInitializedError = function notInitializedError(caller) {
  return "Unable to perform " + caller + ", Provider not initialized";
};

var EmptyProvider = /*#__PURE__*/function () {
  function EmptyProvider() {}

  var _proto = EmptyProvider.prototype;

  _proto.init = function init() {
    return Promise.resolve(false);
  };

  _proto.login = function login(options) {
    throw new Error(notInitializedError("login with options: " + options));
  };

  _proto.logout = function logout(options) {
    try {
      throw new Error(notInitializedError("logout with options: " + options));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getAddress = function getAddress() {
    try {
      throw new Error(notInitializedError('getAddress'));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.isInitialized = function isInitialized() {
    return false;
  };

  _proto.isConnected = function isConnected() {
    return Promise.resolve(false);
  };

  _proto.sendTransaction = function sendTransaction(transaction, options) {
    try {
      throw new Error(notInitializedError("sendTransaction with transactions: " + transaction + " options: " + options));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.signTransaction = function signTransaction(transaction, options) {
    try {
      throw new Error(notInitializedError("signTransaction with transactions: " + transaction + " options: " + options));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.signTransactions = function signTransactions(transactions, options) {
    try {
      throw new Error(notInitializedError("signTransactions with transactions: " + transactions + " options: " + options));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.signMessage = function signMessage(message) {
    try {
      throw new Error(notInitializedError("signTransactions with " + message));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return EmptyProvider;
}();
var emptyProvider = new EmptyProvider();

var initialState$2 = {
  log: function log() {
    return null;
  },
  getProvider: function getProvider() {
    return emptyProvider;
  },
  init: function init() {
    return null;
  }
};
var extraActionsSlice = createSlice({
  name: 'extraActionsSlice',
  initialState: initialState$2,
  reducers: {
    initializeExtraActions: function initializeExtraActions(state, action) {
      return _extends({}, state, action.payload);
    }
  }
});
var initializeExtraActions = extraActionsSlice.actions.initializeExtraActions;
var extraActions = extraActionsSlice.reducer;

var initialState$3 = {};
var modalsSlice = createSlice({
  name: 'modalsSlice',
  initialState: initialState$3,
  reducers: {
    setTxSubmittedModal: function setTxSubmittedModal(state, action) {
      state.txSubmittedModal = action.payload;
    },
    setNotificationModal: function setNotificationModal(state, action) {
      state.notificationModal = action.payload;
    },
    clearTxSubmittedModal: function clearTxSubmittedModal(state) {
      state.txSubmittedModal = undefined;
    },
    clearNotificationModal: function clearNotificationModal(state) {
      state.notificationModal = undefined;
    }
  },
  extraReducers: function extraReducers(builder) {
    builder.addCase(logoutAction, function () {
      return initialState$3;
    });
  }
});
var _modalsSlice$actions = modalsSlice.actions,
    setTxSubmittedModal = _modalsSlice$actions.setTxSubmittedModal,
    setNotificationModal = _modalsSlice$actions.setNotificationModal,
    clearNotificationModal = _modalsSlice$actions.clearNotificationModal;
var modals = modalsSlice.reducer;

var defaultNetwork = {
  id: 'not-configured',
  name: 'NOT CONFIGURED',
  egldLabel: '',
  egldDenomination: '18',
  decimals: '4',
  gasPerDataByte: '1500',
  walletConnectDeepLink: '',
  walletConnectBridgeAddress: '',
  walletAddress: '',
  apiAddress: '',
  explorerAddress: '',
  apiTimeout: '4000'
};
var initialState$4 = {
  network: defaultNetwork,
  proxy: new ProxyProvider(defaultNetwork.apiAddress, {
    timeout: Number(defaultNetwork.apiTimeout)
  }),
  apiProvider: new ApiProvider(defaultNetwork.apiAddress, {
    timeout: Number(defaultNetwork.apiTimeout)
  }),
  provider: emptyProvider,
  chainID: '-1'
};
var networkConfigSlice = createSlice({
  name: 'appConfig',
  initialState: initialState$4,
  reducers: {
    initializeNetworkConfig: function initializeNetworkConfig(state, action) {
      var walletConnectBridgeAddress = getBridgeAddressFromNetwork(action.payload.walletConnectBridgeAddresses);
      var network = omit(action.payload, 'walletConnectBridgeAddresses');
      var apiAddress = network.apiAddress;

      if (apiAddress) {
        state.proxy = new ProxyProvider(apiAddress, {
          timeout: Number(network.apiTimeout || defaultNetwork.apiTimeout)
        });
        state.apiProvider = new ApiProvider(apiAddress, {
          timeout: Number(network.apiTimeout || defaultNetwork.apiTimeout)
        });
      }

      state.network = _extends({}, state.network, network, {
        walletConnectBridgeAddress: walletConnectBridgeAddress
      });
    },
    setChainID: function setChainID(state, action) {
      state.chainID = action.payload;
    },
    setProvider: function setProvider(state, action) {
      state.provider = action.payload;
    }
  },
  extraReducers: function extraReducers(builder) {
    builder.addCase(logoutAction, function (state) {
      state.provider = initialState$4.provider;
    });
  }
});
var _networkConfigSlice$a = networkConfigSlice.actions,
    initializeNetworkConfig = _networkConfigSlice$a.initializeNetworkConfig,
    setChainID = _networkConfigSlice$a.setChainID,
    setProvider = _networkConfigSlice$a.setProvider;
var networkConfig = networkConfigSlice.reducer;

var defaultTransactionErrorMessage = 'Transaction failed';
var defaultTransactionSuccessMessage = 'Transaction successful';
var defaultTransactionProcessingMessage = 'Processing transaction';
var defaultTransactionSubmittedMessage = 'Transaction submitted';
var initialState$5 = {};
var signTransactionsSlice = createSlice({
  name: 'transactionsInfo',
  initialState: initialState$5,
  reducers: {
    setTransactionsDisplayInfo: function setTransactionsDisplayInfo(state, action) {
      var _action$payload = action.payload,
          sessionId = _action$payload.sessionId,
          transactionsDisplayInfo = _action$payload.transactionsDisplayInfo;

      if (sessionId != null) {
        state[sessionId] = {
          errorMessage: (transactionsDisplayInfo === null || transactionsDisplayInfo === void 0 ? void 0 : transactionsDisplayInfo.errorMessage) || defaultTransactionErrorMessage,
          successMessage: (transactionsDisplayInfo === null || transactionsDisplayInfo === void 0 ? void 0 : transactionsDisplayInfo.successMessage) || defaultTransactionSuccessMessage,
          processingMessage: (transactionsDisplayInfo === null || transactionsDisplayInfo === void 0 ? void 0 : transactionsDisplayInfo.processingMessage) || defaultTransactionProcessingMessage,
          submittedMessage: (transactionsDisplayInfo === null || transactionsDisplayInfo === void 0 ? void 0 : transactionsDisplayInfo.submittedMessage) || defaultTransactionSubmittedMessage,
          transactionDuration: transactionsDisplayInfo === null || transactionsDisplayInfo === void 0 ? void 0 : transactionsDisplayInfo.transactionDuration
        };
      }
    },
    clearTransactionsInfoForSessionId: function clearTransactionsInfoForSessionId(state, action) {
      if (action.payload != null) {
        delete state[action.payload];
      }
    },
    clearTransactionsInfo: function clearTransactionsInfo() {
      return initialState$5;
    }
  },
  extraReducers: function extraReducers(builder) {
    builder.addCase(logoutAction, function () {
      return initialState$5;
    });
  }
});
var _signTransactionsSlic = signTransactionsSlice.actions,
    setTransactionsDisplayInfo = _signTransactionsSlic.setTransactionsDisplayInfo,
    clearTransactionsInfoForSessionId = _signTransactionsSlic.clearTransactionsInfoForSessionId;
var transactionsInfo = signTransactionsSlice.reducer;

var TransactionTypesEnum;

(function (TransactionTypesEnum) {
  TransactionTypesEnum["MultiESDTNFTTransfer"] = "MultiESDTNFTTransfer";
  TransactionTypesEnum["ESDTTransfer"] = "ESDTTransfer";
  TransactionTypesEnum["ESDTNFTTransfer"] = "ESDTNFTTransfer";
  TransactionTypesEnum["esdtTransaction"] = "esdtTransaction";
  TransactionTypesEnum["nftTransaction"] = "nftTransaction";
  TransactionTypesEnum["scCall"] = "scCall";
})(TransactionTypesEnum || (TransactionTypesEnum = {}));

var okInHex = '6f6b';
function areScCallsSuccessful(scResults) {
  if (!scResults) {
    return true;
  }

  var success = false;
  scResults.forEach(function (result) {
    if (result !== null && result !== void 0 && result.data) {
      var decoded = Buffer.from(result.data, 'base64').toString().split('@');
      var hasOkPart = Boolean(decoded.find(function (part) {
        return part === okInHex;
      }));

      if (hasOkPart) {
        success = true;
        return;
      }
    }
  });
  return success;
}
function isContract(receiver, data) {
  if (data === void 0) {
    data = '';
  }

  try {
    var extractedAddress = getAddressFromDataField({
      receiver: receiver,
      data: data
    });

    if (!extractedAddress) {
      return false;
    }

    return new Address(extractedAddress).isContractAddress();
  } catch (err) {
    console.log('err', err);
    return false;
  }
}
function getAddressFromDataField(_ref) {
  var receiver = _ref.receiver,
      data = _ref.data;

  try {
    if (!data) {
      return receiver;
    }

    var addressIndex = getAddressIndex(data);
    var parts = data.split('@');
    return addressIndex > -1 ? parts[addressIndex] : receiver;
  } catch (err) {
    console.log(err);
    return;
  }
}

function getAddressIndex(data) {
  return data.includes(TypesOfSmartContractCallsEnum.MultiESDTNFTTransfer) ? 1 : data.includes(TypesOfSmartContractCallsEnum.ESDTNFTTransfer) ? 4 : -1;
}

var pendingBatchTransactionsStates = [TransactionBatchStatusesEnum.sent];
var successBatchTransactionsStates = [TransactionBatchStatusesEnum.success];
var failBatchTransactionsStates = [TransactionBatchStatusesEnum.fail, TransactionBatchStatusesEnum.cancelled, TransactionBatchStatusesEnum.timedOut];
var timedOutBatchTransactionsStates = [TransactionBatchStatusesEnum.timedOut];
var pendingServerTransactionsStatuses = [TransactionServerStatusesEnum.pending];
var successServerTransactionsStates = [TransactionServerStatusesEnum.success];
var completedServerTransactionsStates = [TransactionServerStatusesEnum.completed];
var failServerTransactionsStates = [TransactionServerStatusesEnum.fail, TransactionServerStatusesEnum.invalid];
function getIsTransactionCompleted(status) {
  return completedServerTransactionsStates.includes(status);
}
function getIsTransactionPending(status, isScCall) {
  if (isScCall === void 0) {
    isScCall = false;
  }

  var isPending = status != null && (isBatchTransactionPending(status) || isServerTransactionPending(status));
  return isScCall ? isPending || getIsTransactionSuccessful(status) && !getIsTransactionCompleted(status) : isPending;
}
function getIsTransactionSuccessful(status) {
  return status != null && (isBatchTransactionSuccessful(status) || isServerTransactionSuccessful(status));
}
function getIsTransactionFailed(status) {
  return status != null && (isBatchTransactionFailed(status) || isServerTransactionFailed(status));
}
function getIsTransactionTimedOut(status) {
  return status != null && isBatchTransactionTimedOut(status);
}
function isBatchTransactionPending(status) {
  return status != null && pendingBatchTransactionsStates.includes(status);
}
function isBatchTransactionSuccessful(status) {
  return status != null && successBatchTransactionsStates.includes(status);
}
function isBatchTransactionFailed(status) {
  return status != null && failBatchTransactionsStates.includes(status);
}
function isBatchTransactionTimedOut(status) {
  return status != null && timedOutBatchTransactionsStates.includes(status);
}
function isServerTransactionPending(status) {
  return status != null && pendingServerTransactionsStatuses.includes(status);
}
function isServerTransactionSuccessful(status) {
  return status != null && successServerTransactionsStates.includes(status);
}
function isServerTransactionFailed(status) {
  return status != null && failServerTransactionsStates.includes(status);
}

var base64Regex = /(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)/;
function isStringBase64(string) {
  return base64Regex.test(string);
}
function encodeToBase64(string) {
  return btoa(string);
}
function decodeBase64(string) {
  return atob(string);
}

var isUtf8 = function isUtf8(str) {
  for (var i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) > 127) return false;
  }

  return true;
};

function decodePart(part) {
  var decodedPart = part;

  try {
    var hexPart = Buffer.from(part, 'hex').toString().trim();

    if (isUtf8(hexPart) && hexPart.length > 1) {
      decodedPart = hexPart;
    }
  } catch (error) {}

  return decodedPart;
}

var getAllStringOccurrences = function getAllStringOccurrences(sourceStr, searchStr) {
  return [].concat(sourceStr.matchAll(new RegExp(searchStr, 'gi'))).map(function (a) {
    return a.index;
  });
};

function parseMultiEsdtTransferData(data) {
  var transactions = [];
  var contractCallDataIndex = 0;

  try {
    if (data !== null && data !== void 0 && data.startsWith(TransactionTypesEnum.MultiESDTNFTTransfer) && data !== null && data !== void 0 && data.includes('@')) {
      var _data$split = data === null || data === void 0 ? void 0 : data.split('@'),
          receiver = _data$split[1],
          encodedTxCount = _data$split[2],
          rest = _data$split.slice(3);

      if (receiver) {
        var txCount = new BigNumber(encodedTxCount, 16).toNumber();
        var itemIndex = 0;

        for (var txIndex = 0; txIndex < txCount; txIndex++) {
          var transaction = {
            type: TransactionTypesEnum.nftTransaction,
            data: '',
            receiver: receiver
          };

          for (var index = 0; index < 3; index++) {
            switch (index) {
              case 0:
                transaction.token = decodePart(rest[itemIndex]);
                transaction.data = rest[itemIndex];
                break;

              case 1:
                {
                  var encodedNonce = rest[itemIndex] && rest[itemIndex].length ? rest[itemIndex] : '';

                  if (encodedNonce) {
                    transaction.nonce = encodedNonce;
                  } else {
                    transaction.type = TransactionTypesEnum.esdtTransaction;
                  }

                  transaction.data = transaction.data + "@" + rest[itemIndex];
                  break;
                }

              case 2:
                transaction.amount = new BigNumber(rest[itemIndex], 16).toString(10);
                transaction.data = transaction.data + "@" + rest[itemIndex];
                break;

              default:
                break;
            }

            contractCallDataIndex = itemIndex + 1;
            itemIndex++;
          }

          transactions[txIndex] = transaction;
        }

        if (transactions.length !== txCount || transactions.some(function (tx) {
          return getAllStringOccurrences(tx.data, '@').length !== 2;
        }) || transactions.some(function (tx) {
          return tx.data.startsWith('@');
        })) {
          return [];
        }

        if (rest[contractCallDataIndex]) {
          var scCallData = rest[contractCallDataIndex];

          for (var i = contractCallDataIndex + 1; i < rest.length; i++) {
            scCallData += '@' + rest[i];
          }

          transactions[txCount] = {
            type: TransactionTypesEnum.scCall,
            data: scCallData,
            receiver: receiver
          };
        }
      }
    }
  } catch (err) {
    return transactions;
  }

  return transactions;
}

var noData = {
  tokenId: '',
  amount: ''
};
function getTokenFromData(data) {
  var tokenTransfer = data === null || data === void 0 ? void 0 : data.includes(TransactionTypesEnum.ESDTTransfer);
  var nftTransfer = data === null || data === void 0 ? void 0 : data.includes(TransactionTypesEnum.ESDTNFTTransfer);

  if (data != null && (tokenTransfer || nftTransfer)) {
    try {
      var encodedToken = data.split('@')[1];
      var encodedAmount = data.split('@')[tokenTransfer ? 2 : 3];
      var tokenId = Buffer.from(encodedToken, 'hex').toString('ascii');

      if (tokenId) {
        var amount = new BigNumber('0x' + encodedAmount.replace('0x', '')).toString(10);
        return {
          tokenId: tokenId,
          amount: amount
        };
      } else {
        return noData;
      }
    } catch (e) {
      return noData;
    }
  }

  return noData;
}

function isTokenTransfer(_ref) {
  var tokenId = _ref.tokenId,
      erdLabel = _ref.erdLabel;
  return Boolean(tokenId && tokenId !== erdLabel);
}

function buildUrlParams(search, urlParams) {
  var urlSearchParams = new URLSearchParams(search);
  var params = Object.fromEntries(urlSearchParams);
  var nextUrlParams = new URLSearchParams(_extends({}, params, urlParams)).toString();
  return {
    nextUrlParams: nextUrlParams,
    params: params
  };
}

function buildReplyUrl(_ref) {
  var callbackUrl = _ref.callbackUrl,
      _ref$urlParams = _ref.urlParams,
      urlParams = _ref$urlParams === void 0 ? {} : _ref$urlParams;
  var url = callbackUrl;

  if (Object.entries(urlParams).length > 0) {
    var _URL = new URL(callbackUrl),
        search = _URL.search,
        origin = _URL.origin,
        pathname = _URL.pathname;

    var _buildUrlParams = buildUrlParams(search, urlParams),
        nextUrlParams = _buildUrlParams.nextUrlParams;

    url = "" + origin + pathname + "?" + nextUrlParams;
  }

  return url;
}

function parseTransactionAfterSigning(transaction, isLedger) {
  if (isLedger === void 0) {
    isLedger = false;
  }

  if (isLedger) {
    transaction.version = TransactionVersion.withTxHashSignVersion();
    transaction.options = TransactionOptions.withTxHashSignOptions();
  }

  var parsedTransaction = transaction.toPlainObject();
  parsedTransaction.hash = transaction.getHash().toString();
  parsedTransaction.status = TransactionServerStatusesEnum.pending;
  return parsedTransaction;
}

var initialState$6 = {
  signedTransactions: {},
  transactionsToSign: null,
  signTransactionsError: null
};
var transactionsSlice = createSlice({
  name: 'transactionsSlice',
  initialState: initialState$6,
  reducers: {
    updateSignedTransaction: function updateSignedTransaction(state, action) {
      state.signedTransactions = _extends({}, state.signedTransactions, action.payload);
    },
    updateSignedTransactions: function updateSignedTransactions(state, action) {
      var _action$payload = action.payload,
          sessionId = _action$payload.sessionId,
          status = _action$payload.status,
          errorMessage = _action$payload.errorMessage,
          transactions = _action$payload.transactions;
      var transaction = state.signedTransactions[sessionId];

      if (transaction != null) {
        state.signedTransactions[sessionId].status = status;

        if (errorMessage != null) {
          state.signedTransactions[sessionId].errorMessage = errorMessage;
        }

        if (transactions != null) {
          state.signedTransactions[sessionId].transactions = transactions;
        }
      }
    },
    updateSignedTransactionStatus: function updateSignedTransactionStatus(state, action) {
      var _state$signedTransact, _state$signedTransact2;

      var _action$payload2 = action.payload,
          sessionId = _action$payload2.sessionId,
          status = _action$payload2.status,
          errorMessage = _action$payload2.errorMessage,
          transactionHash = _action$payload2.transactionHash;
      var transactions = (_state$signedTransact = state.signedTransactions) === null || _state$signedTransact === void 0 ? void 0 : (_state$signedTransact2 = _state$signedTransact[sessionId]) === null || _state$signedTransact2 === void 0 ? void 0 : _state$signedTransact2.transactions;

      if (transactions != null) {
        var _state$signedTransact3, _state$signedTransact4, _state$signedTransact5, _state$signedTransact6;

        state.signedTransactions[sessionId].transactions = transactions.map(function (transaction) {
          if (transaction.hash === transactionHash) {
            return _extends({}, transaction, {
              status: status,
              errorMessage: errorMessage
            });
          }

          return transaction;
        });
        var areTransactionsSuccessful = (_state$signedTransact3 = state.signedTransactions[sessionId]) === null || _state$signedTransact3 === void 0 ? void 0 : (_state$signedTransact4 = _state$signedTransact3.transactions) === null || _state$signedTransact4 === void 0 ? void 0 : _state$signedTransact4.every(function (transaction) {
          var isScCall = isContract(transaction.receiver, transaction.data);
          return isScCall ? getIsTransactionCompleted(transaction.status) : getIsTransactionSuccessful(transaction.status);
        });
        var areTransactionsFailed = (_state$signedTransact5 = state.signedTransactions[sessionId]) === null || _state$signedTransact5 === void 0 ? void 0 : (_state$signedTransact6 = _state$signedTransact5.transactions) === null || _state$signedTransact6 === void 0 ? void 0 : _state$signedTransact6.every(function (transaction) {
          return getIsTransactionFailed(transaction.status);
        });

        if (areTransactionsSuccessful) {
          state.signedTransactions[sessionId].status = TransactionBatchStatusesEnum.success;
        }

        if (areTransactionsFailed) {
          state.signedTransactions[sessionId].status = TransactionBatchStatusesEnum.fail;
        }
      }
    },
    setTransactionsToSign: function setTransactionsToSign(state, action) {
      state.transactionsToSign = action.payload;
      state.signTransactionsError = null;
    },
    clearSignTransactions: function clearSignTransactions(state) {
      state.transactionsToSign = initialState$6.transactionsToSign;
      state.signTransactionsError = null;
    },
    setSignTransactionsError: function setSignTransactionsError(state, action) {
      state.signTransactionsError = action.payload;
    }
  },
  extraReducers: function extraReducers(builder) {
    builder.addCase(logoutAction, function () {
      return initialState$6;
    });
    builder.addCase(REHYDRATE, function (state, action) {
      var _action$payload3;

      if (!((_action$payload3 = action.payload) !== null && _action$payload3 !== void 0 && _action$payload3.transactions)) {
        return;
      }

      var signedTransactions = action.payload.transactions.signedTransactions;
      var parsedSignedTransactions = Object.entries(signedTransactions).reduce(function (acc, _ref) {
        var sessionId = _ref[0],
            transaction = _ref[1];
        var txTimestamp = new Date(sessionId);
        var expiration = new Date();
        expiration.setHours(expiration.getHours() + 5);
        var isExpired = expiration - txTimestamp > 0;

        if (!isExpired) {
          acc[sessionId] = transaction;
        }

        return acc;
      }, {});

      if (signedTransactions != null) {
        state.signedTransactions = parsedSignedTransactions;
      }
    });
  }
});
var _transactionsSlice$ac = transactionsSlice.actions,
    updateSignedTransaction = _transactionsSlice$ac.updateSignedTransaction,
    updateSignedTransactionStatus = _transactionsSlice$ac.updateSignedTransactionStatus,
    updateSignedTransactions = _transactionsSlice$ac.updateSignedTransactions,
    setTransactionsToSign = _transactionsSlice$ac.setTransactionsToSign,
    clearSignTransactions = _transactionsSlice$ac.clearSignTransactions,
    setSignTransactionsError = _transactionsSlice$ac.setSignTransactionsError;
var transactions = transactionsSlice.reducer;

var transactionsInfoPersistConfig = {
  key: 'dapp-core-transactionsInfo',
  version: 1,
  storage: sessionStorage$1
};
var transactionsReducer = {
  key: 'dapp-core-transactions',
  version: 1,
  storage: sessionStorage$1,
  blacklist: ['transactionsToSign']
};
var customReducers = {
  transactions: persistReducer(transactionsReducer, transactions),
  transactionsInfo: persistReducer(transactionsInfoPersistConfig, transactionsInfo)
};
var rootReducer = combineReducers(_extends({}, customReducers, {
  account: account,
  networkConfig: networkConfig,
  extraActions: extraActions,
  loginInfo: loginInfo,
  modals: modals
}));

var persistConfig = {
  key: 'dapp-core-store',
  version: 1,
  storage: storage$1,
  whitelist: ['account', 'loginInfo', 'toasts', 'modals']
};
var localStorageReducers = persistReducer(persistConfig, rootReducer);
var store = configureStore({
  reducer: localStorageReducers,
  middleware: function middleware(getDefaultMiddleware) {
    return getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER, 'appConfig/setProvider', 'accountInfoSlice/setAccount', 'accountInfoSlice/setAccountNonce', 'extraActionsSlice/initializeExtraActions'],
        ignoredPaths: ['networkConfig.proxy', 'networkConfig.apiProvider', 'networkConfig.provider', 'payload.nonce', 'account.account.nonce', 'extraActions.log', 'payload.log', 'payload.onLogin', 'extraActions.getProvider', 'extraActions.init']
      }
    }).concat(loginSessionMiddleware);
  }
});
var persistor = persistStore(store);

var extraActionsSelector = function extraActionsSelector(state) {
  return state.extraActions;
};
var extraActionsInit = createSelector(extraActionsSelector, function (state) {
  return state.init;
});

function newTransaction(rawTransaction) {
  var data = rawTransaction.data;
  var parsedData = data ? atob(data) : '';
  return new Transaction(_extends({
    value: Balance.fromString(rawTransaction.value),
    data: new TransactionPayload(parsedData),
    nonce: new Nonce(rawTransaction.nonce),
    receiver: new Address(rawTransaction.receiver),
    gasLimit: new GasLimit(rawTransaction.gasLimit),
    gasPrice: new GasPrice(rawTransaction.gasPrice),
    chainID: new ChainID(rawTransaction.chainID)
  }, rawTransaction.version ? {
    version: new TransactionVersion(rawTransaction.version)
  } : {}, rawTransaction.options ? {
    options: new TransactionOptions$1(rawTransaction.options)
  } : {}));
}

var transactionsSelectors = function transactionsSelectors(state) {
  return state.transactions;
};
var signedTransactionsSelector = createDeepEqualSelector(transactionsSelectors, function (state) {
  return state.signedTransactions;
});
var signTransactionsErrorSelector = createDeepEqualSelector(transactionsSelectors, function (state) {
  return state.signTransactionsError;
});
var pendingSignedTransactionsSelector = createDeepEqualSelector(signedTransactionsSelector, function (signedTransactions) {
  return Object.entries(signedTransactions).reduce(function (acc, _ref) {
    var sessionId = _ref[0],
        txBody = _ref[1];

    if (getIsTransactionPending(txBody.status)) {
      acc[sessionId] = txBody;
    }

    return acc;
  }, {});
});
var successfulTransactionsSelector = createDeepEqualSelector(signedTransactionsSelector, function (signedTransactions) {
  return Object.entries(signedTransactions).reduce(function (acc, _ref2) {
    var sessionId = _ref2[0],
        txBody = _ref2[1];

    if (getIsTransactionSuccessful(txBody.status)) {
      acc[sessionId] = txBody;
    }

    return acc;
  }, {});
});
var completedTransactionsSelector = createDeepEqualSelector(signedTransactionsSelector, function (signedTransactions) {
  return Object.entries(signedTransactions).reduce(function (acc, _ref3) {
    var sessionId = _ref3[0],
        txBody = _ref3[1];

    if (getIsTransactionCompleted(txBody.status)) {
      acc[sessionId] = txBody;
    }

    return acc;
  }, {});
});
var failedTransactionsSelector = createDeepEqualSelector(signedTransactionsSelector, function (signedTransactions) {
  return Object.entries(signedTransactions).reduce(function (acc, _ref4) {
    var sessionId = _ref4[0],
        txBody = _ref4[1];

    if (getIsTransactionFailed(txBody.status)) {
      acc[sessionId] = txBody;
    }

    return acc;
  }, {});
});
var timedOutTransactionsSelector = createDeepEqualSelector(signedTransactionsSelector, function (signedTransactions) {
  return Object.entries(signedTransactions).reduce(function (acc, _ref5) {
    var sessionId = _ref5[0],
        txBody = _ref5[1];

    if (getIsTransactionTimedOut(txBody.status)) {
      acc[sessionId] = txBody;
    }

    return acc;
  }, {});
});
var transactionsToSignSelector = createDeepEqualSelector(transactionsSelectors, function (state) {
  var _state$transactionsTo;

  if ((state === null || state === void 0 ? void 0 : state.transactionsToSign) == null) {
    return null;
  }

  return _extends({}, state.transactionsToSign, {
    transactions: (state === null || state === void 0 ? void 0 : (_state$transactionsTo = state.transactionsToSign) === null || _state$transactionsTo === void 0 ? void 0 : _state$transactionsTo.transactions.map(function (tx) {
      return newTransaction(tx);
    })) || []
  });
});
var transactionStatusSelector = createDeepEqualSelector(signedTransactionsSelector, function (_, transactionSessionId) {
  return transactionSessionId;
}, function (signedTransactions, transactionSessionId) {
  return transactionSessionId != null ? (signedTransactions === null || signedTransactions === void 0 ? void 0 : signedTransactions[transactionSessionId]) || {} : {};
});

var defaultTransactionInfo = {
  errorMessage: defaultTransactionErrorMessage,
  successMessage: defaultTransactionSuccessMessage,
  processingMessage: defaultTransactionProcessingMessage
};
var transactionsInfoSelectors = function transactionsInfoSelectors(state) {
  return state.transactionsInfo;
};
var transactionDisplayInfoSelector = createDeepEqualSelector(transactionsInfoSelectors, function (_, transactionSessionId) {
  return transactionSessionId;
}, function (transactionsDisplayInfo, transactionSessionId) {
  return transactionSessionId != null ? (transactionsDisplayInfo === null || transactionsDisplayInfo === void 0 ? void 0 : transactionsDisplayInfo[Number(transactionSessionId)]) || defaultTransactionInfo : defaultTransactionInfo;
});

var modalsSliceSelector = function modalsSliceSelector(state) {
  return state.modals;
};
var txSubmittedModalSelector = createDeepEqualSelector(modalsSliceSelector, function (state) {
  return state.txSubmittedModal;
});
var notificationModalSelector = createDeepEqualSelector(modalsSliceSelector, function (state) {
  return state.notificationModal;
});

function getIsLoggedIn() {
  return isLoggedInSelector(store.getState());
}

var logout = function logout(callbackUrl, onRedirect) {
  try {
    var provider = providerSelector(store.getState());
    var isLoggedIn = getIsLoggedIn();

    if (!isLoggedIn) {
      return Promise.resolve();
    }

    store.dispatch(logoutAction());

    var _temp2 = _catch(function () {
      return Promise.resolve(provider.logout({
        callbackUrl: callbackUrl
      })).then(function () {
        if (callbackUrl) {
          if (onRedirect) {
            onRedirect(callbackUrl);
          } else {
            window.location.href = callbackUrl;
          }
        }
      });
    }, function (err) {
      console.error('error logging out', err);
    });

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
  } catch (e) {
    return Promise.reject(e);
  }
};

function buildUrlParams$1(search, urlParams) {
  var urlSearchParams = new URLSearchParams(search);
  var params = Object.fromEntries(urlSearchParams);
  var nextUrlParams = new URLSearchParams(_extends({}, params, urlParams)).toString();
  return {
    nextUrlParams: nextUrlParams,
    params: params
  };
}

var _excluded = ["default"];
function switchTrue(object) {
  var defaultValue = object["default"],
      rest = _objectWithoutPropertiesLoose(object, _excluded);

  var obj = _extends({
    "default": defaultValue
  }, rest);

  var result = Object.keys(obj).reduce(function (acc, cur) {
    var _extends2;

    return _extends({}, acc, (_extends2 = {}, _extends2[cur === 'default' ? 'true' : cur] = obj[cur], _extends2));
  }, {});
  return result['true'];
}

function canTransformToPublicKey(address) {
  try {
    var checkAddress = new Address(address);
    return Boolean(checkAddress.bech32());
  } catch (_unused) {
    return false;
  }
}

function addressIsValid(destinationAddress) {
  var isValidBach = (destinationAddress === null || destinationAddress === void 0 ? void 0 : destinationAddress.startsWith('erd')) && destinationAddress.length === 62 && /^\w+$/.test(destinationAddress);
  return isValidBach && canTransformToPublicKey(destinationAddress);
}

function getNetworkProxy() {
  return proxySelector(store.getState());
}

function getApiProvider() {
  return apiProviderSelector(store.getState());
}

function getAccountProvider() {
  return providerSelector(store.getState());
}

function getAccountProviderType() {
  var provider = getAccountProvider();
  return getProviderType(provider);
}

function getChainID() {
  return chainIDSelector(store.getState());
}

function getNetworkConfig() {
  return networkSelector(store.getState());
}

function getEgldLabel() {
  return egldLabelSelector(store.getState());
}

function getIsProviderEqualTo(comparedProviderType) {
  var providerType = getAccountProviderType();
  return providerType === comparedProviderType;
}

function getAddress() {
  var search = window.location.search;
  var appState = store.getState();
  var provider = providerSelector(appState);
  var address = addressSelector(appState);
  var loggedIn = isLoggedInSelector(appState);
  var walletLogin = walletLoginSelector(appState);

  if (getIsProviderEqualTo(LoginMethodsEnum.ledger) && loggedIn) {
    return new Promise(function (resolve) {
      resolve(address);
    });
  }

  return !getIsProviderEqualTo(LoginMethodsEnum.none) && !getIsProviderEqualTo(LoginMethodsEnum.wallet) && !getIsProviderEqualTo(LoginMethodsEnum.extra) ? provider.getAddress() : new Promise(function (resolve) {
    if (walletLogin != null) {
      var urlSearchParams = new URLSearchParams(search);
      var params = Object.fromEntries(urlSearchParams);

      if (addressIsValid(params.address)) {
        resolve(params.address);
      }
    }

    if (loggedIn) {
      resolve(address);
    }

    resolve('');
  });
}

function getAccount(address) {
  var proxy = proxySelector(store.getState());
  return proxy.getAccount(new Address(address));
}

function setNonce(nonce) {
  store.dispatch(setAccountNonce(nonce));
}

function getLatestNonce(account) {
  var appState = store.getState();
  var currentAccountNonce = accountNonceSelector(appState);
  return currentAccountNonce && !isNaN(currentAccountNonce) ? Math.max(currentAccountNonce, account.nonce.valueOf()) : account.nonce.valueOf();
}

var getAccountBalance = function getAccountBalance(address) {
  try {
    var accountAddress = address;

    if (accountAddress == null) {
      var account = accountSelector(store.getState());
      accountAddress = account.address;
    }

    return Promise.resolve(getAccount(accountAddress)).then(function (account) {
      return account.balance.toString();
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var refreshAccount = function refreshAccount() {
  try {
    var _exit4 = false;
    var provider = providerSelector(store.getState());

    var _temp4 = function () {
      if (provider.isInitialized()) {
        var _setNewAccount3 = setNewAccount();

        _exit4 = true;
        return _setNewAccount3;
      } else {
        return _catch(function () {
          return Promise.resolve(provider.init()).then(function (initialized) {
            if (!initialized) {
              _exit4 = true;
              return;
            }

            var _setNewAccount2 = setNewAccount();

            _exit4 = true;
            return _setNewAccount2;
          });
        }, function (e) {
          console.error('Failed initializing provider ', e);
        });
      }
    }();

    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function (_result4) {
      return _exit4 ? _result4 : undefined;
    }) : _exit4 ? _temp4 : undefined);
  } catch (e) {
    return Promise.reject(e);
  }
};

var setNewAccount = function setNewAccount() {
  try {
    var _exit2 = false;

    var _temp2 = _catch(function () {
      return Promise.resolve(getAddress()).then(function (address) {
        return _catch(function () {
          return Promise.resolve(getAccount(address)).then(function (account) {
            var accountData = {
              balance: account.balance.toString(),
              address: address,
              nonce: getLatestNonce(account)
            };
            store.dispatch(setAccount(accountData));
            _exit2 = true;
            return accountData;
          });
        }, function (e) {
          console.error('Failed getting account ', e);
        });
      });
    }, function (e) {
      console.error('Failed getting address ', e);
    });

    return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function (_result) {
      return _exit2 ? _result : null;
    }) : _exit2 ? _temp2 : null);
  } catch (e) {
    return Promise.reject(e);
  }
};

var isAddressOfMetachain = function isAddressOfMetachain(pubKey) {
  var metachainPrefix = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  var pubKeyPrefix = pubKey.slice(0, metachainPrefix.length);

  if (pubKeyPrefix.equals(metachainPrefix)) {
    return true;
  }

  var zeroAddress = Buffer.alloc(32).fill(0);
  return pubKey.equals(zeroAddress);
};

var getShardOfAddress = function getShardOfAddress(hexPubKey) {
  try {
    var numShards = 3;
    var maskHigh = parseInt('11', 2);
    var maskLow = parseInt('01', 2);
    var pubKey = Buffer.from(hexPubKey, 'hex');
    var lastByteOfPubKey = pubKey[31];

    if (isAddressOfMetachain(pubKey)) {
      return 4294967295;
    }

    var shard = lastByteOfPubKey & maskHigh;

    if (shard > numShards - 1) {
      shard = lastByteOfPubKey & maskLow;
    }

    return shard;
  } catch (err) {
    return -1;
  }
};

var logarithmicRest = function logarithmicRest(position) {
  var minp = 0;
  var maxp = 10;
  var minv = Math.log(0.005);
  var maxv = Math.log(2);
  var scale = (maxv - minv) / (maxp - minp);
  return Math.exp(minv + scale * (position - minp));
};

var ledgerErrorCodes = {
  0x9000: {
    code: 'codeSuccess',
    message: 'Success'
  },
  0x6985: {
    code: 'ERR_USER_DENIED',
    message: 'Rejected by user'
  },
  0x6d00: {
    code: 'ERR_UNKNOWN_INSTRUCTION',
    message: 'Unknown instruction'
  },
  0x6e00: {
    code: 'ERR_WRONG_CLA',
    message: 'Wrong CLA'
  },
  0x6e01: {
    code: 'ERR_INVALID_ARGUMENTS',
    message: 'Invalid arguments'
  },
  0x6e02: {
    code: 'ERR_INVALID_MESSAGE',
    message: 'Invalid message'
  },
  0x6e03: {
    code: 'ERR_INVALID_P1',
    message: 'Invalid P1'
  },
  0x6e04: {
    code: 'ERR_MESSAGE_TOO_LONG',
    message: 'Message too long'
  },
  0x6e05: {
    code: 'ERR_RECEIVER_TOO_LONG',
    message: 'Receiver too long'
  },
  0x6e06: {
    code: 'ERR_AMOUNT_TOO_LONG',
    message: 'Amount too long'
  },
  0x6e07: {
    code: 'ERR_CONTRACT_DATA_DISABLED',
    message: 'Contract data disabled in app options'
  },
  0x6e08: {
    code: 'ERR_MESSAGE_INCOMPLETE',
    message: 'Message incomplete'
  },
  0x6e10: {
    code: 'ERR_SIGNATURE_FAILED',
    message: 'Signature failed'
  },
  0x6e09: {
    code: 'ERR_WRONG_TX_VERSION',
    message: 'Wrong TX version'
  },
  0x6e0a: {
    code: 'ERR_NONCE_TOO_LONG',
    message: 'Nonce too long'
  },
  0x6e0b: {
    code: 'ERR_INVALID_AMOUNT',
    message: 'Invalid amount'
  },
  0x6e0c: {
    code: 'ERR_INVALID_FEE',
    message: 'Invalid fee'
  },
  0x6e0d: {
    code: 'ERR_PRETTY_FAILED',
    message: 'Pretty failed'
  },
  0x6e0e: {
    code: 'ERR_DATA_TOO_LONG',
    message: 'Data too long'
  },
  0x6e0f: {
    code: 'ERR_WRONG_TX_OPTIONS',
    message: 'Invalid transaction options'
  },
  0x6e11: {
    code: 'ERR_SIGN_TX_DEPRECATED',
    message: 'Regular transaction signing is deprecated in this version. Use hash signing.'
  }
};

var ledgerErrorCodes$1 = {
  __proto__: null,
  'default': ledgerErrorCodes
};

var DEFAULT_MIN_GAS_LIMIT = 50000;
var configEndpoint = {
  mainnet: 'https://api.elrond.com/dapp/config',
  testnet: 'https://testnet-api.elrond.com/dapp/config',
  devnet: 'https://devnet-api.elrond.com/dapp/config'
};
var fallbackConfigurations = {
  devnet: {
    id: 'devnet',
    name: 'Devnet',
    egldLabel: 'xEGLD',
    egldDenomination: '18',
    decimals: '4',
    gasPerDataByte: '1500',
    walletConnectDeepLink: 'https://maiar.page.link/?apn=com.elrond.maiar.wallet&isi=1519405832&ibi=com.elrond.maiar.wallet&link=https://maiar.com/',
    walletConnectBridgeAddresses: ['https://bridge.walletconnect.org'],
    walletAddress: 'https://devnet-wallet.elrond.com',
    apiAddress: 'https://devnet-api.elrond.com',
    explorerAddress: 'http://devnet-explorer.elrond.com',
    apiTimeout: '4000'
  },
  testnet: {
    id: 'testnet',
    name: 'Testnet',
    egldLabel: 'xEGLD',
    egldDenomination: '18',
    decimals: '4',
    gasPerDataByte: '1500',
    walletConnectDeepLink: 'https://maiar.page.link/?apn=com.elrond.maiar.wallet&isi=1519405832&ibi=com.elrond.maiar.wallet&link=https://maiar.com/',
    walletConnectBridgeAddresses: ['https://bridge.walletconnect.org'],
    walletAddress: 'https://testnet-wallet.elrond.com',
    apiAddress: 'https://testnet-api.elrond.com',
    explorerAddress: 'http://testnet-explorer.elrond.com',
    apiTimeout: '4000'
  },
  mainnet: {
    id: 'mainnet',
    name: 'Mainnet',
    egldLabel: 'xEGLD',
    egldDenomination: '18',
    decimals: '4',
    gasPerDataByte: '1500',
    walletConnectDeepLink: 'https://maiar.page.link/?apn=com.elrond.maiar.wallet&isi=1519405832&ibi=com.elrond.maiar.wallet&link=https://maiar.com/',
    walletConnectBridgeAddresses: ['https://bridge.walletconnect.org'],
    walletAddress: 'https://wallet.elrond.com',
    apiAddress: 'https://api.elrond.com',
    explorerAddress: 'https://explorer.elrond.com',
    apiTimeout: '4000'
  }
};

var gasPriceModifier = '0.01';
var gasPerDataByte = '1500';
var defaultGasPrice = 1000000000;
var defaultGasLimit = 60000000;
var denomination = 18;
var decimals = 4;
var dappInitRoute = '/dapp/init';
var walletSignSession = 'signSession';

function pipe(previous) {
  return {
    "if": function _if(condition) {
      if (condition) {
        return {
          then: function then(newValue) {
            return newValue instanceof Function ? pipe(newValue(previous)) : pipe(newValue);
          }
        };
      } else {
        return {
          then: function then() {
            return pipe(previous);
          }
        };
      }
    },
    then: function then(newValue) {
      return newValue instanceof Function ? pipe(newValue(previous)) : pipe(newValue);
    },
    valueOf: function valueOf() {
      return previous;
    }
  };
}

BigNumber.config({
  ROUNDING_MODE: BigNumber.ROUND_FLOOR
});
function denominate(_ref) {
  var input = _ref.input,
      _ref$denomination = _ref.denomination,
      denomination$1 = _ref$denomination === void 0 ? denomination : _ref$denomination,
      _ref$decimals = _ref.decimals,
      decimals$1 = _ref$decimals === void 0 ? decimals : _ref$decimals,
      _ref$showLastNonZeroD = _ref.showLastNonZeroDecimal,
      showLastNonZeroDecimal = _ref$showLastNonZeroD === void 0 ? true : _ref$showLastNonZeroD,
      _ref$addCommas = _ref.addCommas,
      addCommas = _ref$addCommas === void 0 ? false : _ref$addCommas;
  var token = new Token({
    decimals: denomination$1
  });

  if (typeof input === 'string' && !validation.stringIsInteger(input, false)) {
    throw new Error('Invalid input');
  }

  return pipe(input)["if"](typeof input === 'string').then(function () {
    return new Balance(token, 0, new BigNumber(input)).toDenominated();
  })["if"](input.constructor === Balance).then(function () {
    return input.toDenominated();
  }).then(function (current) {
    var bnBalance = new BigNumber(current);

    if (bnBalance.isZero()) {
      return '0';
    }

    var balance = bnBalance.toString(10);

    var _balance$split = balance.split('.'),
        integerPart = _balance$split[0],
        decimalPart = _balance$split[1];

    var bNdecimalPart = new BigNumber(decimalPart || 0);
    var decimalPlaces = pipe(0)["if"](Boolean(decimalPart && showLastNonZeroDecimal)).then(function () {
      return Math.max(decimalPart.length, decimals$1);
    })["if"](bNdecimalPart.isZero() && !showLastNonZeroDecimal).then(0)["if"](Boolean(decimalPart && !showLastNonZeroDecimal)).then(function () {
      return Math.min(decimalPart.length, decimals$1);
    }).valueOf();
    var shownDecimalsAreZero = decimalPart && decimals$1 >= 1 && decimals$1 <= decimalPart.length && bNdecimalPart.isGreaterThan(0) && new BigNumber(decimalPart.substring(0, decimals$1)).isZero();
    var formatted = bnBalance.toFormat(decimalPlaces);
    var formattedBalance = pipe(balance)["if"](addCommas).then(formatted)["if"](Boolean(shownDecimalsAreZero) && !showLastNonZeroDecimal).then(function (current) {
      var integerPartZero = new BigNumber(integerPart).isZero();

      var _current$split = current.split('.'),
          numericPart = _current$split[0];

      var zeroPlaceholders = new Array(decimals$1 - 1).fill(0);
      var zeros = [].concat(zeroPlaceholders, [0]).join('');
      var minAmount = [].concat(zeroPlaceholders, [1]).join('');

      if (integerPartZero) {
        return "<" + numericPart + "." + minAmount;
      } else {
        return numericPart + "." + zeros;
      }
    }).valueOf();
    return formattedBalance;
  }).valueOf();
}

function nominate(input, customDenomination) {
  var balance = createBalanceBuilder(new Token$1({
    decimals: customDenomination || denomination,
    type: TokenType.Fungible
  }));
  return balance(input).toString();
}

var classnames = {};

try {
  classnames = require('classnames');
} catch (err) {}

var classnames$1 = classnames;

function getGeneratedClasses(className, shouldRenderDefaultCss, defaultStyles) {
  return Object.entries(defaultStyles).reduce(function (acc, _ref) {
    var key = _ref[0],
        defaultClassNames = _ref[1];
    acc[key] = classnames$1 === null || classnames$1 === void 0 ? void 0 : classnames$1(className + "_" + key, shouldRenderDefaultCss && defaultClassNames);
    return acc;
  }, {});
}

var wrapperClassName = 'dapp-core-ui-component';

var moment = {};

try {
  moment = require('moment');
} catch (err) {}

var moment$1 = moment;

var setItem = function setItem(_ref) {
  var key = _ref.key,
      data = _ref.data,
      expires = _ref.expires;
  sessionStorage.setItem(String(key), JSON.stringify({
    expires: expires,
    data: data
  }));
};
var getItem = function getItem(key) {
  var item = sessionStorage.getItem(String(key));

  if (!item) {
    return null;
  }

  var deserializedItem = JSON.parse(item);

  if (!deserializedItem) {
    return null;
  }

  if (!deserializedItem.hasOwnProperty('expires') || !deserializedItem.hasOwnProperty('data')) {
    return null;
  }

  var expired = moment$1().unix() >= deserializedItem.expires;

  if (expired) {
    sessionStorage.removeItem(String(key));
    return null;
  }

  return deserializedItem.data;
};
var removeItem = function removeItem(key) {
  return sessionStorage.removeItem(String(key));
};
var clear = function clear() {
  return sessionStorage.clear();
};
var storage = {
  setItem: setItem,
  getItem: getItem,
  removeItem: removeItem,
  clear: clear
};

var defaultContextValue = null;
var DappCoreContext = React__default.createContext(defaultContextValue);
var useStore = createStoreHook(DappCoreContext);
var useDispatch = createDispatchHook(DappCoreContext);
var useSelector = createSelectorHook(DappCoreContext);

var useExtensionLogin = function useExtensionLogin(_ref) {
  var initiateLogin = function initiateLogin() {
    try {
      setIsLoading(true);
      var provider = ExtensionProvider.getInstance();
      return Promise.resolve(_finallyRethrows(function () {
        return _catch(function () {
          return Promise.resolve(provider.init()).then(function (isSuccessfullyInitialized) {
            if (!isSuccessfullyInitialized) {
              console.warn('Something went wrong trying to redirect to wallet login..');
              return;
            }

            var callbackUrl = encodeURIComponent("" + window.location.origin + callbackRoute);

            var providerLoginData = _extends({
              callbackUrl: callbackUrl
            }, token && {
              token: token
            });

            return Promise.resolve(provider.login(providerLoginData)).then(function () {
              dispatch(setProvider(provider));
              var _provider$account = provider.account,
                  signature = _provider$account.signature,
                  address = _provider$account.address;

              if (signature) {
                dispatch(setTokenLogin({
                  loginToken: String(token),
                  signature: signature
                }));
              }

              dispatch(loginAction({
                address: address,
                loginMethod: LoginMethodsEnum.extension
              }));
              optionalRedirect(callbackRoute, redirectAfterLogin);
            });
          });
        }, function (error) {
          console.error('error loging in', error);
          setError('error logging in' + error.message);
        });
      }, function (_wasThrown, _result) {
        setIsLoading(false);
        if (_wasThrown) throw _result;
        return _result;
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var callbackRoute = _ref.callbackRoute,
      token = _ref.token,
      _ref$redirectAfterLog = _ref.redirectAfterLogin,
      redirectAfterLogin = _ref$redirectAfterLog === void 0 ? false : _ref$redirectAfterLog;

  var _useState = useState(''),
      error = _useState[0],
      setError = _useState[1];

  var _useState2 = useState(false),
      isLoading = _useState2[0],
      setIsLoading = _useState2[1];

  var isLoggedIn = useSelector(isLoggedInSelector);
  var dispatch = useDispatch();
  var loginFailed = Boolean(error);
  return [initiateLogin, {
    loginFailed: loginFailed,
    error: error,
    isLoading: isLoading && !loginFailed,
    isLoggedIn: isLoggedIn && !loginFailed
  }];
};

var useWebWalletLogin = function useWebWalletLogin(_ref) {
  var initiateLogin = function initiateLogin() {
    try {
      var _temp2 = _finallyRethrows(function () {
        return _catch(function () {
          setIsLoading(true);
          var appState = store.getState();
          var network = networkSelector(appState);
          var provider = newWalletProvider(network.walletAddress);
          var now = new Date();
          var expires = now.setMinutes(now.getMinutes() + 3) / 1000;
          var walletLoginData = {
            data: {},
            expires: expires
          };
          store.dispatch(setWalletLogin(walletLoginData));
          var callbackUrl = encodeURIComponent("" + window.location.origin + callbackRoute);

          var loginData = _extends({
            callbackUrl: callbackUrl
          }, token && {
            token: token
          });

          return Promise.resolve(provider.login(loginData)).then(function () {});
        }, function (error) {
          console.error(error);
          setError('error logging in' + error.message);
        });
      }, function (_wasThrown, _result) {
        setIsLoading(false);
        if (_wasThrown) throw _result;
        return _result;
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var callbackRoute = _ref.callbackRoute,
      token = _ref.token;

  var _useState = useState(''),
      error = _useState[0],
      setError = _useState[1];

  var _useState2 = useState(false),
      isLoading = _useState2[0],
      setIsLoading = _useState2[1];

  var isLoggedIn = useSelector(isLoggedInSelector);
  var loginFailed = error != null;
  return [initiateLogin, {
    error: error,
    loginFailed: loginFailed,
    isLoading: isLoading && !loginFailed,
    isLoggedIn: isLoggedIn && !loginFailed
  }];
};

var ledgerAppErrorText = 'Check if Elrond app is open on Ledger';
var failInitializeErrorText = 'Could not initialise ledger app, make sure Elrond app is open';
var defaultAddressesPerPage = 10;
function useLedgerLogin(_ref) {
  var onStartLogin = function onStartLogin() {
    try {
      setError('');
      return Promise.resolve(_finallyRethrows(function () {
        return _catch(function () {
          setIsLoading(true);
          return function () {
            if (ledgerAccount != null) {
              var _hwWalletP = new HWProvider(proxy);

              return Promise.resolve(_hwWalletP.init()).then(function (initialized) {
                if (!initialized) {
                  console.warn(failInitializeErrorText);
                  return;
                }

                return Promise.resolve(_hwWalletP.login()).then(function (address) {
                  dispatch(setProvider(_hwWalletP));
                  dispatch(loginAction({
                    address: address,
                    loginMethod: LoginMethodsEnum.ledger
                  }));
                  optionalRedirect(callbackRoute, redirectAfterLogin);
                });
              });
            } else {
              var _temp6 = function () {
                if ((accounts === null || accounts === void 0 ? void 0 : accounts.length) > 0) {
                  setShowAddressList(true);
                } else {
                  return Promise.resolve(fetchAccounts()).then(function () {
                    setShowAddressList(true);
                  });
                }
              }();

              if (_temp6 && _temp6.then) return _temp6.then(function () {});
            }
          }();
        }, function (error) {
          console.error('error ', error);
          setError(ledgerAppErrorText);
        });
      }, function (_wasThrown2, _result4) {
        setIsLoading(false);
        if (_wasThrown2) throw _result4;
        return _result4;
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var fetchAccounts = function fetchAccounts() {
    try {
      return Promise.resolve(_catch(function () {
        setIsLoading(true);
        return Promise.resolve(hwWalletP.init()).then(function (initialized) {
          if (!initialized) {
            setError(failInitializeErrorText);
            console.warn(failInitializeErrorText);
            setIsLoading(false);
            return;
          }

          return Promise.resolve(hwWalletP.getAccounts(startIndex, addressesPerPage)).then(function (accounts) {
            setAccounts(accounts);
            setIsLoading(false);
          });
        });
      }, function (err) {
        if (err.statusCode in ledgerErrorCodes$1) {
          setError(ledgerErrorCodes$1[err.statusCode].message);
        } else {
          setError(ledgerAppErrorText);
        }

        console.error('error', err);
        setIsLoading(false);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var onConfirmSelectedAddress = function onConfirmSelectedAddress() {
    try {
      var _temp3 = function _temp3(_result) {
        if (_exit2) return _result;
        setShowAddressList(false);
        return true;
      };

      var _exit2 = false;

      var _temp4 = _finallyRethrows(function () {
        return _catch(function () {
          setIsLoading(true);

          if (selectedAddress == null) {
            _exit2 = true;
            return false;
          }

          var address = selectedAddress.address,
              index = selectedAddress.index;
          dispatch(setLedgerAccount({
            index: index,
            address: address
          }));
          var hwWalletProvider = new HWProvider(proxy);
          return Promise.resolve(hwWalletProvider.init()).then(function (initialized) {
            if (!initialized) {
              setError(failInitializeErrorText);
              console.warn(failInitializeErrorText);
              _exit2 = true;
              return false;
            }

            setIsLoading(false);
            return Promise.resolve(loginUser(hwWalletProvider)).then(function () {});
          });
        }, function (err) {
          if (err.statusCode in ledgerErrorCodes$1) {
            setError(ledgerErrorCodes$1[err.statusCode].message);
          }

          console.warn(failInitializeErrorText, err);
        });
      }, function (_wasThrown, _result) {
        setIsLoading(false);
        if (_wasThrown) throw _result;
        return _result;
      });

      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var loginUser = function loginUser(hwWalletProvider) {
    try {
      var _exit4 = false;

      if (selectedAddress == null) {
        return Promise.resolve(false);
      }

      var index = selectedAddress.index;

      var _temp9 = function () {
        if (token) {
          var _temp10 = _catch(function () {
            return Promise.resolve(hwWalletProvider.tokenLogin({
              token: Buffer.from(token + "{}"),
              addressIndex: index
            })).then(function (loginInfo) {
              dispatchLoginActions({
                address: loginInfo.address,
                provider: hwWalletProvider,
                index: index,
                signature: loginInfo.signature.hex()
              });
            });
          }, function (err) {
            onLoginFailed(err, '. Update Elrond App to continue.');
          });

          if (_temp10 && _temp10.then) return _temp10.then(function () {});
        } else {
          return _catch(function () {
            return Promise.resolve(hwWalletProvider.login({
              addressIndex: index
            })).then(function (address) {
              dispatchLoginActions({
                address: address,
                provider: hwWalletProvider,
                index: index
              });
            });
          }, function (err) {
            onLoginFailed(err);
            _exit4 = true;
            return false;
          });
        }
      }();

      return Promise.resolve(_temp9 && _temp9.then ? _temp9.then(function (_result5) {
        return _exit4 ? _result5 : true;
      }) : _exit4 ? _temp9 : true);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var callbackRoute = _ref.callbackRoute,
      token = _ref.token,
      _ref$addressesPerPage = _ref.addressesPerPage,
      addressesPerPage = _ref$addressesPerPage === void 0 ? defaultAddressesPerPage : _ref$addressesPerPage,
      _ref$redirectAfterLog = _ref.redirectAfterLogin,
      redirectAfterLogin = _ref$redirectAfterLog === void 0 ? false : _ref$redirectAfterLog;
  var ledgerAccount = useSelector(ledgerAccountSelector);
  var isLoggedIn = useSelector(isLoggedInSelector);
  var proxy = useSelector(proxySelector);
  var dispatch = useDispatch();

  var _React$useState = React__default.useState(''),
      error = _React$useState[0],
      setError = _React$useState[1];

  var _React$useState2 = React__default.useState(false),
      isLoading = _React$useState2[0],
      setIsLoading = _React$useState2[1];

  var hwWalletP = new HWProvider(proxy);

  var _React$useState3 = React__default.useState(0),
      startIndex = _React$useState3[0],
      setStartIndex = _React$useState3[1];

  var _React$useState4 = React__default.useState([]),
      accounts = _React$useState4[0],
      setAccounts = _React$useState4[1];

  var _React$useState5 = React__default.useState(null),
      selectedAddress = _React$useState5[0],
      setSelectedAddress = _React$useState5[1];

  var _React$useState6 = React__default.useState(false),
      showAddressList = _React$useState6[0],
      setShowAddressList = _React$useState6[1];

  function dispatchLoginActions(_ref2) {
    var provider = _ref2.provider,
        address = _ref2.address,
        index = _ref2.index,
        signature = _ref2.signature;
    dispatch(setProvider(provider));
    dispatch(setLedgerLogin({
      index: index,
      loginType: LoginMethodsEnum.ledger
    }));

    if (signature) {
      dispatch(setTokenLogin({
        loginToken: String(token),
        signature: signature
      }));
    }

    dispatch(loginAction({
      address: address,
      loginMethod: LoginMethodsEnum.ledger
    }));
    optionalRedirect(callbackRoute, redirectAfterLogin);
  }

  var onLoginFailed = function onLoginFailed(err, customMessage) {
    if (err.statusCode in ledgerErrorCodes$1) {
      setError(ledgerErrorCodes$1[err.statusCode].message + customMessage);
    }

    setIsLoading(false);
    console.warn(err);
    dispatch(setLedgerAccount(null));
  };

  function onSelectAddress(newSelectedAddress) {
    setSelectedAddress(newSelectedAddress);
  }

  function onGoToNextPage() {
    setSelectedAddress(null);
    setStartIndex(function (current) {
      return current + 1;
    });
  }

  function onGoToPrevPage() {
    setSelectedAddress(null);
    setStartIndex(function (current) {
      return current === 0 ? 0 : current - 1;
    });
  }

  React__default.useEffect(function () {
    fetchAccounts();
  }, [startIndex]);
  var loginFailed = Boolean(error);
  return [onStartLogin, {
    loginFailed: loginFailed,
    isLoggedIn: isLoggedIn && !loginFailed,
    error: error,
    isLoading: isLoading && !loginFailed
  }, {
    accounts: accounts,
    showAddressList: showAddressList,
    startIndex: startIndex,
    selectedAddress: selectedAddress,
    onGoToPrevPage: onGoToPrevPage,
    onGoToNextPage: onGoToNextPage,
    onSelectAddress: onSelectAddress,
    onConfirmSelectedAddress: onConfirmSelectedAddress
  }];
}

function useUpdateEffect(effect, dependencies) {
  if (dependencies === void 0) {
    dependencies = [];
  }

  var isInitialMount = useRef(true);
  useEffect(function () {
    if (isInitialMount.current) {
      isInitialMount.current = false;
    } else {
      effect();
    }
  }, dependencies);
}

var useWalletConnectLogin = function useWalletConnectLogin(_ref) {
  var generateWcUri = function generateWcUri() {
    try {
      var _providerRef$current2;

      if (!walletConnectBridgeAddress) {
        return Promise.resolve();
      }

      return Promise.resolve((_providerRef$current2 = providerRef.current) === null || _providerRef$current2 === void 0 ? void 0 : _providerRef$current2.login()).then(function (walletConnectUri) {
        var hasUri = Boolean(walletConnectUri);

        if (!hasUri) {
          return;
        }

        if (!token) {
          setWcUri(walletConnectUri);
          return;
        }

        var wcUriWithToken = walletConnectUri + "&token=" + token;
        setWcUri(wcUriWithToken);
        dispatch(setTokenLogin({
          loginToken: token
        }));
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var initiateLogin = function initiateLogin(loginProvider) {
    if (loginProvider === void 0) {
      loginProvider = true;
    }

    try {
      var _providerRef$current, _providerRef$current$;

      if (!walletConnectBridgeAddress || providerRef !== null && providerRef !== void 0 && (_providerRef$current = providerRef.current) !== null && _providerRef$current !== void 0 && (_providerRef$current$ = _providerRef$current.isInitialized) !== null && _providerRef$current$ !== void 0 && _providerRef$current$.call(_providerRef$current)) {
        return Promise.resolve();
      }

      var providerHandlers = {
        onClientLogin: handleOnLogin,
        onClientLogout: handleOnLogout
      };
      var newProvider = new WalletConnectProvider(proxy, walletConnectBridgeAddress, providerHandlers);
      return Promise.resolve(newProvider.init()).then(function () {
        dispatch(setProvider(newProvider));
        providerRef.current = newProvider;

        if (loginProvider) {
          generateWcUri();
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var handleOnLogin = function handleOnLogin() {
    try {
      return Promise.resolve(_catch(function () {
        var provider = providerRef.current;

        if (isLoggedIn) {
          return;
        }

        if (provider == null) {
          return;
        }

        return Promise.resolve(provider.getAddress()).then(function (address) {
          return Promise.resolve(provider.getSignature()).then(function (signature) {
            var hasSignature = Boolean(signature);
            var loginActionData = {
              address: address,
              loginMethod: LoginMethodsEnum.walletconnect
            };
            var loginData = {
              logoutRoute: logoutRoute,
              loginType: 'walletConnect',
              callbackRoute: callbackRoute
            };

            if (hasSignature) {
              dispatch(setWalletConnectLogin(loginData));
              dispatch(setTokenLoginSignature(signature));
            } else {
              dispatch(setWalletConnectLogin(loginData));
            }

            dispatch(loginAction(loginActionData));
            provider.walletConnector.on('heartbeat', function () {
              clearInterval(heartbeatDisconnectInterval);
              heartbeatDisconnectInterval = setInterval(function () {
                console.log('Maiar Wallet Connection Lost');
                handleOnLogout();
                clearInterval(heartbeatDisconnectInterval);
              }, 150000);
            });
            optionalRedirect(callbackRoute, redirectAfterLogin);
          });
        });
      }, function (err) {
        setError('Invalid address');
        console.error(err);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var handleHeartbeat = function handleHeartbeat() {
    try {
      var _providerRef$current3, _providerRef$current4;

      var isProviderConnected = Boolean((_providerRef$current3 = providerRef.current) === null || _providerRef$current3 === void 0 ? void 0 : (_providerRef$current4 = _providerRef$current3.walletConnector) === null || _providerRef$current4 === void 0 ? void 0 : _providerRef$current4.connected);

      if (!isProviderConnected) {
        return Promise.resolve();
      }

      var customMessage = {
        method: 'heartbeat',
        params: {}
      };

      var _temp2 = _catch(function () {
        return Promise.resolve(providerRef.current.sendCustomMessage(customMessage)).then(function () {});
      }, function (error) {
        console.error('Connection lost', error);
        handleOnLogout();
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var callbackRoute = _ref.callbackRoute,
      logoutRoute = _ref.logoutRoute,
      token = _ref.token,
      _ref$redirectAfterLog = _ref.redirectAfterLogin,
      redirectAfterLogin = _ref$redirectAfterLog === void 0 ? false : _ref$redirectAfterLog;
  var dispatch = useDispatch();
  var heartbeatInterval = 15000;

  var _useState = useState(''),
      error = _useState[0],
      setError = _useState[1];

  var _useState2 = useState(''),
      wcUri = _useState2[0],
      setWcUri = _useState2[1];

  var proxy = useSelector(proxySelector);
  var provider = useSelector(providerSelector);
  var walletConnectBridgeAddress = useSelector(walletConnectBridgeAddressSelector);
  var walletConnectDeepLink = useSelector(walletConnectDeepLinkSelector);
  var isLoggedIn = useSelector(isLoggedInSelector);
  var providerRef = useRef(provider);
  var heartbeatDisconnectInterval;
  var hasWcUri = Boolean(wcUri);
  var isLoading = !hasWcUri;
  var uriDeepLink = hasWcUri ? walletConnectDeepLink + "?wallet-connect=" + encodeURIComponent(wcUri) : null;
  useEffect(function () {
    handleHeartbeat();
    var interval = setInterval(function () {
      handleHeartbeat();
    }, heartbeatInterval);
    return function () {
      return clearInterval(interval);
    };
  }, [provider]);
  useUpdateEffect(function () {
    generateWcUri();
  }, [token]);
  useUpdateEffect(function () {
    providerRef.current = provider;
  }, [provider]);

  var handleOnLogout = function handleOnLogout() {
    logout(callbackRoute);
  };

  var loginFailed = error != null;
  return [initiateLogin, {
    error: error,
    loginFailed: loginFailed,
    isLoading: isLoading && !loginFailed,
    isLoggedIn: isLoggedIn && !loginFailed
  }, {
    uriDeepLink: uriDeepLink,
    walletConnectUri: wcUri
  }];
};



var index = {
  __proto__: null,
  useExtensionLogin: useExtensionLogin,
  useWebWalletLogin: useWebWalletLogin,
  useLedgerLogin: useLedgerLogin,
  useWalletConnectLogin: useWalletConnectLogin
};

function calcTotalFee(transactions, minGasLimit) {
  var totalFee = new BigNumber(0);
  transactions.forEach(function (tx) {
    var fee = operations.calculateFeeLimit({
      gasPerDataByte: gasPerDataByte,
      gasPriceModifier: gasPriceModifier,
      minGasLimit: String(minGasLimit),
      gasLimit: tx.getGasLimit().valueOf().toString(),
      gasPrice: tx.getGasPrice().valueOf().toString(),
      data: tx.getData().toString(),
      chainId: tx.getChainID().valueOf()
    });
    totalFee = totalFee.plus(new BigNumber(fee));
  });
  return totalFee;
}

function signTransactions(_ref) {
  var transactions = _ref.transactions,
      _ref$callbackRoute = _ref.callbackRoute,
      callbackRoute = _ref$callbackRoute === void 0 ? window.location.pathname : _ref$callbackRoute,
      _ref$redirectAfterSig = _ref.redirectAfterSign,
      redirectAfterSign = _ref$redirectAfterSig === void 0 ? true : _ref$redirectAfterSig,
      sessionInformation = _ref.sessionInformation,
      _ref$minGasLimit = _ref.minGasLimit,
      minGasLimit = _ref$minGasLimit === void 0 ? DEFAULT_MIN_GAS_LIMIT : _ref$minGasLimit,
      transactionsDisplayInfo = _ref.transactionsDisplayInfo;
  var appState = store.getState();
  var sessionId = Date.now().toString();
  var accountBalance = accountBalanceSelector(appState);
  var storeChainId = chainIDSelector(appState);
  var transactionsPayload = Array.isArray(transactions) ? transactions : [transactions];
  var bNtotalFee = calcTotalFee(transactionsPayload, minGasLimit);
  var bNbalance = new BigNumber(validation.stringIsFloat(accountBalance) ? accountBalance : '0');
  var hasSufficientFunds = bNbalance.minus(bNtotalFee).isGreaterThan(0);

  if (!hasSufficientFunds) {
    var notificationPayload = {
      type: NotificationTypesEnum.warning,
      iconClassName: 'text-warning',
      title: 'Insufficient EGLD funds',
      description: 'Current EGLD balance cannot cover the transaction fees.'
    };
    store.dispatch(setNotificationModal(notificationPayload));
    return {
      error: 'insufficient funds',
      sessionId: null
    };
  }

  var hasValidChainId = transactionsPayload === null || transactionsPayload === void 0 ? void 0 : transactionsPayload.every(function (tx) {
    return tx.getChainID().valueOf() === storeChainId.valueOf();
  });

  if (!hasValidChainId) {
    var _notificationPayload = {
      type: NotificationTypesEnum.warning,
      iconClassName: 'text-warning',
      title: 'Network change detected',
      description: 'The application tried to change the transaction network'
    };
    store.dispatch(setNotificationModal(_notificationPayload));
    return {
      error: 'Invalid ChainID',
      sessionId: null
    };
  }

  var signTransactionsPayload = {
    sessionId: sessionId,
    callbackRoute: callbackRoute,
    redirectAfterSign: redirectAfterSign,
    sessionInformation: sessionInformation,
    transactions: transactionsPayload.map(function (tx) {
      return tx.toPlainObject();
    })
  };
  store.dispatch(setTransactionsToSign(signTransactionsPayload));
  store.dispatch(setTransactionsDisplayInfo({
    sessionId: sessionId,
    transactionsDisplayInfo: transactionsDisplayInfo
  }));
  return {
    sessionId: sessionId
  };
}

var transformAndSignTransactions = function transformAndSignTransactions(_ref) {
  var transactions = _ref.transactions;

  try {
    var address = addressSelector(store.getState());
    return Promise.resolve(getAccount(address)).then(function (account) {
      var nonce = getLatestNonce(account);
      return transactions.map(function (tx) {
        var value = tx.value,
            receiver = tx.receiver,
            _tx$data = tx.data,
            data = _tx$data === void 0 ? '' : _tx$data,
            chainID = tx.chainID,
            version = tx.version,
            options = tx.options,
            _tx$gasPrice = tx.gasPrice,
            gasPrice = _tx$gasPrice === void 0 ? defaultGasPrice : _tx$gasPrice,
            _tx$gasLimit = tx.gasLimit,
            gasLimit = _tx$gasLimit === void 0 ? defaultGasLimit : _tx$gasLimit;
        var validatedReceiver = receiver;

        try {
          var addr = new Address$1(receiver);
          validatedReceiver = addr.hex();
        } catch (err) {
          throw ErrorCodesEnum.invalidReceiver;
        }

        var storeChainId = chainIDSelector(store.getState()).valueOf().toString();
        var transactionsChainId = chainID || storeChainId;
        return newTransaction({
          value: value,
          receiver: validatedReceiver,
          data: isStringBase64(data) ? data : encodeToBase64(data),
          gasPrice: gasPrice,
          gasLimit: gasLimit,
          nonce: Number(nonce.valueOf().toString()),
          sender: new Address$1(address).hex(),
          chainID: transactionsChainId,
          version: version,
          options: options
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var ErrorCodesEnum;

(function (ErrorCodesEnum) {
  ErrorCodesEnum["invalidReceiver"] = "Invalid Receiver address";
  ErrorCodesEnum["unknownError"] = "Unknown Error. Please check the transactions and try again";
})(ErrorCodesEnum || (ErrorCodesEnum = {}));

var sendTransactions = function sendTransactions(_ref) {
  var transactions = _ref.transactions,
      transactionsDisplayInfo = _ref.transactionsDisplayInfo,
      _ref$redirectAfterSig = _ref.redirectAfterSign,
      redirectAfterSign = _ref$redirectAfterSig === void 0 ? true : _ref$redirectAfterSig,
      sessionInformation = _ref.sessionInformation,
      minGasLimit = _ref.minGasLimit;

  try {
    return Promise.resolve(_catch(function () {
      function _temp2() {
        return signTransactions({
          transactions: txToSign,
          minGasLimit: minGasLimit,
          redirectAfterSign: redirectAfterSign,
          sessionInformation: sessionInformation,
          transactionsDisplayInfo: transactionsDisplayInfo
        });
      }

      var transactionsPayload = Array.isArray(transactions) ? transactions : [transactions];
      var areComplexTransactions = transactionsPayload.every(function (tx) {
        return Object.getPrototypeOf(tx).toPlainObject != null;
      });
      var txToSign = transactionsPayload;

      var _temp = function () {
        if (!areComplexTransactions) {
          return Promise.resolve(transformAndSignTransactions({
            transactions: transactionsPayload,
            minGasLimit: minGasLimit
          })).then(function (_transformAndSignTran) {
            txToSign = _transformAndSignTran;
          });
        }
      }();

      return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
    }, function (err) {
      console.error('error signing transaction', err);
      return {
        error: err,
        sessionId: null
      };
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

function useTrackTransactionStatus(_ref) {
  var transactionId = _ref.transactionId,
      onSuccess = _ref.onSuccess,
      onFail = _ref.onFail,
      onCancelled = _ref.onCancelled,
      onTimedOut = _ref.onTimedOut,
      onCompleted = _ref.onCompleted;
  var transactionsBatch = useSelector(function (state) {
    return transactionStatusSelector(state, transactionId);
  });
  var status = transactionsBatch.status,
      transactions = transactionsBatch.transactions,
      errorMessage = transactionsBatch.errorMessage;
  var isPending = getIsTransactionPending(status);
  var isFailed = getIsTransactionFailed(status);
  var isTimedOut = getIsTransactionTimedOut(status);
  var isSuccessful = getIsTransactionSuccessful(status);
  var isCompleted = getIsTransactionCompleted(status);
  var isCancelled = status === TransactionBatchStatusesEnum.cancelled;
  useEffect(function () {
    if (isSuccessful && onSuccess) {
      onSuccess(transactionId);
    }
  }, [isSuccessful]);
  useEffect(function () {
    if (isCompleted && onCompleted) {
      onCompleted(transactionId);
    }
  }, [isCompleted]);
  useEffect(function () {
    if (isFailed && onFail) {
      onFail(transactionId, errorMessage);
    }
  }, [isFailed]);
  useEffect(function () {
    if (isCancelled && onCancelled) {
      onCancelled(transactionId);
    }
  }, [isCancelled]);
  useEffect(function () {
    if (isTimedOut) {
      if (onTimedOut) {
        onTimedOut(transactionId);
      } else {
        onFail === null || onFail === void 0 ? void 0 : onFail(transactionId, 'timeout');
      }
    }
  }, [isTimedOut]);

  if (transactionId == null) {
    return {};
  }

  if (transactionsBatch == null) {
    return {
      errorMessage: 'No transaction to track'
    };
  }

  return {
    isPending: isPending,
    isSuccessful: isSuccessful,
    isFailed: isFailed,
    isCancelled: isCancelled,
    isCompleted: isCompleted,
    errorMessage: errorMessage,
    status: status,
    transactions: transactions
  };
}

function useGetPendingTransactions() {
  var pendingTransactions = useSelector(pendingSignedTransactionsSelector);
  var pendingTransactionsArray = Object.entries(pendingTransactions);
  var hasPendingTransactions = (pendingTransactionsArray === null || pendingTransactionsArray === void 0 ? void 0 : pendingTransactionsArray.length) > 0;
  return {
    pendingTransactions: pendingTransactions,
    pendingTransactionsArray: pendingTransactionsArray,
    hasPendingTransactions: hasPendingTransactions
  };
}

function useGetFailedTransactions() {
  var failedTransactions = useSelector(failedTransactionsSelector);
  var failedTransactionsArray = Object.entries(failedTransactions);
  var hasFailedTransactions = (failedTransactionsArray === null || failedTransactionsArray === void 0 ? void 0 : failedTransactionsArray.length) > 0;
  return {
    failedTransactions: failedTransactions,
    failedTransactionsArray: failedTransactionsArray,
    hasFailedTransactions: hasFailedTransactions
  };
}

function useGetSuccessfulTransactions() {
  var successfulTransactions = useSelector(successfulTransactionsSelector);
  var successfulTransactionsArray = Object.entries(successfulTransactions);
  var hasSuccessfulTransactions = (successfulTransactionsArray === null || successfulTransactionsArray === void 0 ? void 0 : successfulTransactionsArray.length) > 0;
  return {
    successfulTransactions: successfulTransactions,
    successfulTransactionsArray: successfulTransactionsArray,
    hasSuccessfulTransactions: hasSuccessfulTransactions
  };
}

var defaultTransactionInfo$1 = {
  tokenId: '',
  amount: '',
  type: '',
  multiTxData: '',
  receiver: ''
};
function useParseMultiEsdtTransferData(_ref) {
  var transactions = _ref.transactions;

  var _useState = useState({}),
      parsedTransactionsByDataField = _useState[0],
      setParsedTransactions = _useState[1];

  var _useState2 = useState([]),
      allTransactions = _useState2[0],
      setAllTransactions = _useState2[1];

  function addTransactionDataToParsedInfo(data, txInfo) {
    setParsedTransactions(function (existing) {
      var _extends2;

      return _extends({}, existing, (_extends2 = {}, _extends2[data] = txInfo, _extends2));
    });
  }

  function getTxInfoByDataField(data, multiTransactionData) {
    if (parsedTransactionsByDataField == null) {
      return defaultTransactionInfo$1;
    }

    if (data in parsedTransactionsByDataField) {
      return parsedTransactionsByDataField[data];
    }

    if (multiTransactionData != null && String(multiTransactionData) in parsedTransactionsByDataField) {
      return parsedTransactionsByDataField[multiTransactionData];
    }

    return defaultTransactionInfo$1;
  }

  function extractTransactionESDTData() {
    if (transactions && transactions.length > 0) {
      var _allTransactions = [];
      transactions.forEach(function (transaction, transactionIndex) {
        var multiTxs = parseMultiEsdtTransferData(transaction.getData().toString());

        if (multiTxs.length > 0) {
          multiTxs.forEach(function (trx, idx) {
            var newTx = {
              transaction: transaction,
              multiTxData: trx.data,
              transactionIndex: idx
            };
            addTransactionDataToParsedInfo(trx.data, {
              tokenId: trx.token ? trx.token : '',
              amount: trx.amount ? trx.amount : '',
              type: trx.type,
              nonce: trx.nonce ? trx.nonce : '',
              multiTxData: trx.data,
              receiver: trx.receiver
            });

            _allTransactions.push(newTx);
          });
        } else {
          var _getTokenFromData = getTokenFromData(transaction.getData().toString()),
              tokenId = _getTokenFromData.tokenId,
              amount = _getTokenFromData.amount;

          if (tokenId) {
            addTransactionDataToParsedInfo(transaction.getData().toString(), {
              tokenId: tokenId,
              amount: amount,
              receiver: transaction.getReceiver().bech32()
            });
          }

          _allTransactions.push({
            transaction: transaction,
            transactionIndex: transactionIndex
          });
        }
      });
      setAllTransactions(_allTransactions);
    }
  }

  useEffect(function () {
    extractTransactionESDTData();
  }, [transactions]);
  return {
    parsedTransactionsByDataField: parsedTransactionsByDataField,
    getTxInfoByDataField: getTxInfoByDataField,
    allTransactions: allTransactions
  };
}

function useGetActiveTransactionsStatus() {
  var _Object$keys, _Object$keys2, _Object$keys3;

  var signedTransactions = useSelector(signedTransactionsSelector);
  var timedOutTransactions = useSelector(timedOutTransactionsSelector);
  var failedTransactions = useSelector(failedTransactionsSelector);
  var successfulTransactions = useSelector(successfulTransactionsSelector);
  var pendingTransactions = useSelector(pendingSignedTransactionsSelector);
  var completedTransactions = useSelector(completedTransactionsSelector);
  var pending = ((_Object$keys = Object.keys(pendingTransactions)) === null || _Object$keys === void 0 ? void 0 : _Object$keys.length) > 0;
  var timedOut = !pending && ((_Object$keys2 = Object.keys(timedOutTransactions)) === null || _Object$keys2 === void 0 ? void 0 : _Object$keys2.length) > 0;
  var fail = !pending && !timedOut && ((_Object$keys3 = Object.keys(failedTransactions)) === null || _Object$keys3 === void 0 ? void 0 : _Object$keys3.length) > 0;
  var success = !pending && !timedOut && !fail && Object.keys(successfulTransactions).length > 0;
  var completed = !pending && !timedOut && !fail && Object.keys(completedTransactions).length > 0;
  var hasActiveTransactions = Object.keys(signedTransactions).length > 0;
  return {
    pending: pending,
    timedOut: timedOut,
    fail: fail,
    success: success,
    completed: completed,
    hasActiveTransactions: hasActiveTransactions
  };
}

function useGetCompletedTransactions() {
  var completedTransactions = useSelector(completedTransactionsSelector);
  var completedTransactionsArray = Object.entries(completedTransactions);
  var hasCompletedTransactions = (completedTransactionsArray === null || completedTransactionsArray === void 0 ? void 0 : completedTransactionsArray.length) > 0;
  return {
    completedTransactions: completedTransactions,
    completedTransactionsArray: completedTransactionsArray,
    hasCompletedTransactions: hasCompletedTransactions
  };
}



var index$1 = {
  __proto__: null,
  sendTransactions: sendTransactions,
  signTransactions: signTransactions,
  useTrackTransactionStatus: useTrackTransactionStatus,
  useGetPendingTransactions: useGetPendingTransactions,
  useGetFailedTransactions: useGetFailedTransactions,
  useGetSuccessfulTransactions: useGetSuccessfulTransactions,
  useParseMultiEsdtTransferData: useParseMultiEsdtTransferData,
  useGetActiveTransactionsStatus: useGetActiveTransactionsStatus,
  useGetCompletedTransactions: useGetCompletedTransactions
};

var sendSignedTransactions = function sendSignedTransactions(signedTransactions) {
  try {
    var proxy = proxySelector(store.getState());
    var promises = signedTransactions.map(function (transaction) {
      return proxy.sendTransaction(transaction);
    });
    return Promise.resolve(Promise.all(promises)).then(function (response) {
      return response.map(function (txHash) {
        return Buffer.from(txHash.hash).toString('hex');
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

var getTransactionsByHashes = function getTransactionsByHashes(pendingTransactions) {
  try {
    var networkConfig = networkConfigSelector(store.getState());
    var hashes = pendingTransactions.map(function (tx) {
      return tx.hash;
    });
    return Promise.resolve(axios.get(networkConfig.network.apiAddress + "/transactions", {
      params: {
        hashes: hashes.join(','),
        withScResults: true
      }
    })).then(function (_ref) {
      var responseData = _ref.data;
      return pendingTransactions.map(function (_ref2) {
        var hash = _ref2.hash,
            previousStatus = _ref2.previousStatus;
        var txOnNetwork = responseData.find(function (txResponse) {
          return txResponse.txHash === hash;
        });
        var data = txOnNetwork === null || txOnNetwork === void 0 ? void 0 : txOnNetwork.data;

        try {
          data = decodeBase64(data);
        } catch (err) {}

        return {
          hash: hash,
          data: data,
          invalidTransaction: txOnNetwork == null,
          status: txOnNetwork.status,
          results: txOnNetwork.results,
          receiver: txOnNetwork === null || txOnNetwork === void 0 ? void 0 : txOnNetwork.receiver,
          previousStatus: previousStatus,
          hasStatusChanged: status !== previousStatus
        };
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};

function ProviderInitializer() {
  var setExtensionProvider = function setExtensionProvider() {
    try {
      var _temp11 = _catch(function () {
        return Promise.resolve(getAddress()).then(function (address) {
          var provider = ExtensionProvider.getInstance().setAddress(address);
          return Promise.resolve(provider.init()).then(function (success) {
            if (success) {
              dispatch(setProvider(provider));
            } else {
              console.error('Could not initialise extension, make sure Elrond wallet extension is installed.');
            }
          });
        });
      }, function (err) {
        console.error('Unable to login to ExtensionProvider', err);
      });

      return Promise.resolve(_temp11 && _temp11.then ? _temp11.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var tryAuthenticateWalletUser = function tryAuthenticateWalletUser() {
    try {
      return Promise.resolve(_catch(function () {
        var _temp9 = function () {
          if (walletLogin != null) {
            var provider = newWalletProvider(network.walletAddress);
            return Promise.resolve(getAddress()).then(function (address) {
              function _temp8() {
                dispatch(setWalletLogin(null));
              }

              var _temp7 = function () {
                if (address) {
                  dispatch(setProvider(provider));
                  dispatch(loginAction({
                    address: address,
                    loginMethod: LoginMethodsEnum.wallet
                  }));
                  return Promise.resolve(getAccount(address)).then(function (account) {
                    dispatch(setAccount({
                      balance: account.balance.toString(),
                      address: address,
                      nonce: getLatestNonce(account)
                    }));
                  });
                }
              }();

              return _temp7 && _temp7.then ? _temp7.then(_temp8) : _temp8(_temp7);
            });
          }
        }();

        if (_temp9 && _temp9.then) return _temp9.then(function () {});
      }, function (e) {
        console.error('Failed authenticating wallet user ', e);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var fetchAccount = function fetchAccount() {
    try {
      var _temp4 = function _temp4() {
        dispatch(setIsAccountLoading(false));
      };

      dispatch(setIsAccountLoading(true));

      var _temp5 = function () {
        if (address && isLoggedIn) {
          var _temp6 = _catch(function () {
            return Promise.resolve(getAccount(address)).then(function (account) {
              dispatch(setAccount({
                balance: account.balance.toString(),
                address: address,
                nonce: account.nonce.valueOf()
              }));

              if (ledgerAccount == null && ledgerLogin != null) {
                dispatch(setLedgerAccount({
                  index: ledgerLogin.index,
                  address: address
                }));
              }
            });
          }, function (e) {
            dispatch(setAccountLoadingError('Failed getting account'));
            console.error('Failed getting account ', e);
          });

          if (_temp6 && _temp6.then) return _temp6.then(function () {});
        }
      }();

      return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp4) : _temp4(_temp5));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var network = useSelector(networkSelector);
  var walletConnectLogin = useSelector(walletConnectLoginSelector);
  var loginMethod = useSelector(loginMethodSelector);
  var walletLogin = useSelector(walletLoginSelector);

  var _useSelector = useSelector(extraActionsSelector),
      getProvider = _useSelector.getProvider;

  var address = useSelector(addressSelector);
  var ledgerAccount = useSelector(ledgerAccountSelector);
  var ledgerLogin = useSelector(ledgerLoginSelector);
  var isLoggedIn = useSelector(isLoggedInSelector);
  var proxy = useSelector(proxySelector);
  var dispatch = useDispatch();

  var _ref = walletConnectLogin ? walletConnectLogin : {
    callbackRoute: '',
    logoutRoute: ''
  },
      callbackRoute = _ref.callbackRoute,
      logoutRoute = _ref.logoutRoute;

  var _useWalletConnectLogi = useWalletConnectLogin({
    callbackRoute: callbackRoute,
    logoutRoute: logoutRoute
  }),
      initWalletLoginProvider = _useWalletConnectLogi[0];

  useEffect(function () {
    refreshChainID();
  }, [network]);
  useEffect(function () {
    initializeProvider();
  }, [loginMethod]);
  useEffect(function () {
    fetchAccount();
  }, [address, ledgerLogin, isLoggedIn]);

  function refreshChainID() {
    proxy.getNetworkConfig().then(function (networkConfig) {
      dispatch(setChainID(networkConfig.ChainID.valueOf()));
    })["catch"](function (e) {
      console.error('To do ', e);
    });
  }

  function setLedgerProvider() {
    var hwWalletP = new HWProvider(proxy);
    hwWalletP.init().then(function (success) {
      if (!success) {
        console.warn('Could not initialise ledger app');
        logout();
        return;
      }

      dispatch(setProvider(hwWalletP));
    })["catch"](function (err) {
      console.error('Could not initialise ledger app', err);
      logout();
    });
  }

  function initializeProvider() {
    if (loginMethod == null) {
      return;
    }

    switch (loginMethod) {
      case LoginMethodsEnum.ledger:
        {
          setLedgerProvider();
          break;
        }

      case LoginMethodsEnum.walletconnect:
        {
          initWalletLoginProvider(false);
          break;
        }

      case LoginMethodsEnum.wallet:
        {
          var provider = newWalletProvider(network.walletAddress);
          dispatch(setProvider(provider));
          break;
        }

      case LoginMethodsEnum.extension:
        {
          setExtensionProvider();
          break;
        }

      case LoginMethodsEnum.extra:
        {
          var _provider = getProvider();

          dispatch(setProvider(_provider));
          break;
        }

      case LoginMethodsEnum.none:
        {
          tryAuthenticateWalletUser();
          break;
        }

      default:
        return;
    }
  }

  return null;
}

var defaultValue = {
  sendSignedTransactionsAsync: sendSignedTransactions,
  getTransactionsByHash: getTransactionsByHashes,
  completedTransactionsDelay: 0
};
var OverrideDefaultBehaviourContext = React__default.createContext(defaultValue);

var TransactionSender = function TransactionSender() {
  var handleSendTransactions = function handleSendTransactions() {
    try {
      var sessionIds = Object.keys(signedTransactions);
      return Promise.resolve(_forOf(sessionIds, function (sessionId) {
        if (!sessionId) {
          return;
        }

        var _temp = _finallyRethrows(function () {
          return _catch(function () {
            var isSessionIdSigned = signedTransactions[sessionId].status === TransactionBatchStatusesEnum.signed;
            var shouldSendCurrentSession = isSessionIdSigned && !sendingRef.current;

            if (!shouldSendCurrentSession) {
              return;
            }

            var transactions = signedTransactions[sessionId].transactions;

            if (!transactions) {
              return;
            }

            sendingRef.current = true;
            var transactionsToSend = transactions.map(function (tx) {
              var address = new Address(tx.sender);
              var transactionObject = newTransaction(tx);
              var signature = new Signature(tx.signature);
              transactionObject.applySignature(signature, address);
              return transactionObject;
            });
            return Promise.resolve(sendSignedTransactionsAsync(transactionsToSend)).then(function (responseHashes) {
              var newStatus = TransactionServerStatusesEnum.pending;
              var newTransactions = transactions.map(function (transaction) {
                if (responseHashes.includes(transaction.hash)) {
                  return _extends({}, transaction, {
                    status: newStatus
                  });
                }

                return transaction;
              });
              var submittedModalPayload = {
                sessionId: sessionId,
                submittedMessage: 'submitted'
              };
              dispatch(setTxSubmittedModal(submittedModalPayload));
              dispatch(updateSignedTransactions({
                sessionId: sessionId,
                status: TransactionBatchStatusesEnum.sent,
                transactions: newTransactions
              }));
              clearSignInfo();
              setNonce(account.nonce + transactions.length);
              history.pushState({}, document.title, '?');
            });
          }, function (error) {
            console.error('Unable to send transactions', error);
            dispatch(updateSignedTransactions({
              sessionId: sessionId,
              status: TransactionBatchStatusesEnum.fail,
              errorMessage: error.message
            }));
            clearSignInfo();
          });
        }, function (_wasThrown, _result) {
          sendingRef.current = false;
          if (_wasThrown) throw _result;
          return _result;
        });

        if (_temp && _temp.then) return _temp.then(function () {});
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var account = useSelector(accountSelector);
  var signedTransactions = useSelector(signedTransactionsSelector);

  var _useContext = useContext(OverrideDefaultBehaviourContext),
      sendSignedTransactionsAsync = _useContext.sendSignedTransactionsAsync;

  var sendingRef = useRef(false);
  var dispatch = useDispatch();

  var clearSignInfo = function clearSignInfo() {
    dispatch(clearSignTransactions());
    sendingRef.current = false;
  };

  React__default.useEffect(function () {
    handleSendTransactions();
  }, [signedTransactions, account]);
  return null;
};

function TransactionStatusTracker(_ref) {
  var sessionId = _ref.sessionId,
      _ref$transactionPaylo = _ref.transactionPayload,
      transactions = _ref$transactionPaylo.transactions,
      status = _ref$transactionPaylo.status;
  var dispatch = useDispatch();
  var intervalRef = useRef(null);
  var isFetchingStatusRef = useRef(false);
  var retriesRef = useRef({});
  var timeoutRefs = useRef([]);

  var _useContext = useContext(OverrideDefaultBehaviourContext),
      getTransactionsByHash = _useContext.getTransactionsByHash,
      completedTransactionsDelay = _useContext.completedTransactionsDelay;

  var isPending = sessionId != null && getIsTransactionPending(status);

  var manageTimedOutTransactions = function manageTimedOutTransactions() {
    dispatch(updateSignedTransactions({
      sessionId: sessionId,
      status: TransactionBatchStatusesEnum.timedOut
    }));
  };

  var checkTransactionStatus = function checkTransactionStatus() {
    try {
      return Promise.resolve(_catch(function () {
        if (!isPending || transactions == null) {
          return;
        }

        isFetchingStatusRef.current = true;
        var pendingTransactions = transactions.reduce(function (acc, _ref2) {
          var receiver = _ref2.receiver,
              data = _ref2.data,
              status = _ref2.status,
              hash = _ref2.hash;
          var isScCall = isContract(receiver, data);

          if (hash != null && !timeoutRefs.current.includes(hash) && getIsTransactionPending(status, isScCall)) {
            acc.push({
              hash: hash,
              previousStatus: status
            });
          }

          return acc;
        }, []);

        if ((pendingTransactions === null || pendingTransactions === void 0 ? void 0 : pendingTransactions.length) === 0) {
          isFetchingStatusRef.current = false;
          return;
        }

        return Promise.resolve(getTransactionsByHash(pendingTransactions)).then(function (serverTransactions) {
          var _loop = function _loop() {
            var _step$value = _step.value,
                hash = _step$value.hash,
                status = _step$value.status,
                results = _step$value.results,
                invalidTransaction = _step$value.invalidTransaction,
                receiver = _step$value.receiver,
                data = _step$value.data,
                hasStatusChanged = _step$value.hasStatusChanged;

            try {
              var isScCall = isContract(receiver, data);
              var retriesForThisHash = retriesRef.current[hash];

              if (retriesForThisHash > 30) {
                manageTimedOutTransactions();
                return {
                  v: void 0
                };
              }

              if (!invalidTransaction) {
                if (!getIsTransactionPending(status)) {
                  if (isScCall && !getIsTransactionCompleted(status)) {
                    var isScCallCompleted = areScCallsSuccessful(results);

                    if (isScCallCompleted) {
                      timeoutRefs.current.push(hash);
                      setTimeout(function () {
                        return dispatch(updateSignedTransactionStatus({
                          sessionId: sessionId,
                          status: TransactionServerStatusesEnum.completed,
                          transactionHash: hash
                        }));
                      }, completedTransactionsDelay);
                    }
                  }

                  if (hasStatusChanged) {
                    dispatch(updateSignedTransactionStatus({
                      sessionId: sessionId,
                      status: status,
                      transactionHash: hash
                    }));
                  }

                  refreshAccount();

                  if (getIsTransactionFailed(status)) {
                    var resultWithError = results.find(function (scResult) {
                      return (scResult === null || scResult === void 0 ? void 0 : scResult.returnMessage) !== '';
                    });
                    dispatch(updateSignedTransactionStatus({
                      transactionHash: hash,
                      sessionId: sessionId,
                      status: TransactionServerStatusesEnum.fail,
                      errorMessage: resultWithError === null || resultWithError === void 0 ? void 0 : resultWithError.returnMessage
                    }));
                    dispatch(updateSignedTransactions({
                      sessionId: sessionId,
                      status: TransactionBatchStatusesEnum.fail,
                      errorMessage: resultWithError === null || resultWithError === void 0 ? void 0 : resultWithError.returnMessage
                    }));
                  }
                } else {
                  retriesRef.current[hash] = retriesRef.current[hash] ? retriesRef.current[hash] + 1 : 1;
                }
              } else {
                retriesRef.current[hash] = retriesRef.current[hash] ? retriesRef.current[hash] + 1 : 1;
              }
            } catch (error) {
              console.error(error);
              manageTimedOutTransactions();
            }
          };

          for (var _iterator = _createForOfIteratorHelperLoose(serverTransactions), _step; !(_step = _iterator()).done;) {
            var _ret = _loop();

            if (typeof _ret === "object") return _ret.v;
          }
        });
      }, function (error) {
        console.error(error);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  useEffect(function () {
    if (isPending) {
      intervalRef.current = setInterval(function () {
        checkTransactionStatus();
      }, 2000);
    } else {
      clearInterval(intervalRef.current);
    }

    return function () {
      clearInterval(intervalRef.current);
    };
  }, [isPending]);
  return null;
}

function TransactionsTracker() {
  var _useGetPendingTransac = useGetPendingTransactions(),
      pendingTransactionsArray = _useGetPendingTransac.pendingTransactionsArray;

  return React__default.createElement(React__default.Fragment, null, pendingTransactionsArray.map(function (_ref) {
    var sessionId = _ref[0],
        transactionPayload = _ref[1];
    return React__default.createElement(TransactionStatusTracker, {
      key: sessionId,
      sessionId: sessionId,
      transactionPayload: transactionPayload
    });
  }));
}

var getServerConfiguration = function getServerConfiguration(environment) {
  try {
    return Promise.resolve(_catch(function () {
      return Promise.resolve(axios.get(configEndpoint[environment])).then(function (_ref) {
        var data = _ref.data;

        if (data != null) {
          return data;
        }
      });
    }, function () {
      console.error('error fetching configuration for ', environment);
      return null;
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

var useGetNetworkConfig = function useGetNetworkConfig() {
  return useSelector(networkConfigSelector);
};

function useGetNotification() {
  var notification = useSelector(notificationModalSelector);
  var dispatch = useDispatch();

  var clearNotification = function clearNotification() {
    return dispatch(clearNotificationModal());
  };

  return {
    notification: notification,
    clearNotification: clearNotification
  };
}

function useGetTransactionDisplayInfo(toastId) {
  return useSelector(function (state) {
    return transactionDisplayInfoSelector(state, toastId);
  });
}

function useParseSignedTransactions() {
  var search = window.location.search;
  var network = useSelector(networkSelector);
  var dispatch = useDispatch();
  React__default.useEffect(function () {
    if (search != null) {
      var searchData = qs.parse(search.replace('?', ''));

      if (searchData && walletSignSession in searchData) {
        var signSessionId = searchData[walletSignSession];
        var signedTransactions = new WalletProvider("" + network.walletAddress + dappInitRoute).getTransactionsFromWalletUrl();

        if (signedTransactions.length > 0) {
          var _updateSignedTransact;

          dispatch(updateSignedTransaction((_updateSignedTransact = {}, _updateSignedTransact[signSessionId.toString()] = {
            status: TransactionBatchStatusesEnum.signed,
            transactions: signedTransactions.map(function (tx) {
              return parseTransactionAfterSigning(tx);
            })
          }, _updateSignedTransact)));
        }
      }
    }
  }, [search]);
}

function useSignTransactions() {
  var signTransactionsWithProvider = function signTransactionsWithProvider() {
    try {
      return Promise.resolve(_catch(function () {
        var sessionId = transactionsToSign.sessionId,
            transactions = transactionsToSign.transactions,
            callbackRoute = transactionsToSign.callbackRoute,
            sessionInformation = transactionsToSign.sessionInformation,
            redirectAfterSign = transactionsToSign.redirectAfterSign;
        return function () {
          if (transactions !== null && transactions !== void 0 && transactions.length) {
            return Promise.resolve(provider.init()).then(function (initialized) {
              if (!initialized) {
                return;
              }

              var _temp = _catch(function () {
                return Promise.resolve(provider.signTransactions(transactions)).then(function (signedTransactions) {
                  var signingDisabled = !signedTransactions || signedTransactions && Object.keys(signedTransactions).length !== (transactions === null || transactions === void 0 ? void 0 : transactions.length);

                  if (!signingDisabled && signedTransactions) {
                    var _updateSignedTransact2;

                    dispatch(updateSignedTransaction((_updateSignedTransact2 = {}, _updateSignedTransact2[sessionId] = {
                      status: TransactionBatchStatusesEnum.signed,
                      sessionInformation: sessionInformation,
                      transactions: Object.values(signedTransactions).map(function (tx) {
                        return parseTransactionAfterSigning(tx);
                      })
                    }, _updateSignedTransact2)));

                    if (redirectAfterSign && !window.location.pathname.includes(callbackRoute)) {
                      window.location.href = callbackRoute;
                    }
                  }
                });
              }, function (err) {
                console.error('error signing transaction', err);
                onCancel(err.message, sessionId);
              });

              if (_temp && _temp.then) return _temp.then(function () {});
            });
          }
        }();
      }, function (err) {
        console.error('error signing transaction', err);
        onCancel(err.message);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var provider = useSelector(providerSelector);
  var proxy = useSelector(proxySelector);
  var address = useSelector(addressSelector);
  var transactionsToSign = useSelector(transactionsToSignSelector);
  var savedCallback = useRef('/');
  var dispatch = useDispatch();

  var _useState = useState(null),
      error = _useState[0],
      setError = _useState[1];

  useParseSignedTransactions();
  var providerType = getProviderType(provider);

  function clearSignInfo(sessionId) {
    dispatch(clearSignTransactions());
    dispatch(clearTransactionsInfoForSessionId(sessionId));

    if (provider instanceof ExtensionProvider) {
      var _ExtensionProvider$ge, _ExtensionProvider$ge2;

      (_ExtensionProvider$ge = ExtensionProvider.getInstance()) === null || _ExtensionProvider$ge === void 0 ? void 0 : (_ExtensionProvider$ge2 = _ExtensionProvider$ge.cancelAction) === null || _ExtensionProvider$ge2 === void 0 ? void 0 : _ExtensionProvider$ge2.call(_ExtensionProvider$ge);
    }
  }

  function onCancel(e, sessionId) {
    if (e !== 'Transaction cancelled') {
      setError(e);
    }

    clearSignInfo(sessionId);
  }

  function onAbort(sessionId) {
    setError(null);
    clearSignInfo(sessionId);
  }

  var signTransactions = function signTransactions() {
    try {
      return Promise.resolve(function () {
        if (transactionsToSign) {
          var sessionId = transactionsToSign.sessionId,
              transactions = transactionsToSign.transactions,
              callbackRoute = transactionsToSign.callbackRoute;
          savedCallback.current = callbackRoute;
          return _catch(function () {
            if (provider == null) {
              console.error('You need a signer/valid signer to send a transaction, use either WalletProvider, LedgerProvider or WalletConnect');
              return;
            }

            return Promise.resolve(proxy.getAccount(new Address(address))).then(function (proxyAccount) {
              var _urlParams;

              var latestNonce = getLatestNonce(proxyAccount);
              transactions.forEach(function (tx, i) {
                tx.setNonce(new Nonce$1(latestNonce + i));
              });

              switch (providerType) {
                case LoginMethodsEnum.wallet:
                  var callbackUrl = buildReplyUrl({
                    callbackUrl: "" + window.location.origin + callbackRoute,
                    urlParams: (_urlParams = {}, _urlParams[walletSignSession] = sessionId, _urlParams)
                  });
                  dispatch(clearSignTransactions());
                  provider.signTransactions(transactions, {
                    callbackUrl: encodeURIComponent(callbackUrl)
                  });
                  break;

                case LoginMethodsEnum.extension:
                case LoginMethodsEnum.walletconnect:
                case LoginMethodsEnum.extra:
                  signTransactionsWithProvider();
                  break;
              }
            });
          }, function (err) {
            var _updateSignedTransact;

            var errMessage = 'error when signing';
            console.error(errMessage, err);
            onCancel((err === null || err === void 0 ? void 0 : err.message) || errMessage, sessionId);
            dispatch(updateSignedTransaction((_updateSignedTransact = {}, _updateSignedTransact[sessionId] = {
              status: TransactionBatchStatusesEnum.cancelled
            }, _updateSignedTransact)));
          });
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  };

  useEffect(function () {
    if (transactionsToSign !== null && transactionsToSign !== void 0 && transactionsToSign.sessionId) {
      signTransactions();
    }
  }, [transactionsToSign === null || transactionsToSign === void 0 ? void 0 : transactionsToSign.sessionId]);
  var hasTransactions = transactionsToSign === null || transactionsToSign === void 0 ? void 0 : transactionsToSign.transactions;
  return {
    onAbort: onAbort,
    error: error,
    hasTransactions: hasTransactions,
    transactions: transactionsToSign === null || transactionsToSign === void 0 ? void 0 : transactionsToSign.transactions,
    sessionId: transactionsToSign === null || transactionsToSign === void 0 ? void 0 : transactionsToSign.sessionId,
    callbackRoute: savedCallback.current
  };
}

function useGetSignedTransactions() {
  return useSelector(signedTransactionsSelector);
}

var swr = {};

try {
  swr = require('swr');
} catch (err) {}

var useSwr = swr;

var fetcher = function fetcher(url) {
  return fetch(url).then(function (res) {
    return res.json();
  });
};

function useGetTokenDetails(_ref) {
  var _selectedToken$assets;

  var tokenId = _ref.tokenId;

  var _useGetNetworkConfig = useGetNetworkConfig(),
      network = _useGetNetworkConfig.network;

  if (!tokenId) {
    return {
      tokenDenomination: Number(network.egldDenomination),
      tokenLabel: '',
      tokenAvatar: ''
    };
  }

  var _useSwr = useSwr(network.apiAddress + "/tokens/" + tokenId, fetcher),
      selectedToken = _useSwr.data,
      error = _useSwr.error;

  var tokenDenomination = selectedToken ? selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.decimals : Number(network.egldDenomination);
  var tokenLabel = selectedToken ? selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.name : '';
  var tokenAvatar = selectedToken ? "" + (selectedToken === null || selectedToken === void 0 ? void 0 : (_selectedToken$assets = selectedToken.assets) === null || _selectedToken$assets === void 0 ? void 0 : _selectedToken$assets.svgUrl) : '';
  return {
    tokenDenomination: tokenDenomination,
    tokenLabel: tokenLabel,
    tokenAvatar: tokenAvatar,
    error: error
  };
}

function useSignTransactionsWithLedger(_ref) {
  var _currentTransaction$t, _currentTransaction$t2, _currentTransaction$t3;

  var sign = function sign() {
    try {
      return Promise.resolve(_catch(function () {
        if (currentTransaction == null || sessionId == null) {
          return;
        }

        setWaitingForDevice(true);
        return Promise.resolve(provider.signTransaction(currentTransaction.transaction)).then(function (signedTx) {
          var _newSignedTx;

          var newSignedTx = (_newSignedTx = {}, _newSignedTx[currentStep] = signedTx, _newSignedTx);
          var newSignedTransactions = signedTransactions ? _extends({}, signedTransactions, newSignedTx) : newSignedTx;
          setSignedTransactions(newSignedTransactions);

          if (!isLastTransaction) {
            setCurrentStep(function (exising) {
              return exising + 1;
            });
          } else if (newSignedTransactions) {
            var _updateSignedTransact;

            dispatch(clearSignTransactions());
            dispatch(updateSignedTransaction((_updateSignedTransact = {}, _updateSignedTransact[sessionId] = {
              status: TransactionBatchStatusesEnum.signed,
              transactions: Object.values(newSignedTransactions).map(function (tx) {
                return parseTransactionAfterSigning(tx, true);
              })
            }, _updateSignedTransact)));
            reset();

            if (callbackRoute != null && redirectAfterSign && !window.location.pathname.includes(callbackRoute)) {
              window.location.href = callbackRoute;
            }
          }
        });
      }, function (err) {
        console.error(err, 'sign error');
        reset();
        dispatch(setSignTransactionsError(err.message));
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var onCancel = _ref.onCancel;
  var transactionsToSign = useSelector(transactionsToSignSelector);

  var _ref2 = transactionsToSign || {},
      sessionId = _ref2.sessionId,
      transactions = _ref2.transactions,
      callbackRoute = _ref2.callbackRoute,
      redirectAfterSign = _ref2.redirectAfterSign;

  var _useState = useState(0),
      currentStep = _useState[0],
      setCurrentStep = _useState[1];

  var _useState2 = useState(),
      signedTransactions = _useState2[0],
      setSignedTransactions = _useState2[1];

  var _useParseMultiEsdtTra = useParseMultiEsdtTransferData({
    transactions: transactions
  }),
      getTxInfoByDataField = _useParseMultiEsdtTra.getTxInfoByDataField,
      allTransactions = _useParseMultiEsdtTra.allTransactions;

  var _useState3 = useState(null),
      currentTransaction = _useState3[0],
      setCurrentTransaction = _useState3[1];

  var provider = useSelector(providerSelector);
  var egldLabel = useSelector(egldLabelSelector);

  var _useState4 = useState(false),
      waitingForDevice = _useState4[0],
      setWaitingForDevice = _useState4[1];

  var dispatch = useDispatch();
  var isLastTransaction = currentStep === allTransactions.length - 1;
  useEffect(function () {
    extractTransactionsInfo();
  }, [currentStep, allTransactions]);

  function extractTransactionsInfo() {
    var tx = allTransactions[currentStep];

    if (tx == null) {
      return;
    }

    var transaction = tx.transaction,
        multiTxData = tx.multiTxData;
    var dataField = transaction.getData().toString();
    var transactionTokenInfo = getTxInfoByDataField(transaction.getData().toString(), multiTxData);
    var tokenId = transactionTokenInfo.tokenId;
    var isTokenTransaction = Boolean(tokenId && isTokenTransfer({
      tokenId: tokenId,
      erdLabel: egldLabel
    }));
    setCurrentTransaction({
      transaction: transaction,
      transactionTokenInfo: transactionTokenInfo,
      isTokenTransaction: isTokenTransaction,
      dataField: dataField
    });
  }

  function reset() {
    setCurrentStep(0);
    setSignedTransactions(undefined);
    setWaitingForDevice(false);
  }

  function signTx() {
    try {
      if (currentTransaction == null) {
        return;
      }

      var signature = currentTransaction.transaction.getSignature();

      if (signature) {
        if (!isLastTransaction) {
          setCurrentStep(function (exising) {
            return exising + 1;
          });
        }
      } else {
        sign();
      }
    } catch (_unused) {
      sign();
    }
  }

  function onAbort() {
    if (isFirst) {
      dispatch(clearSignTransactions());

      if (callbackRoute != null && redirectAfterSign) {
        window.location.href = callbackRoute;
      }
    } else {
      setCurrentStep(function (existing) {
        return existing - 1;
      });
    }
  }

  var continueWithoutSigning = (currentTransaction === null || currentTransaction === void 0 ? void 0 : (_currentTransaction$t = currentTransaction.transactionTokenInfo) === null || _currentTransaction$t === void 0 ? void 0 : _currentTransaction$t.type) && (currentTransaction === null || currentTransaction === void 0 ? void 0 : (_currentTransaction$t2 = currentTransaction.transactionTokenInfo) === null || _currentTransaction$t2 === void 0 ? void 0 : _currentTransaction$t2.multiTxData) && !(currentTransaction !== null && currentTransaction !== void 0 && currentTransaction.dataField.endsWith(currentTransaction === null || currentTransaction === void 0 ? void 0 : (_currentTransaction$t3 = currentTransaction.transactionTokenInfo) === null || _currentTransaction$t3 === void 0 ? void 0 : _currentTransaction$t3.multiTxData));

  function onSignTransaction() {
    if (continueWithoutSigning) {
      setCurrentStep(function (exising) {
        return exising + 1;
      });
    } else {
      signTx();
    }
  }

  function onNext() {
    setCurrentStep(function (current) {
      var nextStep = current + 1;

      if (nextStep > (allTransactions === null || allTransactions === void 0 ? void 0 : allTransactions.length)) {
        return current;
      }

      return nextStep;
    });
  }

  function onPrev() {
    if (currentStep === 0) {
      onCancel();
    }

    setCurrentStep(function (current) {
      var nextStep = current - 1;

      if (nextStep < 0) {
        return current;
      }

      return nextStep;
    });
  }

  var isFirst = currentStep === 0;
  return {
    allTransactions: allTransactions,
    onSignTransaction: onSignTransaction,
    onNext: onNext,
    onPrev: onPrev,
    waitingForDevice: waitingForDevice,
    onAbort: onAbort,
    isLastTransaction: isLastTransaction,
    callbackRoute: callbackRoute,
    currentStep: currentStep,
    signedTransactions: signedTransactions,
    currentTransaction: currentTransaction
  };
}

var useGetSignTransactionsError = function useGetSignTransactionsError() {
  return useSelector(signTransactionsErrorSelector);
};

var useGetAccountInfo = function useGetAccountInfo() {
  return useSelector(accountInfoSelector);
};

var useGetLoginInfo = function useGetLoginInfo() {
  var loginInfo = useSelector(loginInfoSelector);
  var isLoggedIn = useSelector(isLoggedInSelector);
  return _extends({}, loginInfo, {
    isLoggedIn: isLoggedIn
  });
};

var useGetAccountProvider = function useGetAccountProvider() {
  var provider = useSelector(providerSelector);
  var providerType = getProviderType(provider);
  return {
    provider: provider,
    providerType: providerType
  };
};

var getAccountShard = function getAccountShard() {
  try {
    var _await$axios$get, account;

    var appState = store.getState();
    var network = networkSelector(appState);
    var address = addressSelector(appState);
    var shard = shardSelector(appState);
    return Promise.resolve(_catch(function () {
      if (shard == null && address) {
        return Promise.resolve(axios.get(network.apiAddress + "/accounts/" + address)).then(function (_axios$get) {
          _await$axios$get = _axios$get;
          account = _await$axios$get.data;
          store.dispatch(setAccountShard(account.shard));
          return account.shard;
        });
      } else {
        return shard;
      }
    }, function (err) {
      console.error(err);
      return null;
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

function AppInitializer(_ref) {
  var initializeApp = function initializeApp() {
    try {
      initializeCustomExtraActions();
      return Promise.resolve(initializeNetwork()).then(function () {
        setInitialized(true);
        getAccountShard();
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var initializeNetwork = function initializeNetwork() {
    try {
      var fallbackConfig = fallbackConfigurations[environment];

      if (fallbackConfig != null) {
        dispatch(initializeNetworkConfig(_extends({}, fallbackConfig, customNetworkConfig)));
      }

      return Promise.resolve(getServerConfiguration(environment)).then(function (serverConfig) {
        if (serverConfig != null) {
          dispatch(initializeNetworkConfig(_extends({}, serverConfig, customNetworkConfig)));
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var _ref$customNetworkCon = _ref.customNetworkConfig,
      customNetworkConfig = _ref$customNetworkCon === void 0 ? {} : _ref$customNetworkCon,
      children = _ref.children,
      environment = _ref.environment,
      extraActions = _ref.extraActions;

  var _useState = useState(false),
      initialized = _useState[0],
      setInitialized = _useState[1];

  var account = useGetAccountInfo();
  var address = account.address,
      publicKey = account.publicKey;
  var dispatch = useDispatch();

  function initializeCustomExtraActions() {
    if (extraActions != null) {
      try {
        extraActions === null || extraActions === void 0 ? void 0 : extraActions.init({
          onLogin: function onLogin(address, loginMethod) {
            dispatch(loginAction({
              address: address,
              loginMethod: loginMethod
            }));
          },
          log: function log(word) {
            console.log('dapp log: ', word);
          }
        });
        dispatch(initializeExtraActions(extraActions));
      } catch (err) {
        console.error('Unable to initalize extraActions', err);
      }
    }
  }

  useEffect(function () {
    if (address) {
      var pubKey = new Address$1(address).hex();

      if (pubKey !== publicKey) {
        logout();
      }
    }
  }, [address, publicKey]);
  useEffect(function () {
    initializeApp();
  }, [customNetworkConfig, environment]);
  return initialized ? children : null;
}

var DappProvider = function DappProvider(_ref) {
  var children = _ref.children,
      _ref$customNetworkCon = _ref.customNetworkConfig,
      customNetworkConfig = _ref$customNetworkCon === void 0 ? {} : _ref$customNetworkCon,
      extraActions = _ref.extraActions,
      _ref$completedTransac = _ref.completedTransactionsDelay,
      completedTransactionsDelay = _ref$completedTransac === void 0 ? 0 : _ref$completedTransac,
      _ref$signWithoutSendi = _ref.signWithoutSending,
      signWithoutSending = _ref$signWithoutSendi === void 0 ? false : _ref$signWithoutSendi,
      environment = _ref.environment,
      _ref$sendSignedTransa = _ref.sendSignedTransactionsAsync,
      sendSignedTransactionsAsync = _ref$sendSignedTransa === void 0 ? sendSignedTransactions : _ref$sendSignedTransa,
      _ref$getTransactionsB = _ref.getTransactionsByHash,
      getTransactionsByHash = _ref$getTransactionsB === void 0 ? getTransactionsByHashes : _ref$getTransactionsB;
  var memoizedSendSignedTransactionsAsync = useCallback(sendSignedTransactionsAsync, []);
  var memoizedGetTransactionsByHash = useCallback(getTransactionsByHash, []);
  return React__default.createElement(Provider, {
    context: DappCoreContext,
    store: store
  }, React__default.createElement(PersistGate, {
    persistor: persistor,
    loading: null
  }, React__default.createElement(OverrideDefaultBehaviourContext.Provider, {
    value: {
      sendSignedTransactionsAsync: memoizedSendSignedTransactionsAsync,
      getTransactionsByHash: memoizedGetTransactionsByHash,
      completedTransactionsDelay: completedTransactionsDelay
    }
  }, React__default.createElement(AppInitializer, {
    environment: environment,
    customNetworkConfig: customNetworkConfig,
    extraActions: extraActions
  }, React__default.createElement(ProviderInitializer, null), !signWithoutSending && React__default.createElement(TransactionSender, null), React__default.createElement(TransactionsTracker, null), children))));
};

var AuthenticatedRoutesWrapper = function AuthenticatedRoutesWrapper(_ref) {
  var children = _ref.children,
      routes = _ref.routes,
      unlockRoute = _ref.unlockRoute,
      onRedirect = _ref.onRedirect;
  var isLoggedIn = useSelector(isLoggedInSelector);
  var isAccountLoading = useSelector(isAccountLoadingSelector);
  var walletLogin = useSelector(walletLoginSelector);
  var pathname = window.location.pathname;
  var authenticatedRoutesRef = useRef(routes.filter(function (route) {
    return Boolean(route.authenticatedRoute);
  }));
  var isOnAuthenticatedRoute = authenticatedRoutesRef.current.some(function (_ref2) {
    var path = _ref2.path;
    return pathname === path;
  });
  var shouldRedirect = isOnAuthenticatedRoute && !isLoggedIn && walletLogin == null;

  if (isAccountLoading || walletLogin) {
    return null;
  }

  if (shouldRedirect) {
    if (onRedirect) {
      onRedirect(unlockRoute);
    } else {
      window.location.href = unlockRoute;
    }

    return null;
  }

  return React__default.createElement(React__default.Fragment, null, children);
};

var TransactionParameter = function TransactionParameter(sender, receiver, functionName, inputParameters, outputParameters) {
  this.sender = sender;
  this.receiver = receiver;
  this.functionName = functionName;
  this.inputParameters = inputParameters;
  this.outputParameters = outputParameters;
};



var index$2 = {
  __proto__: null,
  TransactionParameter: TransactionParameter
};

var withClassNameWrapper = function withClassNameWrapper(Component) {
  return function (_ref) {
    var props = _extends({}, _ref);

    return React__default.createElement("span", {
      className: wrapperClassName
    }, React__default.createElement(Component, Object.assign({}, props)));
  };
};

var denominateInvalid = function denominateInvalid(props) {
  return React__default.createElement("span", {
    "data-testid": props['data-testid'] ? props['data-testid'] : 'denominateComponent'
  }, React__default.createElement("span", {
    className: 'int-amount'
  }, "..."));
};

var denominateValid = function denominateValid(props, erdLabel) {
  var value = props.value,
      _props$showLastNonZer = props.showLastNonZeroDecimal,
      showLastNonZeroDecimal = _props$showLastNonZer === void 0 ? false : _props$showLastNonZer,
      _props$showLabel = props.showLabel,
      showLabel = _props$showLabel === void 0 ? true : _props$showLabel;
  var decimals$1 = props.decimals !== undefined ? props.decimals : decimals;
  var denomination$1 = props.denomination !== undefined ? props.denomination : denomination;
  var denominatedValue = denominate({
    input: value,
    denomination: denomination$1,
    decimals: decimals$1,
    showLastNonZeroDecimal: showLastNonZeroDecimal,
    addCommas: true
  });
  var valueParts = denominatedValue.split('.');
  var hasNoDecimals = valueParts.length === 1;
  var isNotZero = denominatedValue !== '0';

  if (decimals$1 > 0 && hasNoDecimals && isNotZero) {
    var zeros = '';

    for (var i = 1; i <= decimals$1; i++) {
      zeros = zeros + '0';
    }

    valueParts.push(zeros);
  }

  return React__default.createElement("span", {
    "data-testid": props['data-testid'] ? props['data-testid'] : 'denominateComponent'
  }, React__default.createElement("span", {
    className: 'int-amount'
  }, valueParts[0]), valueParts.length > 1 && React__default.createElement("span", {
    className: 'decimals'
  }, ".", valueParts[1]), showLabel && React__default.createElement("span", {
    className: "symbol " + (props.token ? 'text-muted' : '')
  }, "\xA0", props.token ? props.token : erdLabel));
};

var Denominate = function Denominate(props) {
  var value = props.value;
  return !validation.stringIsInteger(value) ? denominateInvalid(props) : denominateValid(props, props.egldLabel || '');
};

var DenominateWrapper = function DenominateWrapper(props) {
  var egldLabel = getEgldLabel();

  var denominateProps = _extends({}, props, {
    egldLabel: egldLabel
  });

  return React__default.createElement(Denominate, Object.assign({}, denominateProps));
};

var Denominate$1 = withClassNameWrapper(DenominateWrapper);

var fontawesomeFreeSolidIcons = {};

try {
  fontawesomeFreeSolidIcons = require('@fortawesome/free-solid-svg-icons');
} catch (err) {}

var icons = fontawesomeFreeSolidIcons;

var ReactFontawesome = {};

try {
  ReactFontawesome = require('@fortawesome/react-fontawesome');
} catch (err) {}

var ReactFontawesome$1 = ReactFontawesome;

var ExplorerLink = function ExplorerLink(_ref) {
  var page = _ref.page,
      text = _ref.text,
      className = _ref.className;

  var _useGetNetworkConfig = useGetNetworkConfig(),
      explorerAddress = _useGetNetworkConfig.network.explorerAddress;

  return React__default.createElement("a", Object.assign({
    href: "" + explorerAddress + page
  }, {
    target: '_blank'
  }, {
    className: "link-style " + className
  }), text ? React__default.createElement(React__default.Fragment, null, text) : React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
    icon: icons.faSearch,
    className: 'text-secondary'
  }));
};

var ExplorerLink$1 = withClassNameWrapper(ExplorerLink);

var ExtensionLoginButton = function ExtensionLoginButton(_ref) {
  var token = _ref.token,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'extension-login' : _ref$className,
      children = _ref.children,
      callbackRoute = _ref.callbackRoute,
      buttonClassName = _ref.buttonClassName,
      _ref$loginButtonText = _ref.loginButtonText,
      loginButtonText = _ref$loginButtonText === void 0 ? 'Maiar DeFi Wallet' : _ref$loginButtonText,
      _ref$redirectAfterLog = _ref.redirectAfterLogin,
      redirectAfterLogin = _ref$redirectAfterLog === void 0 ? false : _ref$redirectAfterLog,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa;

  var _useExtensionLogin = useExtensionLogin({
    callbackRoute: callbackRoute,
    token: token,
    redirectAfterLogin: redirectAfterLogin
  }),
      onInitiateLogin = _useExtensionLogin[0];

  var classes = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: "btn btn-primary px-sm-4 m-1 mx-sm-3 " + (buttonClassName != null ? buttonClassName : ''),
    loginText: 'text-left',
    noExtensionButtonWrapper: 'btn btn-unlock d-inline-block',
    noExtensionButtonContent: 'd-flex justify-content-between align-items-center',
    noExtensionButtonTitle: 'title',
    noExtensionButtonIcon: ''
  });

  var handleLogin = function handleLogin() {
    onInitiateLogin();
  };

  return !window.elrondWallet ? React__default.createElement("a", {
    rel: 'noreferrer',
    href: 'https://chrome.google.com/webstore/detail/dngmlblcodfobpdpecaadgfbcggfjfnm?authuser=0&hl=en',
    target: '_blank',
    className: classes.noExtensionButtonWrapper
  }, React__default.createElement("div", {
    className: classes.noExtensionButtonContent
  }, React__default.createElement("div", {
    className: classes.noExtensionButtonTitle
  }, "Maiar DeFi Wallet"), React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
    className: classes.noExtensionButtonIcon,
    icon: ReactFontawesome$1.faArrowRight
  }))) : React__default.createElement("button", {
    onClick: handleLogin,
    className: classes.wrapper
  }, children || React__default.createElement("span", {
    className: classes.loginText
  }, loginButtonText));
};

var ExtensionLoginButton$1 = withClassNameWrapper(ExtensionLoginButton);

var ReactBootstrap = {};

try {
  ReactBootstrap = require('react-bootstrap');
} catch (err) {}

var ReactBootstrap$1 = ReactBootstrap;

var ModalContainer = function ModalContainer(_ref) {
  var children = _ref.children,
      noSpacer = _ref.noSpacer,
      className = _ref.className,
      title = _ref.title,
      onClose = _ref.onClose;
  return React__default.createElement(ReactBootstrap$1.Modal, {
    show: true,
    backdrop: 'static',
    onHide: onClose,
    className: "modal-container " + (className ? className : '') + " " + wrapperClassName,
    animation: false,
    centered: true
  }, React__default.createElement("div", {
    className: 'modal-card card w-100'
  }, React__default.createElement("div", {
    className: 'card-title h5 mb-0'
  }, React__default.createElement("div", {
    className: 'd-flex justify-content-between align-items-center pt-spacer px-spacer mb-0'
  }, React__default.createElement("div", {
    className: 'px-3'
  }, title), React__default.createElement("button", {
    type: 'button',
    className: 'btn btn-light px-3 py-2',
    onClick: onClose
  }, React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
    size: 'lg',
    icon: icons.faTimes
  })))), React__default.createElement("div", {
    className: "modal-card-body text-center " + (noSpacer ? 'p-0' : 'p-spacer')
  }, children)));
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var classnames$2 = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if ( module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});

var PageState = function PageState(_ref) {
  var _classNames;

  var icon = _ref.icon,
      title = _ref.title,
      action = _ref.action,
      iconClass = _ref.iconClass,
      dataTestId = _ref.dataTestId,
      description = _ref.description,
      iconBgClass = _ref.iconBgClass,
      _ref$iconSize = _ref.iconSize,
      iconSize = _ref$iconSize === void 0 ? '5x' : _ref$iconSize,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'page-state' : _ref$className,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa;
  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: 'state m-auto p-4 text-center',
    iconContainer: classnames$2('icon-state mx-auto', (_classNames = {}, _classNames["" + iconBgClass] = Boolean(iconBgClass), _classNames)),
    iconClass: classnames$2(iconClass != null && iconClass),
    title: 'h4 my-4',
    description: 'mb-3'
  });
  return React__default.createElement("div", {
    className: generatedClasses.wrapper,
    "data-testid": dataTestId
  }, icon && React__default.createElement("span", {
    className: generatedClasses.iconContainer
  }, React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
    icon: icon,
    className: generatedClasses.iconClass,
    size: iconSize
  })), title && React__default.createElement("p", {
    className: generatedClasses.title
  }, title), description && React__default.createElement("div", {
    className: generatedClasses.description
  }, description), action && React__default.createElement(React__default.Fragment, null, action));
};
var PageState$1 = withClassNameWrapper(PageState);

var trimHash = function trimHash(hash, keep) {
  if (keep === void 0) {
    keep = 10;
  }

  var start = hash.substring(0, keep);
  var end = hash.substring(hash.length - keep);
  return start + "..." + end;
};

var noBalance = '...';

var AddressRow = function AddressRow(_ref) {
  var address = _ref.address,
      index = _ref.index,
      selectedAddress = _ref.selectedAddress,
      onSelectAddress = _ref.onSelectAddress;

  var _React$useState = React__default.useState(noBalance),
      balance = _React$useState[0],
      setBalance = _React$useState[1];

  var handleChange = function handleChange(e) {
    var checked = e.target.checked;

    if (checked) {
      onSelectAddress({
        address: address,
        index: index
      });
    }
  };

  var fetchBalance = function fetchBalance() {
    try {
      var _temp2 = _catch(function () {
        return Promise.resolve(getAccountBalance(address)).then(function (balance) {
          setBalance(balance);
        });
      }, function () {
        console.error('error fetching balance', balance);
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  React__default.useEffect(function () {
    fetchBalance();
  }, []);
  return React__default.createElement("tr", null, React__default.createElement("td", {
    className: 'text-left'
  }, React__default.createElement("div", {
    className: 'd-flex align-items-start text-left form-check'
  }, React__default.createElement("input", {
    type: 'radio',
    id: "check_" + index,
    "data-testid": "check_" + index,
    onChange: handleChange,
    role: 'button',
    checked: selectedAddress === address,
    className: 'form-check-input mr-1'
  }), React__default.createElement("label", {
    htmlFor: "check_" + index,
    role: 'button',
    "data-testid": "label_" + index,
    className: 'form-check-label text-nowrap trim-size-xl m-0'
  }, React__default.createElement("div", {
    className: 'd-flex align-items-center text-nowrap trim'
  }, React__default.createElement("span", null, trimHash(address)))))), React__default.createElement("td", {
    className: 'text-left'
  }, React__default.createElement(Denominate$1, {
    value: balance
  })), React__default.createElement("td", {
    className: 'text-left'
  }, index));
};

var ledgerWaitingText = 'Waiting for device';
var addressesPerPage = 10;

var AddressTable = function AddressTable(_ref) {
  var loading = _ref.loading,
      accounts = _ref.accounts,
      startIndex = _ref.startIndex,
      selectedAddress = _ref.selectedAddress,
      onGoToPrevPage = _ref.onGoToPrevPage,
      onGoToNextPage = _ref.onGoToNextPage,
      onConfirmSelectedAddress = _ref.onConfirmSelectedAddress,
      onSelectAddress = _ref.onSelectAddress,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'ledger-address-table' : _ref$className;
  var classes = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: 'card my-4 text-center',
    cardBody: 'card-body p-4 mx-lg-4',
    tableWrapper: 'table-responsive',
    tableContent: 'table m-0 border-bottom',
    tableHeader: 'py-2 text-semibold border-bottom',
    tableHeaderText: 'text-left border-0',
    buttonsWrapper: 'd-flex justify-content-center pager mt-2',
    arrowButton: 'btn btn-link mx-2',
    confirmButton: 'btn btn-primary px-4 mt-4'
  });

  switch (true) {
    case loading:
      return React__default.createElement(PageState$1, {
        className: className,
        icon: icons.faCircleNotch,
        iconClass: 'fa-spin text-primary',
        title: ledgerWaitingText
      });

    default:
      return React__default.createElement(React__default.Fragment, null, React__default.createElement("div", {
        className: 'm-auto'
      }, React__default.createElement("div", {
        className: classes.wrapper
      }, React__default.createElement("div", {
        className: classes.cardBody
      }, React__default.createElement("div", {
        className: classes.tableWrapper,
        "data-testid": 'ledgerAddresses'
      }, React__default.createElement("table", {
        className: classes.tableContent
      }, React__default.createElement("thead", {
        className: classes.tableHeader
      }, React__default.createElement("tr", null, React__default.createElement("th", {
        className: classes.tableHeaderText
      }, "Address"), React__default.createElement("th", {
        className: classes.tableHeaderText
      }, "Balance"), React__default.createElement("th", {
        className: classes.tableHeaderText
      }, "#"))), React__default.createElement("tbody", {
        "data-testid": 'addressesTable'
      }, accounts.map(function (address, index) {
        var key = index + startIndex * addressesPerPage;
        return React__default.createElement(AddressRow, {
          key: key,
          address: address,
          index: key,
          selectedAddress: selectedAddress,
          onSelectAddress: onSelectAddress
        });
      })))), React__default.createElement("div", {
        className: classes.buttonsWrapper
      }, React__default.createElement("button", {
        type: 'button',
        className: classes.arrowButton,
        onClick: onGoToPrevPage,
        "data-testid": 'prevBtn',
        disabled: startIndex === 0
      }, React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
        size: 'sm',
        icon: icons.faChevronLeft
      }), ' ', "Prev"), React__default.createElement("button", {
        type: 'button',
        className: classes.arrowButton,
        onClick: onGoToNextPage,
        "data-testid": 'nextBtn'
      }, "Next", ' ', React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
        size: 'sm',
        icon: icons.faChevronRight
      }))), React__default.createElement("button", {
        className: classes.confirmButton,
        disabled: selectedAddress === '',
        onClick: onConfirmSelectedAddress,
        "data-testid": 'confirmBtn'
      }, "Confirm")))));
  }
};

var ConfirmAddress = function ConfirmAddress(_ref) {
  var token = _ref.token,
      noBorder = _ref.noBorder;

  var _useGetAccountInfo = useGetAccountInfo(),
      ledgerAccount = _useGetAccountInfo.ledgerAccount;

  return React__default.createElement("div", {
    className: 'm-auto'
  }, React__default.createElement("div", {
    className: "card my-4 text-center " + (noBorder ? 'border-0' : '')
  }, React__default.createElement("div", {
    className: 'card-body p-4 mx-lg-4'
  }, React__default.createElement("h4", {
    className: 'mb-4'
  }, "Confirm Ledger Address"), React__default.createElement("p", null, "For security, please confirm that your address: "), React__default.createElement("p", {
    className: 'lead border rounded p-2'
  }, ledgerAccount ? ledgerAccount.address : ''), token && React__default.createElement(React__default.Fragment, null, React__default.createElement("p", null, "and Auth Token"), React__default.createElement("p", {
    className: 'lead border rounded p-2'
  }, token + "{}")), React__default.createElement("p", {
    className: 'm-0'
  }, token ? 'are the one shown on your Ledger device screen now.' : 'is the one shown on your Ledger device screen now.'), React__default.createElement("p", null, "Select Approve on your device to confirm."), React__default.createElement("p", null, "Or, if it does not match, close this page and", ' ', React__default.createElement("a", Object.assign({
    href: 'https://help.elrond.com/en/'
  }, {
    target: '_blank'
  }), "contact support"), "."))));
};

var _defs, _g;

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

function SvgLedgerNano(props) {
  return /*#__PURE__*/createElement("svg", _extends$1({
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    width: 110,
    height: 55,
    viewBox: "0 0 260 129"
  }, props), _defs || (_defs = /*#__PURE__*/createElement("defs", null, /*#__PURE__*/createElement("linearGradient", {
    id: "ledger-nano_svg__a",
    x1: "50%",
    x2: "50%",
    y1: "0%",
    y2: "100%"
  }, /*#__PURE__*/createElement("stop", {
    offset: "0%"
  }), /*#__PURE__*/createElement("stop", {
    offset: "100%",
    stopColor: "#FFF"
  })), /*#__PURE__*/createElement("path", {
    id: "ledger-nano_svg__b",
    d: "M91 0h34a4 4 0 014 4v108.144c0 11.519-9.337 20.856-20.856 20.856h-.288C96.337 133 87 123.663 87 112.144V4a4 4 0 014-4z"
  }))), _g || (_g = /*#__PURE__*/createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /*#__PURE__*/createElement("path", {
    className: "ledger-nano_svg__ledger-stroke",
    stroke: "#1D2027",
    strokeWidth: 2,
    d: "M127.856 31.44a1 1 0 01-1 1H100.63a5 5 0 01-5-5v-8.486a5 5 0 015-5h26.225a1 1 0 011 1v16.485z"
  }), /*#__PURE__*/createElement("path", {
    className: "ledger-nano_svg__ledger-stroke",
    stroke: "#142533",
    strokeWidth: 2,
    d: "M95.247 26.231H84.318v-6.435h10.93v6.435z"
  }), /*#__PURE__*/createElement("path", {
    className: "ledger-nano_svg__ledger-stroke",
    stroke: "#1D2027",
    strokeWidth: 2,
    d: "M127.923 28.726V17.471l6.977.083a1 1 0 01.988 1v9.266a1 1 0 01-1.012.988l-6.953-.083z"
  }), /*#__PURE__*/createElement("path", {
    fill: "url(#ledger-nano_svg__a)",
    d: "M6.836 53.925h1.616v82.65H6.836v-82.65zm5.657 0h1.616v82.65h-1.616v-82.65z",
    transform: "matrix(0 -1 -1 0 137.5 33.44)"
  }), /*#__PURE__*/createElement("g", {
    transform: "rotate(-90 128.59 1.975)"
  }, /*#__PURE__*/createElement("rect", {
    className: "ledger-nano_svg__ledger-fill",
    width: 4.492,
    height: 17.12,
    x: 125.336,
    y: 15.505,
    fill: "#142533",
    rx: 2
  }), /*#__PURE__*/createElement("rect", {
    className: "ledger-nano_svg__ledger-fill",
    width: 4.492,
    height: 17.12,
    x: 125.336,
    y: 70.094,
    fill: "#142533",
    rx: 2
  }), /*#__PURE__*/createElement("use", {
    className: "ledger-nano_svg__ledger-fill-inner-bg",
    fill: "#FFF",
    xlinkHref: "#ledger-nano_svg__b"
  }), /*#__PURE__*/createElement("path", {
    className: "ledger-nano_svg__ledger-stroke",
    fill: "#6490F1",
    fillOpacity: 0.15,
    stroke: "#142533",
    strokeLinejoin: "square",
    strokeWidth: 2,
    d: "M91 1a3 3 0 00-3 3v108.144C88 123.11 96.89 132 107.856 132h.288C119.11 132 128 123.11 128 112.144V4a3 3 0 00-3-3H91z"
  }), /*#__PURE__*/createElement("rect", {
    className: "ledger-nano_svg__ledger-fill-outer-bg",
    width: 21,
    height: 62,
    x: 97.5,
    y: 21.5,
    fill: "#FFF",
    stroke: "#6490F1",
    rx: 1.6
  }), /*#__PURE__*/createElement("path", {
    fill: "#6490F1",
    d: "M105.5 35h5a.5.5 0 01.5.5v34a.5.5 0 01-.5.5h-5a.5.5 0 01-.5-.5v-34a.5.5 0 01.5-.5zm1.238 3.042l.774.512v.013l-.774.505.341.466.722-.577h.013l.243.899.551-.177-.328-.88.932.053v-.597l-.932.046.328-.873-.551-.17-.243.892h-.013l-.722-.584-.34.472zm0 3.908l.774.512v.013l-.774.505.341.466.722-.578h.013l.243.9.551-.178-.328-.88.932.053v-.597l-.932.046.328-.872-.551-.17-.243.891h-.013l-.722-.584-.34.473zm0 3.907l.774.512v.013l-.774.505.341.466.722-.577h.013l.243.899.551-.178-.328-.879.932.053v-.597l-.932.046.328-.873-.551-.17-.243.892h-.013l-.722-.584-.34.472zm0 3.908l.774.511v.014l-.774.505.341.466.722-.578h.013l.243.899.551-.177-.328-.88.932.053v-.597l-.932.046.328-.872-.551-.171-.243.892h-.013l-.722-.584-.34.473zm0 3.907l.774.512v.013l-.774.505.341.466.722-.577h.013l.243.898.551-.177-.328-.879.932.053v-.597l-.932.046.328-.873-.551-.17-.243.892h-.013l-.722-.584-.34.472zm0 3.908l.774.511v.013l-.774.506.341.465.722-.577h.013l.243.899.551-.177-.328-.88.932.053v-.597l-.932.046.328-.873-.551-.17-.243.892h-.013l-.722-.584-.34.473zm0 3.907l.774.512v.013l-.774.505.341.466.722-.578h.013l.243.9.551-.178-.328-.879.932.052v-.597l-.932.046.328-.872-.551-.17-.243.891h-.013l-.722-.583-.34.472zm0 3.907l.774.512v.013l-.774.505.341.466.722-.577h.013l.243.899.551-.177-.328-.88.932.053v-.597l-.932.046.328-.873-.551-.17-.243.892h-.013l-.722-.584-.34.472z"
  }), /*#__PURE__*/createElement("path", {
    className: "ledger-nano_svg__ledger-stroke ledger-nano_svg__ledger-fill-outer-bg",
    fill: "#FFF",
    stroke: "#142533",
    strokeWidth: 2,
    d: "M123.166 125.105c7.049-8.4 5.953-20.925-2.447-27.974l-90.824-76.21a3 3 0 00-4.227.37L4 47.115a3 3 0 00.37 4.227l90.824 76.21c8.4 7.049 20.924 5.953 27.973-2.447z"
  }), /*#__PURE__*/createElement("ellipse", {
    cx: 108.016,
    cy: 111.123,
    stroke: "#6490F1",
    rx: 10.57,
    ry: 10.644
  })))));
}

var LedgerConnect = function LedgerConnect(_ref) {
  var onClick = _ref.onClick,
      error = _ref.error,
      connectPageContent = _ref.connectPageContent;
  return React__default.createElement("div", {
    className: 'm-auto login-container'
  }, React__default.createElement("div", {
    className: 'card my-4 text-center'
  }, React__default.createElement("div", {
    className: 'card-body p-4 mx-lg-4'
  }, connectPageContent ? React__default.createElement(React__default.Fragment, null, connectPageContent) : React__default.createElement(React__default.Fragment, null, React__default.createElement(SvgLedgerNano, {
    className: 'mb-4'
  }), React__default.createElement("h4", {
    className: 'mb-4'
  }, "Connect Ledger"), React__default.createElement("p", {
    className: 'lead mb-4'
  }, "Unlock your device & open the Elrond App.")), React__default.createElement("div", null, error && React__default.createElement("p", {
    className: 'text-danger d-flex justify-content-center align-items-center'
  }, error), React__default.createElement("button", {
    className: 'btn btn-primary px-4',
    onClick: onClick,
    "data-testid": 'connectBtn'
  }, "Connect Ledger")))));
};

var ledgerWaitingText$1 = 'Waiting for device';

function LedgerLoginContainer(_ref) {
  var callbackRoute = _ref.callbackRoute,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'login-modal-content' : _ref$className,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa,
      _ref$wrapContentInsid = _ref.wrapContentInsideModal,
      wrapContentInsideModal = _ref$wrapContentInsid === void 0 ? true : _ref$wrapContentInsid,
      redirectAfterLogin = _ref.redirectAfterLogin,
      onClose = _ref.onClose,
      token = _ref.token;
  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    spinner: 'fa-spin text-primary'
  });

  var _useGetAccountInfo = useGetAccountInfo(),
      ledgerAccount = _useGetAccountInfo.ledgerAccount;

  var _useLedgerLogin = useLedgerLogin({
    callbackRoute: callbackRoute,
    token: token,
    redirectAfterLogin: redirectAfterLogin
  }),
      onStartLogin = _useLedgerLogin[0],
      _useLedgerLogin$ = _useLedgerLogin[1],
      error = _useLedgerLogin$.error,
      isLoading = _useLedgerLogin$.isLoading,
      _useLedgerLogin$2 = _useLedgerLogin[2],
      showAddressList = _useLedgerLogin$2.showAddressList,
      accounts = _useLedgerLogin$2.accounts,
      onGoToPrevPage = _useLedgerLogin$2.onGoToPrevPage,
      onGoToNextPage = _useLedgerLogin$2.onGoToNextPage,
      onSelectAddress = _useLedgerLogin$2.onSelectAddress,
      onConfirmSelectedAddress = _useLedgerLogin$2.onConfirmSelectedAddress,
      startIndex = _useLedgerLogin$2.startIndex,
      selectedAddress = _useLedgerLogin$2.selectedAddress;

  function getContent() {
    if (isLoading) {
      return React__default.createElement(PageState$1, {
        icon: icons.faCircleNotch,
        iconClass: generatedClasses.spinner,
        title: ledgerWaitingText$1
      });
    }

    if (ledgerAccount != null && !error) {
      return React__default.createElement(ConfirmAddress, {
        token: token
      });
    }

    if (showAddressList && !error) {
      return React__default.createElement(AddressTable, {
        accounts: accounts,
        loading: isLoading,
        className: className,
        shouldRenderDefaultCss: shouldRenderDefaultCss,
        onGoToNextPage: onGoToNextPage,
        onGoToPrevPage: onGoToPrevPage,
        onSelectAddress: onSelectAddress,
        startIndex: startIndex,
        selectedAddress: selectedAddress === null || selectedAddress === void 0 ? void 0 : selectedAddress.address,
        onConfirmSelectedAddress: onConfirmSelectedAddress
      });
    }

    return React__default.createElement(LedgerConnect, {
      onClick: onStartLogin,
      error: error
    });
  }

  return wrapContentInsideModal ? React__default.createElement(ModalContainer, {
    title: 'Login with ledger',
    className: className,
    onClose: onClose
  }, getContent()) : getContent();
}

var LedgerLoginContainer$1 = withClassNameWrapper(LedgerLoginContainer);

var LedgerLoginButton = function LedgerLoginButton(_ref) {
  var token = _ref.token,
      callbackRoute = _ref.callbackRoute,
      children = _ref.children,
      _ref$loginButtonText = _ref.loginButtonText,
      loginButtonText = _ref$loginButtonText === void 0 ? 'Ledger' : _ref$loginButtonText,
      buttonClassName = _ref.buttonClassName,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'ledger-login' : _ref$className,
      _ref$redirectAfterLog = _ref.redirectAfterLogin,
      redirectAfterLogin = _ref$redirectAfterLog === void 0 ? false : _ref$redirectAfterLog,
      _ref$wrapContentInsid = _ref.wrapContentInsideModal,
      wrapContentInsideModal = _ref$wrapContentInsid === void 0 ? true : _ref$wrapContentInsid,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa;

  var _React$useState = React__default.useState(false),
      showLoginModal = _React$useState[0],
      setShowLoginModal = _React$useState[1];

  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: "btn btn-primary px-sm-4 m-1 mx-sm-3 " + (buttonClassName != null ? buttonClassName : ''),
    loginText: 'text-left'
  });

  function handleOpenModal() {
    setShowLoginModal(true);
  }

  function handleCloseModal() {
    setShowLoginModal(false);
  }

  return React__default.createElement("span", {
    className: wrapperClassName
  }, React__default.createElement("button", {
    onClick: handleOpenModal,
    className: generatedClasses.wrapper
  }, children || React__default.createElement("span", {
    className: generatedClasses.loginText
  }, loginButtonText)), showLoginModal && React__default.createElement(LedgerLoginContainer$1, {
    className: className,
    shouldRenderDefaultCss: shouldRenderDefaultCss,
    callbackRoute: callbackRoute,
    token: token,
    wrapContentInsideModal: wrapContentInsideModal,
    redirectAfterLogin: redirectAfterLogin,
    onClose: handleCloseModal
  }));
};

var LedgerLoginButton$1 = withClassNameWrapper(LedgerLoginButton);

var _notificationTypesToI;
var notificationTypesToIcons = (_notificationTypesToI = {}, _notificationTypesToI[NotificationTypesEnum.warning] = icons.faExclamationTriangle, _notificationTypesToI);
var defaultIcon = icons.faExclamationTriangle;
function NotificationModal() {
  var _useGetNotification = useGetNotification(),
      notification = _useGetNotification.notification,
      clearNotification = _useGetNotification.clearNotification;

  var showModal = Boolean(notification);

  var onDone = function onDone() {
    clearNotification();
  };

  var icon = notification ? notificationTypesToIcons[notification === null || notification === void 0 ? void 0 : notification.type] || defaultIcon : null;
  return notification ? React__default.createElement(ReactBootstrap$1.Modal, {
    show: showModal,
    backdrop: true,
    onHide: notification,
    className: "modal-container " + wrapperClassName,
    animation: false,
    centered: true
  }, React__default.createElement("div", {
    className: 'card w-100 notification-modal'
  }, React__default.createElement(PageState$1, {
    icon: icon,
    iconClass: notification.iconClassName,
    iconBgClass: 'p-4 rounded-bg-circle',
    iconSize: '3x',
    title: notification.title,
    description: notification.description,
    action: React__default.createElement("button", {
      className: 'btn btn-primary',
      onClick: onDone
    }, "Done")
  }))) : null;
}

var SignWithExtensionModal = function SignWithExtensionModal(_ref) {
  var handleClose = _ref.handleClose,
      error = _ref.error,
      callbackRoute = _ref.callbackRoute,
      transactions = _ref.transactions,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'extension-modal' : _ref$className;
  var classes = getGeneratedClasses(className, true, {
    wrapper: 'modal-container extension',
    icon: 'text-white',
    closeBtn: 'btn btn-close-link mt-2'
  });
  var description = error ? error : transactions && transactions.length > 1 ? 'Check your Elrond Wallet Extension to sign the transactions' : 'Check your Elrond Wallet Extension to sign the transaction';

  var close = function close(e) {
    e.preventDefault();
    handleClose();

    if (callbackRoute != null && !window.location.pathname.includes(callbackRoute)) {
      window.location.href = callbackRoute;
    }
  };

  return React__default.createElement(ReactBootstrap$1.Modal, {
    show: true,
    backdrop: 'static',
    onHide: handleClose,
    className: classnames$1(classes.wrapper, wrapperClassName),
    animation: false,
    centered: true
  }, React__default.createElement(PageState$1, {
    icon: error ? icons.faTimes : icons.faHourglass,
    iconClass: classes.icon,
    className: className,
    iconBgClass: error ? 'bg-danger' : 'bg-warning',
    iconSize: '3x',
    title: 'Confirm on Maiar DeFi Wallet',
    description: description,
    action: React__default.createElement("button", {
      id: 'closeButton',
      "data-testid": 'closeButton',
      onClick: close,
      className: classes.closeBtn
    }, "Close")
  }));
};

var _g$1;

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

function SvgEgld(props) {
  return /*#__PURE__*/createElement("svg", _extends$2({
    viewBox: "0 0 100 100",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _g$1 || (_g$1 = /*#__PURE__*/createElement("g", {
    fillRule: "nonzero"
  }, /*#__PURE__*/createElement("path", {
    d: "M79.6 19.424c-.4-.438-.6-.877-.6-1.425 0-.547.2-.986.6-1.424.8-.767 2-.767 2.8 0 .4.438.6.877.6 1.424 0 .548-.2.987-.6 1.425-.4.329-.9.548-1.4.548-.5.11-1-.11-1.4-.548M74.556 24.448c-.333-.441-.556-.883-.556-1.435s.223-.993.556-1.434c.778-.772 2.111-.772 2.889 0 .333.441.555.883.555 1.435s-.222.993-.555 1.434C77 24.779 76.556 25 76 25s-1-.221-1.445-.552M69.556 30.448c-.333-.331-.556-.883-.556-1.435s.223-.993.556-1.434c.778-.772 2.111-.772 2.889 0 .333.331.555.883.555 1.435s-.222.993-.555 1.434C72 30.889 71.556 31 71 31s-1.112-.221-1.445-.552M64.6 35.448c-.4-.331-.6-.883-.6-1.435s.2-.993.6-1.434c.8-.772 2-.772 2.8 0 .4.331.6.883.6 1.435s-.2 1.103-.6 1.434c-.4.441-.9.552-1.4.552s-1-.11-1.4-.552M59.556 40.424c-.444-.329-.556-.877-.556-1.425 0-.547.223-.986.556-1.424.778-.767 2.111-.767 2.889 0 .444.329.555.877.555 1.424 0 .548-.222 1.096-.555 1.425-.333.438-.889.548-1.445.548a1.457 1.457 0 01-1.444-.548M53 44.014c0-.552.222-.993.556-1.435.777-.772 2.11-.772 2.888 0 .445.442.556.883.556 1.435s-.222.993-.556 1.435c-.333.33-.888.551-1.444.551s-1-.22-1.444-.551c-.334-.332-.556-.883-.556-1.435zM43.556 56.424c-.333-.329-.556-.877-.556-1.425 0-.547.223-.986.556-1.424.778-.767 2.111-.767 2.889 0 .444.438.555.877.555 1.424 0 .548-.222.987-.555 1.425-.333.438-.889.548-1.445.548-.555.11-1-.11-1.444-.548M38.6 61.424c-.4-.329-.6-.877-.6-1.425 0-.547.2-.986.6-1.424.8-.767 2-.767 2.8 0 .4.438.6.877.6 1.424 0 .548-.2.987-.6 1.425-.4.438-.9.548-1.4.548-.5.11-1-.11-1.4-.548M33.556 66.448c-.333-.331-.556-.883-.556-1.435s.223-1.103.556-1.434c.778-.772 2.111-.772 2.889 0 .333.331.555.883.555 1.434s-.222.994-.555 1.435C36 66.889 35.556 67 35 67s-1-.221-1.444-.552M27.556 71.448c-.444-.331-.556-.883-.556-1.435s.223-.993.556-1.434c.778-.772 2.111-.772 2.889 0 .333.441.555.883.555 1.435s-.222 1.103-.555 1.434C30 71.889 29.556 72 29 72s-1.112-.11-1.445-.552M22.615 76.448c-.41-.331-.615-.883-.615-1.435s.205-.993.615-1.434c.82-.772 2.051-.772 2.77 0 .41.441.615.883.615 1.435s-.206 1.103-.616 1.434c-.41.331-.923.552-1.436.552-.513 0-1.025-.11-1.333-.552M17.556 82.424c-.444-.438-.556-.877-.556-1.425 0-.547.223-.986.556-1.424.778-.767 2.111-.767 2.889 0 .444.438.555.877.555 1.425 0 .547-.222.986-.555 1.424-.333.329-.889.548-1.444.548-.445.11-1-.11-1.445-.548M20.444 19.424c.333-.438.556-.877.556-1.425 0-.547-.223-.986-.556-1.424-.778-.767-2.111-.767-2.889 0-.444.438-.555.877-.555 1.424 0 .548.222.987.555 1.425.333.329.889.548 1.444.548.556.11 1.112-.11 1.445-.548M25.4 24.448c.4-.441.6-.883.6-1.435s-.2-.993-.6-1.434c-.8-.772-2-.772-2.8 0-.4.441-.6.883-.6 1.435s.2.993.6 1.434c.4.331.9.552 1.4.552s1-.221 1.4-.552M30.444 30.448c.333-.331.556-.883.556-1.435s-.223-.993-.556-1.434c-.778-.772-2.111-.772-2.889 0-.333.331-.555.883-.555 1.435s.222.993.555 1.434C28 30.889 28.444 31 29 31c.445 0 1-.221 1.445-.552M36.444 35.448c.333-.331.556-.883.556-1.435s-.223-.993-.556-1.434c-.778-.772-2.111-.772-2.889 0-.333.331-.555.883-.555 1.435s.222 1.103.555 1.434C34 35.889 34.444 36 35 36c.444 0 1-.11 1.444-.552M41.385 40.424c.41-.329.615-.877.615-1.425 0-.547-.205-.986-.615-1.424-.718-.767-2.051-.767-2.77 0-.41.329-.615.877-.615 1.424 0 .548.206 1.096.616 1.425.41.438.923.548 1.436.548.513.11 1.025-.11 1.333-.548M47 44.014c0-.552-.222-.993-.556-1.435-.777-.772-2.11-.772-2.888 0-.445.442-.556.883-.556 1.435s.222.993.556 1.435c.333.33.888.551 1.444.551s1-.22 1.444-.551c.445-.332.556-.883.556-1.435zM51.444 51.448c.444-.441.556-.883.556-1.435s-.223-.993-.556-1.434c-.778-.772-2.111-.772-2.889 0-.444.441-.555.883-.555 1.435s.222.993.555 1.434c.333.331.889.552 1.445.552s1.11-.221 1.444-.552M56.385 56.424c.41-.329.615-.877.615-1.425 0-.547-.205-.986-.615-1.424-.82-.767-2.051-.767-2.77 0-.41.438-.615.877-.615 1.424 0 .548.206.987.616 1.425.41.438.923.548 1.436.548.41.11.923-.11 1.333-.548M62.444 61.424c.333-.329.556-.877.556-1.425 0-.547-.223-.986-.556-1.424-.778-.767-2.111-.767-2.889 0-.333.438-.555.877-.555 1.424 0 .548.222.987.555 1.425.445.438.889.548 1.445.548.444.11 1-.11 1.444-.548M67.444 66.448c.333-.331.556-.883.556-1.435s-.223-1.103-.556-1.434c-.778-.772-2.111-.772-2.889 0-.333.331-.555.883-.555 1.434s.222.994.555 1.435C65 66.889 65.444 67 66 67s1-.221 1.445-.552M72.444 71.448c.444-.331.556-.883.556-1.435s-.223-.993-.556-1.434c-.778-.772-2.111-.772-2.889 0-.333.441-.555.883-.555 1.435s.222 1.103.555 1.434C70 71.889 70.444 72 71 72s1.112-.11 1.445-.552M77.444 76.448c.444-.331.556-.883.556-1.435s-.223-.993-.556-1.434c-.778-.772-2.111-.772-2.889 0-.444.441-.555.883-.555 1.435s.222 1.103.555 1.434c.333.331.889.552 1.444.552s1.112-.11 1.445-.552M82.385 82.424c.41-.438.615-.877.615-1.425 0-.547-.205-.986-.615-1.424-.82-.767-2.051-.767-2.77 0-.41.438-.615.877-.615 1.425 0 .547.206.986.616 1.424.41.329.923.548 1.436.548.41.11.923-.11 1.333-.548M33.036 21c5.265-3.433 11.036-5.048 17.414-5.149 6.277 0 12.048 1.716 17.414 5.149L79.001 9.894C70.294 3.331 60.878 0 50.45 0 40.022 0 30.505 3.332 22.001 9.894L33.037 21zM21 66.742c-3.585-5.375-5.327-11.157-5.327-17.343 0-6.288 1.742-12.069 5.327-17.343L9.834 21.001C3.278 29.521 0 38.953 0 49.501c0 10.345 3.278 19.879 9.937 28.5L21 66.743zM67.964 78c-5.265 3.533-11.036 5.35-17.313 5.451-6.378 0-12.25-1.716-17.515-5.35L21.999 89.105c8.606 6.663 18.123 9.994 28.652 9.893 10.428-.1 19.844-3.432 28.348-9.893L67.963 78zM79 32.258c3.533 5.375 5.35 11.258 5.25 17.648-.102 6.187-1.818 11.867-5.25 17.039L90.105 78c6.562-8.52 9.893-17.952 9.893-28.297.101-10.548-3.23-20.082-9.893-28.703L79 32.258zM90 81c4.364 0 8 3.533 8 8 0 4.364-3.533 8-8 8-4.364 0-8-3.533-8-8s3.533-8 8-8M10 81c4.421 0 8 3.533 8 8 0 4.364-3.579 8-8 8-4.421 0-8-3.533-8-8s3.579-8 8-8M90 1c4.421 0 8 3.533 8 8 0 4.468-3.579 8-8 8s-8-3.533-8-8c0-4.468 3.579-8 8-8M10 1c4.364 0 8 3.579 8 8 0 4.421-3.533 8-8 8-4.364 0-8-3.579-8-8 0-4.421 3.533-8 8-8"
  }))));
}

var Simple = function Simple(_ref) {
  var children = _ref.children;
  return createElement("div", {
    className: 'token-symbol'
  }, children);
};
var Combined = function Combined(_ref2) {
  var small = _ref2.small,
      children = _ref2.children;
  return createElement("div", {
    className: "token-symbol-combined " + (small ? 'small' : '')
  }, children);
};

var getIdentifierWithoutNonce = function getIdentifierWithoutNonce(identifier) {
  var tokenParts = identifier.split('-');
  return identifier.includes('-') ? tokenParts[0] + "-" + tokenParts[1] : identifier;
};

var getDetails = function getDetails(token) {
  var egldLabel = getEgldLabel();
  var isEgldTransfer = token === egldLabel;
  return {
    token: token,
    symbol: token ? token.split('-')[0] : '',
    label: token,
    icon: function icon() {
      return isEgldTransfer ? createElement(SvgEgld, null) : createElement(ReactFontawesome$1.FontAwesomeIcon, {
        icon: icons.faGem
      });
    }
  };
};

var TokenDetails = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TokenDetails, _React$Component);

  function TokenDetails() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = TokenDetails.prototype;

  _proto.render = function render() {
    return null;
  };

  return TokenDetails;
}(Component);

TokenDetails.Token = function (props) {
  return createElement(Fragment, null, props.token);
};

TokenDetails.Symbol = function (props) {
  return createElement(Fragment, null, getDetails(getIdentifierWithoutNonce(props.token)).symbol);
};

TokenDetails.Label = function (props) {
  return createElement(Fragment, null, getDetails(getIdentifierWithoutNonce(props.token)).label);
};

TokenDetails.Icon = function (props) {
  var Component = process.env.NODE_ENV !== 'test' ? getDetails(getIdentifierWithoutNonce(props.token)).icon : function () {
    return null;
  };
  return createElement("span", {
    className: wrapperClassName
  }, props.combined ? createElement(Combined, {
    small: props.small
  }, createElement(Component, null)) : createElement(Simple, null, createElement(Component, null)));
};

var allOccurences = function allOccurences(sourceStr, searchStr) {
  return [].concat(sourceStr.matchAll(new RegExp(searchStr, 'gi'))).map(function (a) {
    return a.index;
  });
};

var TransactionData = function TransactionData(_ref) {
  var data = _ref.data,
      highlight = _ref.highlight,
      isScCall = _ref.isScCall;
  var output = createElement(Fragment, null, data);

  var _ref2 = highlight && isScCall ? highlight.split('@') : [],
      encodedScCall = _ref2[0],
      remainingDataFields = _ref2.slice(1);

  if (data && highlight && allOccurences(data, highlight).length === 1) {
    switch (true) {
      case data.startsWith(highlight):
        {
          var _data$split = data.split(highlight),
              rest = _data$split[1];

          output = createElement(Fragment, null, highlight, createElement("span", {
            className: 'text-muted'
          }, rest));
          break;
        }

      case data.endsWith(highlight):
        {
          var _data$split2 = data.split(highlight),
              _rest = _data$split2[0];

          output = createElement(Fragment, null, createElement("span", {
            className: 'text-muted'
          }, _rest), highlight);
          break;
        }

      default:
        {
          var _data$split3 = data.split(highlight),
              start = _data$split3[0],
              end = _data$split3[1];

          output = createElement(Fragment, null, createElement("span", {
            className: 'text-muted'
          }, start), createElement("span", {
            className: 'highlighted'
          }, highlight), createElement("span", {
            className: 'text-muted'
          }, end));
          break;
        }
    }
  }

  return createElement(Fragment, null, encodedScCall && createElement("div", {
    className: 'form-group mb-0 data-field mw-100'
  }, createElement("span", {
    className: 'form-label text-secondary d-block'
  }, "SC Call"), createElement("div", {
    "data-testid": 'confirmScCall',
    className: 'textarea sc-call form-control cursor-text mt-1 text-break-all'
  }, [decodePart(encodedScCall)].concat(remainingDataFields).join('@'))), createElement("div", {
    className: 'form-group mb-0 data-field mw-100'
  }, createElement("span", {
    className: 'form-label text-secondary d-block'
  }, "Data"), createElement("div", {
    "data-testid": 'confirmData',
    className: 'textarea form-control cursor-text mt-1 text-break-all'
  }, data ? output : 'N/A')));
};

var TransactionData$1 = withClassNameWrapper(TransactionData);

var SignStep = function SignStep(_ref) {
  var onSignTransaction = _ref.onSignTransaction,
      handleClose = _ref.handleClose,
      onPrev = _ref.onPrev,
      waitingForDevice = _ref.waitingForDevice,
      currentTransaction = _ref.currentTransaction,
      error = _ref.error,
      isLastTransaction = _ref.isLastTransaction,
      currentStep = _ref.currentStep,
      className = _ref.className;
  var egldLabel = getEgldLabel();
  var transactionData = currentTransaction.transaction.getData().toString();

  var _useGetNetworkConfig = useGetNetworkConfig(),
      network = _useGetNetworkConfig.network;

  var _currentTransaction$t = currentTransaction.transactionTokenInfo,
      tokenId = _currentTransaction$t.tokenId,
      amount = _currentTransaction$t.amount,
      type = _currentTransaction$t.type,
      multiTxData = _currentTransaction$t.multiTxData,
      receiver = _currentTransaction$t.receiver;
  var isTokenTransaction = Boolean(tokenId && isTokenTransfer({
    tokenId: tokenId,
    erdLabel: egldLabel
  }));

  var onCloseClick = function onCloseClick(e) {
    e.preventDefault();

    if (isFirst) {
      handleClose();
    } else {
      onPrev();
    }
  };

  var continueWithoutSigning = type && multiTxData && !transactionData.endsWith(multiTxData);
  var signBtnLabel = 'Sign & Continue';
  signBtnLabel = waitingForDevice ? 'Check your Ledger' : signBtnLabel;
  signBtnLabel = isLastTransaction && !waitingForDevice ? 'Sign & Submit' : signBtnLabel;
  signBtnLabel = continueWithoutSigning ? 'Continue' : signBtnLabel;
  var isFirst = currentStep === 0;

  var _useGetTokenDetails = useGetTokenDetails({
    tokenId: currentTransaction.transactionTokenInfo.tokenId
  }),
      tokenDenomination = _useGetTokenDetails.tokenDenomination;

  var denominatedAmount = denominate({
    input: isTokenTransaction ? amount : currentTransaction.transaction.getValue().toString(),
    denomination: isTokenTransaction ? tokenDenomination : Number(network.egldDenomination),
    decimals: Number(network.decimals),
    showLastNonZeroDecimal: false,
    addCommas: true
  });
  var classes = getGeneratedClasses(className, true, {
    formGroup: 'form-group text-left',
    formLabel: 'form-label text-secondary',
    icon: 'text-white',
    contentWrapper: 'd-flex flex-column justify-content-start flex-md-row justify-content-md-between mb-3',
    tokenWrapper: 'mb-3 mb-md-0 d-flex flex-column align-items-start',
    tokenLabel: 'text-secondary text-left',
    tokenValue: 'd-flex align-items-center mt-1',
    tokenAmountLabel: 'text-secondary text-left',
    tokenAmountValue: 'd-flex align-items-center',
    dataFormGroup: 'form-group text-left',
    errorMessage: 'text-danger d-flex justify-content-center align-items-center',
    buttonsWrapper: 'd-flex align-items-center justify-content-end mt-spacer',
    cancelButton: 'btn btn-dark text-white flex-even mr-2',
    signButton: 'btn btn-primary flex-even ml-2'
  });
  return React__default.createElement(PageState$1, {
    icon: error ? icons.faTimes : icons.faHourglass,
    iconClass: classes.icon,
    iconBgClass: error ? 'bg-danger' : 'bg-warning',
    iconSize: '3x',
    className: className,
    title: 'Confirm on Ledger',
    description: React__default.createElement(React__default.Fragment, null, currentTransaction.transaction && React__default.createElement(React__default.Fragment, null, React__default.createElement("div", {
      className: classes.formGroup,
      "data-testid": 'transactionTitle'
    }, React__default.createElement("div", {
      className: classes.formLabel
    }, "To: "), multiTxData ? new Address$1(receiver).bech32() : currentTransaction.transaction.getReceiver().toString()), React__default.createElement("div", {
      className: classes.contentWrapper
    }, React__default.createElement("div", {
      className: classes.tokenWrapper
    }, React__default.createElement("div", {
      className: classes.tokenlabel
    }, "Token"), React__default.createElement("div", {
      className: classes.tokenValue
    }, React__default.createElement(TokenDetails.Icon, {
      token: tokenId || egldLabel
    }), React__default.createElement("div", {
      className: 'mr-1'
    }), React__default.createElement(TokenDetails.Label, {
      token: tokenId || egldLabel
    }))), React__default.createElement("div", null, React__default.createElement("div", {
      className: classes.tokenAmountLabel
    }, "Amount"), React__default.createElement("div", {
      className: classes.tokenAmountValue
    }, React__default.createElement("div", {
      className: 'mr-1'
    }, denominatedAmount), React__default.createElement(TokenDetails.Symbol, {
      token: tokenId || egldLabel
    })))), React__default.createElement("div", {
      className: classes.dataFormGroup
    }, currentTransaction.transaction.getData() && React__default.createElement(TransactionData$1, Object.assign({}, {
      data: currentTransaction.transaction.getData().toString(),
      highlight: multiTxData,
      isScCall: !tokenId
    }))), error && React__default.createElement("p", {
      className: classes.errorMessage
    }, error))),
    action: React__default.createElement("div", {
      className: classes.buttonsWrapper
    }, React__default.createElement("button", {
      id: 'closeButton',
      "data-testid": 'closeButton',
      onClick: onCloseClick,
      className: classes.cancelButton
    }, isFirst ? 'Cancel' : 'Back'), React__default.createElement("button", {
      type: 'button',
      className: classes.signButton,
      id: 'signBtn',
      "data-testid": 'signBtn',
      onClick: onSignTransaction,
      disabled: waitingForDevice
    }, signBtnLabel))
  });
};

var SignWithLedgerModal = function SignWithLedgerModal(_ref) {
  var handleClose = _ref.handleClose,
      error = _ref.error,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'ledger-modal' : _ref$className;

  var _useSignTransactionsW = useSignTransactionsWithLedger({
    onCancel: handleClose
  }),
      onSignTransaction = _useSignTransactionsW.onSignTransaction,
      onNext = _useSignTransactionsW.onNext,
      onPrev = _useSignTransactionsW.onPrev,
      allTransactions = _useSignTransactionsW.allTransactions,
      waitingForDevice = _useSignTransactionsW.waitingForDevice,
      onAbort = _useSignTransactionsW.onAbort,
      isLastTransaction = _useSignTransactionsW.isLastTransaction,
      currentStep = _useSignTransactionsW.currentStep,
      callbackRoute = _useSignTransactionsW.callbackRoute,
      currentTransaction = _useSignTransactionsW.currentTransaction;

  var classes = getGeneratedClasses(className, true, {
    wrapper: 'modal-container wallet-connect',
    container: 'card container',
    cardBody: 'card-body'
  });
  return React__default.createElement(ReactBootstrap$1.Modal, {
    show: currentTransaction != null,
    backdrop: 'static',
    onHide: handleClose,
    className: classnames$1(classes.wrapper, wrapperClassName),
    animation: false,
    centered: true
  }, React__default.createElement("div", {
    className: classes.container
  }, React__default.createElement("div", {
    className: classes.cardBody
  }, React__default.createElement(SignStep, Object.assign({}, {
    onSignTransaction: onSignTransaction,
    onNext: onNext,
    onPrev: onPrev,
    allTransactions: allTransactions,
    waitingForDevice: waitingForDevice,
    isLastTransaction: isLastTransaction,
    currentStep: currentStep,
    callbackRoute: callbackRoute,
    currentTransaction: currentTransaction,
    handleClose: onAbort,
    className: className,
    error: error
  })))));
};

var SignWithWalletConnectModal = function SignWithWalletConnectModal(_ref) {
  var error = _ref.error,
      handleClose = _ref.handleClose,
      callbackRoute = _ref.callbackRoute,
      transactions = _ref.transactions,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'wallet-connect-modal' : _ref$className;
  var classes = getGeneratedClasses(className, true, {
    wrapper: 'modal-container wallet-connect',
    icon: 'text-white',
    closeBtn: 'btn btn-close-link mt-2'
  });
  var hasMultipleTransactions = transactions && (transactions === null || transactions === void 0 ? void 0 : transactions.length) > 1;
  var description = error ? error : "Check your phone to sign the transaction" + (hasMultipleTransactions ? 's' : '');

  var close = function close(e) {
    e.preventDefault();
    handleClose();

    if (callbackRoute != null && !window.location.pathname.includes(callbackRoute)) {
      window.location.href = callbackRoute;
    }
  };

  return React__default.createElement(ReactBootstrap$1.Modal, {
    show: true,
    backdrop: 'static',
    onHide: close,
    className: classnames$1(classes.wrapper, wrapperClassName),
    animation: false,
    centered: true
  }, React__default.createElement(PageState$1, {
    icon: error ? icons.faTimes : icons.faHourglass,
    iconClass: classes.icon,
    className: className,
    iconBgClass: error ? 'bg-danger' : 'bg-warning',
    iconSize: '3x',
    title: 'Confirm on Maiar',
    description: description,
    action: React__default.createElement("button", {
      id: 'closeButton',
      "data-testid": 'closeButton',
      onClick: close,
      className: classes.closeBtn
    }, "Close")
  }));
};

function SignTransactionsModals(_ref) {
  var _CustomConfirmScreens, _CustomConfirmScreens2, _CustomConfirmScreens3, _CustomConfirmScreens4;

  var className = _ref.className,
      CustomConfirmScreens = _ref.CustomConfirmScreens;

  var _useSignTransactions = useSignTransactions(),
      callbackRoute = _useSignTransactions.callbackRoute,
      transactions = _useSignTransactions.transactions,
      error = _useSignTransactions.error,
      sessionId = _useSignTransactions.sessionId,
      onAbort = _useSignTransactions.onAbort,
      hasTransactions = _useSignTransactions.hasTransactions;

  var _useGetAccountProvide = useGetAccountProvider(),
      providerType = _useGetAccountProvide.providerType;

  var signTransactionsError = useGetSignTransactionsError();

  var handleClose = function handleClose() {
    onAbort(sessionId);
  };

  var signError = error || signTransactionsError;
  var signProps = {
    handleClose: handleClose,
    error: signError,
    sessionId: sessionId,
    transactions: transactions,
    providerType: providerType,
    callbackRoute: callbackRoute,
    className: className
  };
  return signError || hasTransactions ? React__default.createElement(React__default.Fragment, null, getIsProviderEqualTo(LoginMethodsEnum.ledger) && ((CustomConfirmScreens === null || CustomConfirmScreens === void 0 ? void 0 : (_CustomConfirmScreens = CustomConfirmScreens.Ledger) === null || _CustomConfirmScreens === void 0 ? void 0 : _CustomConfirmScreens.call(CustomConfirmScreens, signProps)) || React__default.createElement(SignWithLedgerModal, Object.assign({}, signProps))), getIsProviderEqualTo(LoginMethodsEnum.walletconnect) && ((CustomConfirmScreens === null || CustomConfirmScreens === void 0 ? void 0 : (_CustomConfirmScreens2 = CustomConfirmScreens.WalletConnect) === null || _CustomConfirmScreens2 === void 0 ? void 0 : _CustomConfirmScreens2.call(CustomConfirmScreens, signProps)) || React__default.createElement(SignWithWalletConnectModal, Object.assign({}, signProps))), getIsProviderEqualTo(LoginMethodsEnum.extension) && ((CustomConfirmScreens === null || CustomConfirmScreens === void 0 ? void 0 : (_CustomConfirmScreens3 = CustomConfirmScreens.Extension) === null || _CustomConfirmScreens3 === void 0 ? void 0 : _CustomConfirmScreens3.call(CustomConfirmScreens, signProps)) || React__default.createElement(SignWithExtensionModal, Object.assign({}, signProps))), getIsProviderEqualTo(LoginMethodsEnum.extra) && (CustomConfirmScreens === null || CustomConfirmScreens === void 0 ? void 0 : (_CustomConfirmScreens4 = CustomConfirmScreens.Extra) === null || _CustomConfirmScreens4 === void 0 ? void 0 : _CustomConfirmScreens4.call(CustomConfirmScreens, signProps))) : null;
}

var index$3 = withClassNameWrapper(SignTransactionsModals);

var SessionStorageKeysEnum;

(function (SessionStorageKeysEnum) {
  SessionStorageKeysEnum["toasts"] = "toasts";
})(SessionStorageKeysEnum || (SessionStorageKeysEnum = {}));

function setToastsIdsToStorage(ids) {
  return sessionStorage.setItem(SessionStorageKeysEnum.toasts, JSON.stringify(ids));
}
function getToastsIdsFromStorage() {
  var toastsIds = sessionStorage.getItem(SessionStorageKeysEnum.toasts);
  return toastsIds != null ? JSON.parse(toastsIds) : [];
}

function isCrossShardTransaction(_ref) {
  var receiverAddress = _ref.receiverAddress,
      senderShard = _ref.senderShard,
      senderAddress = _ref.senderAddress;

  try {
    var receiver = new Address$1(receiverAddress);
    var receiverShard = getShardOfAddress(receiver.pubkey());

    if (senderShard == null && senderAddress != null) {
      var sender = new Address$1(senderAddress);
      return getShardOfAddress(sender) === receiverShard;
    }

    return receiverShard === senderShard;
  } catch (err) {
    return false;
  }
}

var IconState = function IconState(_ref) {
  var icon = _ref.icon,
      _ref$iconSize = _ref.iconSize,
      iconSize = _ref$iconSize === void 0 ? '3x' : _ref$iconSize,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'icon-state' : _ref$className,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa;
  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: classnames$1('icon-state mx-auto', className, {
      half: iconSize === '2x'
    }),
    icon: classnames$1('text-white', className)
  });
  return React__default.createElement("span", {
    className: generatedClasses.wrapper
  }, React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
    icon: icon,
    size: iconSize,
    className: generatedClasses.icon
  }));
};

var IconState$1 = withClassNameWrapper(IconState);

var Progress = function Progress(_ref) {
  var id = _ref.id,
      children = _ref.children,
      progress = _ref.progress,
      done = _ref.done;
  var ref = React__default.useRef(null);
  var intervalRef = React__default.useRef();

  var removeTxFromSession = function removeTxFromSession() {
    var toastProgress = storage.getItem('toastProgress');
    var hasSessionStoredTx = Boolean(toastProgress[id]);

    if (!hasSessionStoredTx) {
      return;
    }

    var expires = moment$1().add(10, 'minutes').unix();
    delete toastProgress[id];
    storage.setItem({
      key: 'toastProgress',
      data: toastProgress,
      expires: expires
    });
  };

  var saveToSession = function saveToSession(_ref2) {
    var value = _ref2.value;
    var toastProgress = storage.getItem('toastProgress') || {};
    toastProgress[id] = value;
    storage.setItem({
      key: 'toastProgress',
      data: toastProgress,
      expires: moment$1().add(10, 'minutes').unix()
    });
  };

  var getInitialData = function getInitialData() {
    var totalSeconds = progress ? progress.endTime - progress.startTime : 0;
    var toastProgress = storage.getItem('toastProgress');
    var remaining = progress ? (progress.endTime - moment$1().unix()) * 100 / totalSeconds : 0;
    var currentRemaining = toastProgress && id in toastProgress ? toastProgress[id] : remaining;
    return {
      currentRemaining: currentRemaining,
      totalSeconds: totalSeconds
    };
  };

  var _getInitialData = getInitialData(),
      totalSeconds = _getInitialData.totalSeconds,
      currentRemaining = _getInitialData.currentRemaining;

  var _React$useState = React__default.useState(currentRemaining),
      percentRemaining = _React$useState[0],
      setPercentRemaining = _React$useState[1];

  React__default.useEffect(function () {
    if (progress) {
      var maxPercent = 90;
      var perc = totalSeconds / maxPercent;

      var _int = moment$1.duration(perc.toFixed(2), 's').asMilliseconds();

      if (done) {
        intervalRef.current = setInterval(function () {
          if (ref.current !== null) {
            setPercentRemaining(function (existing) {
              var value = existing - 1;

              if (value <= 0) {
                clearInterval(intervalRef.current);
                removeTxFromSession();
                return 0;
              } else {
                saveToSession({
                  value: value
                });
                return value;
              }
            });
          }
        }, 5);
      } else {
        intervalRef.current = setInterval(function () {
          if (ref.current !== null) {
            setPercentRemaining(function (existing) {
              var decrement = existing > 100 - maxPercent ? 1 : logarithmicRest(existing);
              var value = existing - decrement;
              saveToSession({
                value: value
              });
              return value;
            });
          }
        }, _int);
      }

      return function () {
        clearInterval(intervalRef.current);
      };
    }

    return;
  }, [progress, done]);
  return progress ? React__default.createElement("div", {
    className: 'progress position-relative',
    ref: ref
  }, React__default.createElement("div", {
    className: 'progress-bar',
    role: 'progressbar',
    style: {
      width: percentRemaining + "%"
    },
    "aria-valuenow": percentRemaining,
    "aria-valuemin": 0,
    "aria-valuemax": 100
  }, React__default.createElement("div", {
    className: 'content-height'
  }, children)), React__default.createElement("div", {
    className: 'd-flex position-absolute w-100'
  }, children)) : React__default.createElement(React__default.Fragment, null, children);
};

var Progress$1 = withClassNameWrapper(Progress);

function fallbackCopyTextToClipboard(text) {
  var success = false;
  var textArea = document.createElement('textarea');
  textArea.value = text;
  textArea.style.position = 'fixed';
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();

  try {
    document.execCommand('copy');
    success = true;
  } catch (err) {
    console.error('Fallback: Oops, unable to copy', err);
  }

  document.body.removeChild(textArea);
  return success;
}

var copyTextToClipboard = function copyTextToClipboard(text) {
  try {
    var success = false;

    var _temp = function () {
      if (!navigator.clipboard) {
        success = fallbackCopyTextToClipboard(text);
      } else {
        return Promise.resolve(navigator.clipboard.writeText(text).then(function done() {
          return true;
        }, function error(err) {
          console.error('Async: Could not copy text: ', err);
          return false;
        })).then(function (_navigator$clipboard$) {
          success = _navigator$clipboard$;
        });
      }
    }();

    return Promise.resolve(_temp && _temp.then ? _temp.then(function () {
      return success;
    }) : success);
  } catch (e) {
    return Promise.reject(e);
  }
};

var CopyButton = function CopyButton(_ref) {
  var text = _ref.text,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className;

  var _React$useState = React__default.useState({
    "default": true,
    success: false
  }),
      copyResult = _React$useState[0],
      setCopyResut = _React$useState[1];

  var handleCopyToClipboard = function handleCopyToClipboard(e) {
    try {
      e.preventDefault();
      e.stopPropagation();
      var noSpaces = text ? text.trim() : text;
      return Promise.resolve(copyTextToClipboard(noSpaces)).then(function (_copyTextToClipboard) {
        setCopyResut({
          "default": false,
          success: _copyTextToClipboard
        });
        setTimeout(function () {
          setCopyResut({
            "default": true,
            success: false
          });
        }, 1000);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return React__default.createElement("a", {
    href: '/#',
    onClick: handleCopyToClipboard,
    className: "side-action text-secondary " + className
  }, copyResult["default"] || !copyResult.success ? React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
    icon: icons.faCopy
  }) : React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
    icon: icons.faCheck,
    className: 'text-primary-highlight'
  }));
};

var CopyButton$1 = withClassNameWrapper(CopyButton);

var Trim = function Trim(_ref) {
  var text = _ref.text,
      _ref$dataTestId = _ref.dataTestId,
      dataTestId = _ref$dataTestId === void 0 ? '' : _ref$dataTestId;

  var _React$useState = React__default.useState(false),
      overflow = _React$useState[0],
      setOverflow = _React$useState[1];

  var trimRef = React__default.useRef(document.createElement('span'));
  var hiddenTextRef = React__default.useRef(document.createElement('span'));
  var listener = useCallback(debounce(function () {
    if (trimRef.current && hiddenTextRef.current) {
      var diff = hiddenTextRef.current.offsetWidth - trimRef.current.offsetWidth;
      setOverflow(diff > 1);
    }
  }, 300), []);

  var addWindowResizeListener = function addWindowResizeListener() {
    window.addEventListener('resize', listener);
    return function () {
      window.removeEventListener('resize', listener);
    };
  };

  React__default.useEffect(addWindowResizeListener);
  React__default.useEffect(function () {
    listener();
  }, []);
  return React__default.createElement("span", {
    ref: trimRef,
    className: "trim " + (overflow ? 'overflow' : ''),
    "data-testid": dataTestId
  }, React__default.createElement("span", {
    ref: hiddenTextRef,
    className: 'hidden-text-ref'
  }, text), overflow ? React__default.createElement(React__default.Fragment, null, React__default.createElement("span", {
    className: 'left'
  }, React__default.createElement("span", null, String(text).substring(0, Math.floor(text.length / 2)))), React__default.createElement("span", {
    className: 'ellipsis'
  }, "..."), React__default.createElement("span", {
    className: 'right'
  }, React__default.createElement("span", null, String(text).substring(Math.ceil(text.length / 2))))) : React__default.createElement("span", null, text));
};

var Trim$1 = withClassNameWrapper(Trim);

var TxDetails = function TxDetails(_ref) {
  var title = _ref.title,
      transactions = _ref.transactions,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'tx-details' : _ref$className,
      _ref$isTimedOut = _ref.isTimedOut,
      isTimedOut = _ref$isTimedOut === void 0 ? false : _ref$isTimedOut,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa;
  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    title: 'mb-0',
    statusTransactions: 'mb-2 mt-1',
    iconSuccess: 'mr-1 text-secondary',
    iconFailed: 'mr-1 text-secondary',
    trimContainer: 'text-nowrap trim-fs-sm mr-3',
    iconPending: 'mr-1 text-secondary fa-spin slow-spin',
    item: 'tx-description d-flex justify-content-start align-items-center'
  });
  var iconSuccessData = {
    icon: icons.faCheck,
    classNames: generatedClasses.iconSuccess
  };
  var iconFailedData = {
    icon: icons.faTimes,
    classNames: generatedClasses.iconSuccess
  };
  var iconPendingData = {
    icon: icons.faSpinner,
    classNames: generatedClasses.iconPending
  };
  var iconData = {
    pending: iconPendingData,
    success: iconSuccessData,
    completed: iconSuccessData,
    fail: iconFailedData,
    invalid: iconFailedData,
    timedOut: iconFailedData
  };
  return React__default.createElement(React__default.Fragment, null, title && React__default.createElement("div", {
    className: generatedClasses.title
  }, title), React__default.createElement("div", {
    className: generatedClasses.statusTransactions
  }, transactions.filter(function (tx) {
    return !isServerTransactionPending(tx.status);
  }).length, ' ', "/ ", transactions.length, " transactions processed"), transactions.map(function (_ref2) {
    var hash = _ref2.hash,
        status = _ref2.status;
    var iconSrc = iconData[status];
    return React__default.createElement("div", {
      className: generatedClasses.item,
      key: hash
    }, !isTimedOut && iconSrc != null && React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
      icon: iconSrc.icon,
      className: iconSrc.classNames
    }), React__default.createElement("span", {
      className: generatedClasses.trimContainer,
      style: {
        width: '10rem'
      }
    }, React__default.createElement(Trim$1, {
      text: hash
    })), React__default.createElement(CopyButton$1, {
      text: hash
    }), !isServerTransactionPending(status) && React__default.createElement(ExplorerLink$1, {
      page: "/transactions/" + hash,
      className: 'ml-2'
    }));
  }));
};

var TxDetails$1 = withClassNameWrapper(TxDetails);

var averageTxDurationMs = 6000;
var crossShardRounds = 5;

var TransactionToast = function TransactionToast(_ref) {
  var toastId = _ref.toastId,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? '' : _ref$title,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'transaction-toast' : _ref$className,
      _ref$withTxNonce = _ref.withTxNonce,
      withTxNonce = _ref$withTxNonce === void 0 ? false : _ref$withTxNonce,
      transactions = _ref.transactions,
      status = _ref.status,
      onClose = _ref.onClose;
  var ref = useRef(null);

  var _useState = useState(true),
      shouldRender = _useState[0],
      setShouldRender = _useState[1];

  var transactionDisplayInfo = useGetTransactionDisplayInfo(toastId);
  var accountShard = useSelector(shardSelector);
  var _transactionDisplayIn = transactionDisplayInfo.errorMessage,
      errorMessage = _transactionDisplayIn === void 0 ? 'Transaction failed' : _transactionDisplayIn,
      _transactionDisplayIn2 = transactionDisplayInfo.timedOutMessage,
      timedOutMessage = _transactionDisplayIn2 === void 0 ? 'Transaction timed out' : _transactionDisplayIn2,
      _transactionDisplayIn3 = transactionDisplayInfo.successMessage,
      successMessage = _transactionDisplayIn3 === void 0 ? 'Transaction successful' : _transactionDisplayIn3,
      _transactionDisplayIn4 = transactionDisplayInfo.processingMessage,
      processingMessage = _transactionDisplayIn4 === void 0 ? 'Processing transaction' : _transactionDisplayIn4;
  var isSameShard = useMemo(function () {
    return transactions.reduce(function (prevTxIsSameShard, _ref2) {
      var receiver = _ref2.receiver,
          data = _ref2.data;
      var receiverAddress = getAddressFromDataField({
        receiver: receiver,
        data: data
      });

      if (receiverAddress == null) {
        return prevTxIsSameShard;
      }

      return prevTxIsSameShard && isCrossShardTransaction({
        receiverAddress: receiverAddress,
        senderShard: accountShard
      });
    }, true);
  }, [transactions, accountShard]);
  var shardAdjustedDuration = isSameShard ? averageTxDurationMs : crossShardRounds * averageTxDurationMs;
  var transactionDuration = (transactionDisplayInfo === null || transactionDisplayInfo === void 0 ? void 0 : transactionDisplayInfo.transactionDuration) || shardAdjustedDuration;
  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    toastFooter: 'mb-0 text-break',
    details: 'media-body flex-grow-1',
    toastContainer: 'w-100 media p-2',
    wrapper: 'toast-visible clickable',
    toastHeader: 'd-flex justify-content-between mb-1',
    iconContainer: 'align-self-center ml-2 mr-2 pr-1',
    title: 'm-0 font-weight-normal text-nowrap text-truncate',
    closeButton: 'close d-flex side-action align-items-center mx-2 outline-0'
  });

  var _useMemo = useMemo(function () {
    var startTime = moment$1().unix();
    var endTime = moment$1().add(Number(transactionDuration), 'milliseconds').unix();
    return [startTime, endTime];
  }, []),
      startTime = _useMemo[0],
      endTime = _useMemo[1];

  var progress = {
    startTime: startTime,
    endTime: endTime
  };
  var successToastData = {
    id: toastId,
    icon: icons.faCheck,
    expires: 30000,
    hasCloseButton: true,
    title: successMessage,
    iconClassName: 'bg-success'
  };
  var pendingToastData = {
    id: toastId,
    expires: false,
    icon: icons.faHourglass,
    hasCloseButton: false,
    title: processingMessage,
    iconClassName: 'bg-warning'
  };
  var failToastData = {
    id: toastId,
    icon: icons.faTimes,
    title: errorMessage,
    hasCloseButton: true,
    iconClassName: 'bg-danger'
  };
  var timedOutToastData = {
    id: toastId,
    icon: icons.faTimes,
    title: timedOutMessage,
    hasCloseButton: true,
    iconClassName: 'bg-warning'
  };
  var isPending = getIsTransactionPending(status);
  var isTimedOut = getIsTransactionTimedOut(status);
  var toatsOptionsData = {
    signed: pendingToastData,
    sent: pendingToastData,
    pending: pendingToastData,
    success: successToastData,
    completed: successToastData,
    cancelled: failToastData,
    fail: failToastData,
    timedOut: timedOutToastData
  };
  var toastDataState = toatsOptionsData[status];

  var handleDeleteToast = function handleDeleteToast() {
    setShouldRender(false);
    onClose === null || onClose === void 0 ? void 0 : onClose(toastId);
  };

  if (!shouldRender || transactions == null) {
    return null;
  }

  return React__default.createElement(ReactBootstrap$1.Toast, {
    ref: ref,
    className: generatedClasses.wrapper,
    key: toastId
  }, React__default.createElement(Progress$1, {
    key: toastId,
    id: toastId,
    progress: progress,
    done: !isPending || isTimedOut
  }, React__default.createElement("div", {
    className: generatedClasses.toastContainer
  }, React__default.createElement("div", {
    className: generatedClasses.iconContainer
  }, React__default.createElement(IconState$1, {
    iconSize: '2x',
    icon: toastDataState.icon,
    className: toastDataState.iconClassName
  }), withTxNonce && transactions.map(function (tx) {
    return React__default.createElement("p", {
      key: tx.nonce.valueOf()
    }, tx.nonce.valueOf());
  })), React__default.createElement("div", {
    className: generatedClasses.details,
    style: {
      minWidth: 0
    }
  }, React__default.createElement("div", {
    className: generatedClasses.toastHeader
  }, React__default.createElement("h5", {
    className: generatedClasses.title
  }, toastDataState.title), !isPending && React__default.createElement("button", {
    type: 'button',
    className: generatedClasses.closeButton,
    onClick: handleDeleteToast
  }, React__default.createElement(ReactFontawesome$1.FontAwesomeIcon, {
    icon: icons.faTimes,
    size: 'xs'
  }))), React__default.createElement("div", {
    className: generatedClasses.toastFooter
  }, React__default.createElement(TxDetails$1, {
    transactions: transactions,
    title: title,
    isTimedOut: isTimedOut
  }))))));
};

var TransactionToast$1 = withClassNameWrapper(TransactionToast);

function TransactionsToastList(_ref) {
  var _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa,
      _ref$withTxNonce = _ref.withTxNonce,
      withTxNonce = _ref$withTxNonce === void 0 ? false : _ref$withTxNonce,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'transactions-toast-list' : _ref$className,
      pendingTransactions = _ref.pendingTransactions,
      signedTransactions = _ref.signedTransactions;

  var _useState = useState([]),
      toastsIds = _useState[0],
      setToastsIds = _useState[1];

  var pendingTransactionsFromStore = useGetPendingTransactions().pendingTransactions;
  var signedTransactionsFromStore = useGetSignedTransactions();
  var pendingTransactionsToRender = pendingTransactions || pendingTransactionsFromStore;
  var signedTransactionsToRender = signedTransactions || signedTransactionsFromStore;
  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: 'toast-messages d-flex flex-column align-items-center justify-content-sm-end',
    toast: ''
  });
  var mappedToastsList = toastsIds === null || toastsIds === void 0 ? void 0 : toastsIds.map(function (toastId) {
    var currentTx = signedTransactionsToRender[toastId];

    if (currentTx == null || (currentTx === null || currentTx === void 0 ? void 0 : currentTx.transactions) == null || (currentTx === null || currentTx === void 0 ? void 0 : currentTx.status) == null) {
      return null;
    }

    var transactions = currentTx.transactions,
        status = currentTx.status;
    return React__default.createElement(TransactionToast$1, {
      className: className,
      key: toastId,
      transactions: transactions,
      status: status,
      toastId: toastId,
      withTxNonce: withTxNonce
    });
  });

  var mapPendingSignedTransactions = function mapPendingSignedTransactions() {
    var newToasts = [].concat(toastsIds);

    for (var sessionId in pendingTransactionsToRender) {
      var hasToast = toastsIds.includes(sessionId);

      if (!hasToast) {
        newToasts.push(sessionId);
      }
    }

    setToastsIds(newToasts);
  };

  var fetchSessionStorageToasts = function fetchSessionStorageToasts() {
    var sessionStorageToastsIds = getToastsIdsFromStorage();

    if (sessionStorageToastsIds) {
      var newToasts = [].concat(toastsIds, sessionStorageToastsIds);
      setToastsIds(newToasts);
    }
  };

  var saveSessionStorageToasts = function saveSessionStorageToasts() {
    var shouldSaveLocalToasts = Boolean(toastsIds.length);

    if (!shouldSaveLocalToasts) {
      return;
    }

    setToastsIdsToStorage(toastsIds);
  };

  useEffect(function () {
    fetchSessionStorageToasts();
    return function () {
      saveSessionStorageToasts();
    };
  }, []);
  useEffect(function () {
    mapPendingSignedTransactions();
  }, [pendingTransactionsToRender]);
  return React__default.createElement("div", {
    className: generatedClasses.wrapper
  }, mappedToastsList);
}

var index$4 = withClassNameWrapper(TransactionsToastList);

var platform = {};

try {
  platform = require('platform');
} catch (err) {}

var platform$1 = platform;

var qrcode = {};

try {
  qrcode = require('qrcode');
} catch (err) {}

var QRCode = qrcode;

var _defs$1, _style, _g$2;

function _extends$3() {
  _extends$3 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$3.apply(this, arguments);
}

function SvgLightning(props) {
  return /*#__PURE__*/createElement("svg", _extends$3({
    xmlns: "http://www.w3.org/2000/svg",
    width: 44,
    height: 60
  }, props), _defs$1 || (_defs$1 = /*#__PURE__*/createElement("defs", null, /*#__PURE__*/createElement("image", {
    width: 22,
    height: 30,
    id: "lightning_svg__img1",
    href: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAeCAYAAAAo5+5WAAAA6klEQVRIibXWURHCMBBFUSRUAhLqgEpAQh1QB1RCHVAJOAAHxQE4IA4uH2yYTCbQafexAk5eNpu0m80fCtiqwRqYgF6J9ryrVYExZQAaFRpTBqBWgDElwA2olCkBzm40SwkwqlP6T76QMijQPKXv5Asp48lvPWhHuS6rUYN/1R04AQdgtxTe22yGmUU+OwGOixayXrfAYD2eq2lph9LFGttRqR6r4QTPa8Rzta09zwSUXJgc9c32F3RwgYa22dYbNep/ewto5wYNjW/GDcW3zNBRMpsFNAB7CZigV/dsJmCF+rfI4F4ym1m9AOPnYuevr8exAAAAAElFTkSuQmCC"
  }))), _style || (_style = /*#__PURE__*/createElement("style", null)), _g$2 || (_g$2 = /*#__PURE__*/createElement("g", {
    id: "lightning_svg__Elrond_Swap_Landing_Page_\\u2013_v2_2"
  }, /*#__PURE__*/createElement("g", {
    id: "lightning_svg__Group_424"
  }, /*#__PURE__*/createElement("g", {
    id: "lightning_svg__Group_421"
  }, /*#__PURE__*/createElement("use", {
    id: "lightning_svg__\\u26A1\\uFE0F",
    href: "#lightning_svg__img1",
    transform: "scale(2)"
  }))))));
}

function WalletConnectLoginContainer(_ref) {
  var _platform$os, _platform$os2;

  var callbackRoute = _ref.callbackRoute,
      loginButtonText = _ref.loginButtonText,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? 'Maiar Login' : _ref$title,
      _ref$logoutRoute = _ref.logoutRoute,
      logoutRoute = _ref$logoutRoute === void 0 ? '/unlock' : _ref$logoutRoute,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'wallect-connect-login-modal' : _ref$className,
      _ref$lead = _ref.lead,
      lead = _ref$lead === void 0 ? 'Scan the QR code using Maiar' : _ref$lead,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa,
      _ref$wrapContentInsid = _ref.wrapContentInsideModal,
      wrapContentInsideModal = _ref$wrapContentInsid === void 0 ? true : _ref$wrapContentInsid,
      redirectAfterLogin = _ref.redirectAfterLogin,
      token = _ref.token,
      onClose = _ref.onClose;

  var _useWalletConnectLogi = useWalletConnectLogin({
    logoutRoute: logoutRoute,
    callbackRoute: callbackRoute,
    token: token,
    redirectAfterLogin: redirectAfterLogin,
    shouldLoginUser: true
  }),
      initLoginWithWalletConnect = _useWalletConnectLogi[0],
      error = _useWalletConnectLogi[1].error,
      _useWalletConnectLogi2 = _useWalletConnectLogi[2],
      uriDeepLink = _useWalletConnectLogi2.uriDeepLink,
      walletConnectUri = _useWalletConnectLogi2.walletConnectUri;

  var _useState = useState(''),
      qrCodeSvg = _useState[0],
      setQrCodeSvg = _useState[1];

  var isMobileDevice = (platform$1 === null || platform$1 === void 0 ? void 0 : (_platform$os = platform$1.os) === null || _platform$os === void 0 ? void 0 : _platform$os.family) === 'iOS' || (platform$1 === null || platform$1 === void 0 ? void 0 : (_platform$os2 = platform$1.os) === null || _platform$os2 === void 0 ? void 0 : _platform$os2.family) === 'Android';
  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: 'btn btn-primary px-sm-4 m-1 mx-sm-3',
    loginText: 'text-left',
    container: 'm-auto login-container',
    card: 'card my-3 text-center',
    cardBody: 'card-body p-4 mx-lg-4',
    qrCodeSvgContainer: 'mx-auto mb-3',
    title: 'mb-3',
    leadText: 'lead mb-0',
    mobileLoginButton: 'btn btn-primary px-4 mt-4',
    errorMessage: 'text-danger d-flex justify-content-center align-items-center'
  });

  var generateQRCode = function generateQRCode() {
    try {
      if (!walletConnectUri) {
        return Promise.resolve();
      }

      return Promise.resolve(QRCode.toString(walletConnectUri, {
        type: 'svg'
      })).then(function (svg) {
        setQrCodeSvg(svg);
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  useEffect(function () {
    generateQRCode();
  }, [walletConnectUri]);
  useEffect(function () {
    initLoginWithWalletConnect();
  }, []);
  var content = React__default.createElement("div", {
    className: generatedClasses.container
  }, React__default.createElement("div", {
    className: generatedClasses.root
  }, React__default.createElement("div", {
    className: generatedClasses.card
  }, React__default.createElement("div", {
    className: generatedClasses.cardBody
  }, React__default.createElement("div", {
    className: generatedClasses.qrCodeSvgContainer,
    dangerouslySetInnerHTML: {
      __html: qrCodeSvg
    },
    style: {
      width: '15rem',
      height: '15rem'
    }
  }), React__default.createElement("h4", {
    className: generatedClasses.title
  }, title), isMobileDevice ? React__default.createElement(React__default.Fragment, null, React__default.createElement("p", {
    className: generatedClasses.leadText
  }, loginButtonText), React__default.createElement("a", {
    id: 'accessWalletBtn',
    "data-testid": 'accessWalletBtn',
    className: generatedClasses.mobileLoginButton,
    href: uriDeepLink || undefined,
    rel: 'noopener noreferrer nofollow',
    target: '_blank'
  }, React__default.createElement(SvgLightning, {
    className: generatedClasses.cardBody,
    style: {
      width: '0.7rem',
      height: '0.7rem'
    }
  }), title)) : React__default.createElement("p", {
    className: generatedClasses.leadText
  }, lead), React__default.createElement("div", null, error && React__default.createElement("p", {
    className: generatedClasses.errorMessage
  }, error))))));
  return wrapContentInsideModal ? React__default.createElement(ModalContainer, {
    title: 'Login with Maiar',
    className: className,
    onClose: onClose
  }, content) : content;
}

var WalletConnectLoginContainer$1 = withClassNameWrapper(WalletConnectLoginContainer);

var WalletConnectLoginButton = function WalletConnectLoginButton(_ref) {
  var children = _ref.children,
      callbackRoute = _ref.callbackRoute,
      _ref$loginButtonText = _ref.loginButtonText,
      loginButtonText = _ref$loginButtonText === void 0 ? 'Maiar App' : _ref$loginButtonText,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? 'Maiar Login' : _ref$title,
      _ref$logoutRoute = _ref.logoutRoute,
      logoutRoute = _ref$logoutRoute === void 0 ? '/unlock' : _ref$logoutRoute,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa,
      _ref$wrapContentInsid = _ref.wrapContentInsideModal,
      wrapContentInsideModal = _ref$wrapContentInsid === void 0 ? true : _ref$wrapContentInsid,
      _ref$redirectAfterLog = _ref.redirectAfterLogin,
      redirectAfterLogin = _ref$redirectAfterLog === void 0 ? false : _ref$redirectAfterLog,
      buttonClassName = _ref.buttonClassName,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'wallect-connect-login' : _ref$className,
      _ref$lead = _ref.lead,
      lead = _ref$lead === void 0 ? 'Scan the QR code using Maiar' : _ref$lead,
      token = _ref.token;

  var _useState = useState(false),
      showLoginModal = _useState[0],
      setShowLoginModal = _useState[1];

  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: "btn btn-primary px-sm-4 m-1 mx-sm-3 " + (buttonClassName != null ? buttonClassName : ''),
    loginText: 'text-left'
  });

  var handleOpenModal = function handleOpenModal() {
    setShowLoginModal(true);
  };

  var handleCloseModal = function handleCloseModal() {
    setShowLoginModal(false);
  };

  return React__default.createElement(Fragment, null, React__default.createElement("button", {
    onClick: handleOpenModal,
    className: generatedClasses.wrapper
  }, children || React__default.createElement("span", {
    className: generatedClasses.loginText
  }, loginButtonText)), showLoginModal && React__default.createElement(WalletConnectLoginContainer$1, {
    callbackRoute: callbackRoute,
    loginButtonText: loginButtonText,
    title: title,
    token: token,
    className: className,
    logoutRoute: logoutRoute,
    lead: lead,
    wrapContentInsideModal: wrapContentInsideModal,
    redirectAfterLogin: redirectAfterLogin,
    onClose: handleCloseModal
  }));
};

var WalletConnectLoginButton$1 = withClassNameWrapper(WalletConnectLoginButton);

var WebWalletLoginButton = function WebWalletLoginButton(_ref) {
  var children = _ref.children,
      token = _ref.token,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'web-wallet-login' : _ref$className,
      callbackRoute = _ref.callbackRoute,
      buttonClassName = _ref.buttonClassName,
      _ref$loginButtonText = _ref.loginButtonText,
      loginButtonText = _ref$loginButtonText === void 0 ? 'Elrond Web Wallet' : _ref$loginButtonText,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa;

  var _useWebWalletLogin = useWebWalletLogin({
    callbackRoute: callbackRoute,
    token: token
  }),
      onInitiateLogin = _useWebWalletLogin[0];

  var classes = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: "btn btn-primary px-sm-4 m-1 mx-sm-3 " + (buttonClassName != null ? buttonClassName : ''),
    loginText: 'text-left'
  });

  var handleLogin = function handleLogin() {
    onInitiateLogin();
  };

  return React__default.createElement("button", {
    onClick: handleLogin,
    className: classes.wrapper
  }, children || React__default.createElement("span", {
    className: classes.loginText
  }, loginButtonText));
};

var WebWalletLoginButton$1 = withClassNameWrapper(WebWalletLoginButton);

var UnlockPage = function UnlockPage(_ref) {
  var loginRoute = _ref.loginRoute,
      _ref$title = _ref.title,
      title = _ref$title === void 0 ? 'Login' : _ref$title,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? 'unlock-page' : _ref$className,
      _ref$shouldRenderDefa = _ref.shouldRenderDefaultCss,
      shouldRenderDefaultCss = _ref$shouldRenderDefa === void 0 ? true : _ref$shouldRenderDefa,
      _ref$LedgerLoginButto = _ref.LedgerLoginButtonText,
      LedgerLoginButtonText = _ref$LedgerLoginButto === void 0 ? 'Ledger' : _ref$LedgerLoginButto,
      _ref$description = _ref.description,
      description = _ref$description === void 0 ? 'Pick a login method' : _ref$description,
      _ref$WalletConnectLog = _ref.WalletConnectLoginButtonText,
      WalletConnectLoginButtonText = _ref$WalletConnectLog === void 0 ? 'Maiar' : _ref$WalletConnectLog,
      _ref$ExtensionLoginBu = _ref.ExtensionLoginButtonText,
      ExtensionLoginButtonText = _ref$ExtensionLoginBu === void 0 ? 'Extension' : _ref$ExtensionLoginBu,
      _ref$WebWalletLoginBu = _ref.WebWalletLoginButtonText,
      WebWalletLoginButtonText = _ref$WebWalletLoginBu === void 0 ? 'Web wallet' : _ref$WebWalletLoginBu;
  var generatedClasses = getGeneratedClasses(className, shouldRenderDefaultCss, {
    wrapper: "home d-flex flex-fill align-items-center " + wrapperClassName,
    title: 'mb-4',
    description: 'mb-4',
    cardContainer: 'm-auto',
    card: 'card my-4 text-center',
    cardBody: 'card-body py-4 px-2 px-sm-2 mx-lg-4'
  });

  var _useGetLoginInfo = useGetLoginInfo(),
      isLoggedIn = _useGetLoginInfo.isLoggedIn;

  React__default.useEffect(function () {
    if (isLoggedIn) {
      window.location.href = loginRoute;
    }
  }, [isLoggedIn]);
  return React__default.createElement("div", {
    className: generatedClasses.wrapper
  }, React__default.createElement("div", {
    className: generatedClasses.cardContainer
  }, React__default.createElement("div", {
    className: generatedClasses.card
  }, React__default.createElement("div", {
    className: generatedClasses.cardBody
  }, React__default.createElement("h4", {
    className: generatedClasses.title
  }, title), React__default.createElement("p", {
    className: generatedClasses.description
  }, description), React__default.createElement(ExtensionLoginButton$1, {
    callbackRoute: loginRoute,
    loginButtonText: ExtensionLoginButtonText
  }), React__default.createElement(WebWalletLoginButton$1, {
    callbackRoute: loginRoute,
    loginButtonText: WebWalletLoginButtonText
  }), React__default.createElement(LedgerLoginButton$1, {
    loginButtonText: LedgerLoginButtonText,
    callbackRoute: loginRoute
  }), React__default.createElement(WalletConnectLoginButton$1, {
    callbackRoute: loginRoute,
    loginButtonText: WalletConnectLoginButtonText
  })))));
};

var index$5 = withClassNameWrapper(UnlockPage);



var index$6 = {
  __proto__: null,
  UnlockPage: index$5
};



var index$7 = {
  __proto__: null,
  ExplorerLink: ExplorerLink$1,
  Denominate: Denominate$1,
  PageState: PageState$1,
  ExtensionLoginButton: ExtensionLoginButton$1,
  LedgerLoginButton: LedgerLoginButton$1,
  LedgerLoginContainer: LedgerLoginContainer$1,
  NotificationModal: NotificationModal,
  SignTransactionsModals: index$3,
  TransactionsToastList: index$4,
  TransactionToast: TransactionToast$1,
  WalletConnectLoginButton: WalletConnectLoginButton$1,
  WalletConnectLoginContainer: WalletConnectLoginContainer$1,
  WebWalletLoginButton: WebWalletLoginButton$1,
  Trim: Trim$1,
  DappCorePages: index$6
};

export { AppInitializer, AuthenticatedRoutesWrapper, DAPP_INIT_ROUTE, DappProvider, index$7 as DappUI, EmptyProvider, EnvironmentsEnum, LoginMethodsEnum, NotificationTypesEnum, TransactionBatchStatusesEnum, TransactionServerStatusesEnum, TransactionTypesEnum, TypesOfSmartContractCallsEnum, addressIsValid, areScCallsSuccessful, buildReplyUrl, buildUrlParams$1 as buildUrlParams, clear, completedServerTransactionsStates, decodeBase64, decodePart, denominate, emptyProvider, encodeToBase64, failBatchTransactionsStates, failServerTransactionsStates, getAccount, getAccountBalance, getAccountProvider, getAccountProviderType, getAddress, getAddressFromDataField, getApiProvider, getChainID, getEgldLabel, getGeneratedClasses, getIsLoggedIn, getIsProviderEqualTo, getIsTransactionCompleted, getIsTransactionFailed, getIsTransactionPending, getIsTransactionSuccessful, getIsTransactionTimedOut, getItem, getLatestNonce, getNetworkConfig, getNetworkProxy, getProviderType, getShardOfAddress, getTokenFromData, isBatchTransactionFailed, isBatchTransactionPending, isBatchTransactionSuccessful, isBatchTransactionTimedOut, isContract, isServerTransactionFailed, isServerTransactionPending, isServerTransactionSuccessful, isStringBase64, isTokenTransfer, logarithmicRest, index as loginServices, logout, index$2 as models, newWalletProvider, nominate, parseMultiEsdtTransferData, parseTransactionAfterSigning, pendingBatchTransactionsStates, pendingServerTransactionsStatuses, refreshAccount, removeItem, sendTransactions, setItem, setNonce, storage, successBatchTransactionsStates, successServerTransactionsStates, switchTrue, timedOutBatchTransactionsStates, index$1 as transactionServices, useGetAccountInfo, useGetAccountProvider, useGetLoginInfo, useGetNetworkConfig, useGetNotification, useGetPendingTransactions, useGetSignTransactionsError, useGetSignedTransactions, useGetTokenDetails, useGetTransactionDisplayInfo, useParseSignedTransactions, useSignTransactions, useSignTransactionsWithLedger, wrapperClassName };
//# sourceMappingURL=index.modern.js.map
