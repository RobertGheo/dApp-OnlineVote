import { asNodeArray, ensureMap, ensureSet, splitAndTrim } from './utils.js';
export function addOnEvents(target, source) {
    return Object.assign(target || {}, source);
}
export function on(els, types, arg1, arg2, arg3) {
    let opts;
    let listener;
    let selector;
    // arg1 is a function, then no selector, arg1 is the listener, and arg2 is the potential eventOptions
    if (arg1 instanceof Function) {
        listener = arg1;
        opts = arg2;
    }
    else {
        selector = arg1;
        listener = arg2;
        opts = arg3;
    }
    // AddEventListenerOptions	
    let eventOptions;
    if (opts && (opts.passive != null || opts.capture != null)) {
        eventOptions = {};
        if (opts.passive != null) {
            eventOptions.passive = opts.passive;
        }
        if (opts.capture != null) {
            eventOptions.capture = opts.capture;
        }
    }
    if (els == null) {
        return;
    }
    const silenceDisconnectedCtx = opts === null || opts === void 0 ? void 0 : opts.silenceDisconnectedCtx;
    const ctx = opts === null || opts === void 0 ? void 0 : opts.ctx;
    const ctxEl = (ctx instanceof HTMLElement) ? ctx : undefined;
    const typeArray = splitAndTrim(types, ",");
    typeArray.forEach(function (type) {
        const typeSelectorKey = buildTypeSelectorKey(type, selector);
        asNodeArray(els).forEach(function (el) {
            // This will the listener use for the even listener, which might differ
            // from the listener function passed in case of a selector
            let _listener = listener;
            // if we have a selector, create the wrapper listener to do the matches on the selector
            if (selector) {
                _listener = function (evt) {
                    let tgt = null;
                    const target = evt.target;
                    const currentTarget = evt.currentTarget;
                    const ctx = (opts) ? opts.ctx : null;
                    // if the 
                    if (silenceDisconnectedCtx === true && ctxEl != null) {
                        if (!ctxEl.isConnected) {
                            return;
                        }
                    }
                    // if the target match the selector, then, easy, we call the listener
                    if (target && target.matches(selector)) {
                        // Note: While mouseEvent are readonly for its properties, it does allow to add custom properties
                        // TODO: type narrowing needed.
                        evt.selectTarget = target;
                        listener.call(ctx, evt);
                    }
                    // now, if it does not, perhaps something in between the target and currentTarget
                    // might match
                    else {
                        // TODO: type narrowing needed.
                        tgt = evt.target.parentNode;
                        // TODO: might need to check that tgt is not undefined as well. 
                        while (tgt !== null && tgt !== currentTarget && tgt !== document) {
                            if (tgt.matches(selector)) { // selector is present here (see if above)
                                // Note: While mouseEvent are readonly for its properties, it does allow to add custom properties
                                evt.selectTarget = tgt;
                                listener.call(ctx, evt);
                                tgt = null;
                                break;
                            }
                            tgt = tgt.parentNode;
                        }
                    }
                };
            }
            // if we do not have a selector, but still havea  opts.ctx, then, need to wrap
            else if (opts && opts.ctx) {
                _listener = function (evt) {
                    if (silenceDisconnectedCtx === true && ctxEl != null) {
                        if (!ctxEl.isConnected) {
                            return;
                        }
                    }
                    listener.call(opts.ctx, evt);
                };
            }
            const listenerRef = {
                type: type,
                listener: listener,
                _listener: _listener, // an eventual wrap of the listener, or just point listener.
            };
            if (selector) {
                listenerRef.selector = selector;
            }
            // If we have a namespace, they add it to the Ref, and to the listenerRefsByNs
            // TODO: need to add listenerRef in a nsDic if if there a opts.ns
            if (opts && opts.ns) {
                listenerRef.ns = opts.ns;
                let listenerRefSetByNs = ensureMap(el, "listenerRefsByNs");
                let listenerRefSet = ensureSet(listenerRefSetByNs, opts.ns);
                listenerRefSet.add(listenerRef);
            }
            // add the listenerRef as listener:listenerRef entry for this typeSelectorKey in the listenerDic
            let listenerDic = ensureMap(el, "listenerDic");
            let listenerRefByListener = ensureMap(listenerDic, typeSelectorKey);
            listenerRefByListener.set(listener, listenerRef);
            // do the binding
            // TODO: fix typing here.
            el.addEventListener(type, _listener, eventOptions);
        }); // /utils.asArray(els).forEach(function(el){
    }); // /types.forEach(function(type){
}
export function off(els, type_or_opts, selector_or_listener, maybe_listener) {
    if (els == null) {
        return;
    }
    // for now, opts is only the first position
    const opts = (type_or_opts && type_or_opts.ns) ? type_or_opts : null;
    const type = (opts === null) ? type_or_opts : null;
    let selector = null;
    let listener;
    const tof = typeof selector_or_listener;
    if (tof === 'function') {
        selector = null;
        listener = selector_or_listener;
    }
    else if (tof === 'string') {
        selector = selector_or_listener;
        listener = maybe_listener;
    }
    // --------- off(els, {ns}) --------- //
    // if we have a .off(els,{ns:..}) then we do check only the ns
    if (opts && opts.ns) {
        const ns = opts.ns;
        asNodeArray(els).forEach(function (el) {
            const listenerDic = el.listenerDic;
            const listenerRefsByNs = el.listenerRefsByNs;
            let listenerRefSet;
            if (listenerRefsByNs && listenerDic) {
                listenerRefSet = listenerRefsByNs.get(ns);
                if (listenerRefSet) {
                    // if we get the set, we remove them all
                    listenerRefSet.forEach(function (listenerRef) {
                        // we remove the event listener
                        el.removeEventListener(listenerRef.type, listenerRef._listener);
                        // need to remove it from the listenerDic
                        const typeSelectorKey = buildTypeSelectorKey(listenerRef.type, listenerRef.selector);
                        const listenerRefMapByListener = listenerDic.get(typeSelectorKey);
                        if (listenerRefMapByListener && listenerRefMapByListener.has(listenerRef.listener)) {
                            listenerRefMapByListener.delete(listenerRef.listener);
                        }
                        else {
                            // eventua already removed
                            //console.log("INTERNAL INFO - should have a listener in el.listenerDic for " + typeSelectorKey);
                        }
                    });
                    // we remove this namespace now that all event handlers has been removed
                    listenerRefsByNs.delete(ns);
                }
            }
        });
        return;
    }
    // --------- /off(els, {ns}) --------- //
    const typeSelectorKey = buildTypeSelectorKey(type, selector);
    asNodeArray(els).forEach(function (el) {
        // First, get the listenerRefByListener for this type/selectory
        const listenerRefMapByListener = (el.listenerDic) ? el.listenerDic.get(typeSelectorKey) : null; //val(el, ["listenerDic", typeSelectorKey]);
        // for now, if we do not have a listenerRef for this type/[selector], we throw an error
        if (!listenerRefMapByListener) {
            console.log("WARNING - Cannot do .off() since this type-selector '" + typeSelectorKey +
                "' event was not bound with .on(). We will add support for this later.");
            return;
        }
        // if we do not have a listener function, this mean we need to remove all events for this type/selector
        if (typeof listener === "undefined" && type) {
            listenerRefMapByListener.forEach(function (listenerRef) {
                // Note: Here, type === listenerRef.type
                // remove the event
                // TODO: check typing assumption
                el.removeEventListener(type, listenerRef._listener);
            });
            el.listenerDic.delete(typeSelectorKey);
        }
        // if we have a listener, then, just remove this one.
        else {
            // check that we have the map. 
            const listenerRef = (listener) ? listenerRefMapByListener.get(listener) : null;
            if (!listenerRef) {
                console.log("WARNING - Cannot do .off() since no listenerRef for " + typeSelectorKey +
                    " and function \n" + listener + "\n were found. Probably was not registered via on()");
                return;
            }
            // remove the event
            // TODO: check typing assumption
            el.removeEventListener(type, listenerRef._listener);
            // remove it from the map
            // TODO: check typing ! assumption
            listenerRefMapByListener.delete(listener);
        }
    });
}
//#endregion ---------- /Public off API ---------- 
//#region    ---------- Public trigger API ---------- 
const customDefaultProps = {
    bubbles: true,
    cancelable: true
};
export function trigger(els, type, evtInit) {
    if (els == null) {
        return;
    } // for now make it null/undefined proof
    asNodeArray(els).forEach(function (el) {
        const evt = new CustomEvent(type, Object.assign({}, customDefaultProps, { selectTarget: el }, evtInit));
        el.dispatchEvent(evt);
    });
}
//#endregion ---------- /Public trigger API ---------- 
//#region    ---------- Public bindDOMEvents API ---------- 
/**
 * Bind a list of bindings
 *
 * @param typeAndSelector e.g., `click` or `click; button.add`
 */
export function bindOnEvents(el, eventDics, opts) {
    eventDics = (eventDics instanceof Array) ? eventDics : [eventDics]; // make we have an array of eventDic
    for (const eventDic of eventDics) {
        for (const selector in eventDic) {
            bindOnEvent(el, selector, eventDic[selector], opts);
        }
    }
}
/**
 * Bind one event to a el by appropriately parsing the `typeAndSelector` might contains a selector;
 *
 * @param typeAndSelector e.g., `click` or `click; button.add`
 */
export function bindOnEvent(el, typeAndSelector, fn, opts) {
    let selectorSplitted = typeAndSelector.trim().split(";"); // e.g., ["click", " button.add"]
    let type = selectorSplitted[0].trim(); // e.g., "click"
    let selector = null; // e.g., "button.add"
    if (selectorSplitted.length > 1) {
        selector = selectorSplitted[1].trim();
    }
    on(el, type, selector, fn, opts);
}
//#endregion ---------- /Public bindDOMEvents API ---------- 
function buildTypeSelectorKey(type, selector) {
    return (selector) ? (type + "--" + selector) : type;
}
//# sourceMappingURL=event.js.map