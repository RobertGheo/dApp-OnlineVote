import { html } from './dom-builders.js';
import { asNodeArray } from './utils.js';
export function first(el_or_selector, selector) {
    // We do not have a selector at all, then, this call is for firstElementChild
    if (!selector && typeof el_or_selector !== "string") {
        const el = el_or_selector;
        // try to get 
        const firstElementChild = el.firstElementChild;
        // if firstElementChild is null/undefined, but we have a firstChild, it is perhaps because not supported
        if (!firstElementChild && el.firstChild) {
            // If the firstChild is of type Element, return it. 
            if (el.firstChild.nodeType === 1) {
                return el.firstChild;
            }
            // Otherwise, try to find the next element (using the next)
            else {
                // TODO: Needs to look at typing here, this is a ChildNode
                return next(el.firstChild);
            }
        }
        return firstElementChild;
    }
    // otherwise, the call was either (selector) or (el, selector), so foward to the querySelector
    else {
        return _execQuerySelector(false, el_or_selector, selector);
    }
}
export function all(el, selector) {
    const nodeList = _execQuerySelector(true, el, selector);
    return (nodeList != null) ? asNodeArray(nodeList) : [];
}
export function getChild(el, name) {
    name = name.toUpperCase();
    for (const child of el.children) {
        if (child.tagName === name) {
            return child;
        }
    }
    throw new Error(`dom-native - getChild - No child found for selector ${name}`);
}
export function getChildren(el, ...names) {
    const childrenCount = el.childElementCount;
    if (childrenCount < names.length) {
        throw new Error("dom-native - getChildren - node has less children than requested names");
    }
    const result = [];
    let nameIdx = 0;
    for (const child of el.children) {
        let name = names[nameIdx].toUpperCase();
        if (child.tagName === name) {
            // Note: could do an instanceof HTMLElement (need measure perf impact vs value of the check)
            result.push(child);
            nameIdx += 1;
        }
        if (nameIdx >= childrenCount || nameIdx >= names.length) {
            break;
        }
    }
    if (result.length < names.length) {
        throw new Error("dom-native - getChildren - node has match children than requested");
    }
    return result;
}
// #endregion --- getChildren
// #region    --- next & prev
/**
 * Get the eventual next sibling of an HTMLElement given (optionally as selector)
 */
export function next(el, selector) {
    return _sibling(true, el, selector); // assume HTMLElement
}
/**
 * Get the eventual previous sibling
 */
export function prev(el, selector) {
    return _sibling(false, el, selector); // assume HTMLElement
}
/**
 * Return the next or previous Element sibling
 * @param next
 * @param el
 * @param selector
 */
function _sibling(next, el, selector) {
    const sibling = (next) ? 'nextSibling' : 'previousSibling';
    let tmpEl = (el) ? el[sibling] : null;
    // use "!=" for null and undefined
    while (tmpEl != null && tmpEl != document) {
        // only if node type is of Element, otherwise, 
        if (tmpEl.nodeType === 1 && (!selector || tmpEl.matches(selector))) {
            return tmpEl;
        }
        tmpEl = tmpEl[sibling];
    }
    return null;
}
// #endregion --- next & prev
// util: querySelector[All] wrapper
function _execQuerySelector(all, elOrSelector, selector) {
    let el = null;
    // if el is null or undefined, means we return nothing. 
    if (elOrSelector == null) {
        return null;
    }
    // if selector is undefined, it means we select from document and el is the document
    if (typeof selector === "undefined") {
        selector = elOrSelector;
        el = document;
    }
    else {
        el = elOrSelector;
    }
    return (all) ? el.querySelectorAll(selector) : el.querySelector(selector);
}
// #region    --- closest
/**
 * call el.closest, but allow el to be null (return null in this case)
 */
export function closest(el, selector) {
    return (el) ? el.closest(selector) : null;
}
export function append(refEl, newEl, position) {
    let parentEl;
    let nextSibling = null;
    let result;
    // make newEl a document fragment if string passed
    if (typeof newEl === 'string') {
        newEl = html(newEl);
    }
    // NOTE: need to do it before we append in the case for DocumentFragment case.
    // NOTE: we assume HTML element as per dom-native current approach.
    if (newEl instanceof Array) {
        result = newEl;
        // Create a document frag
        const fragment = document.createDocumentFragment();
        for (const elItem of newEl) {
            fragment.appendChild(elItem);
        }
        newEl = fragment;
    }
    else if (newEl instanceof DocumentFragment) {
        result = [...newEl.children]; // take the liberty to assume HTMLElememt
    }
    else {
        result = newEl;
    }
    // default is "last"
    position = (position) ? position : "last";
    //// 1) We determine the parentEl
    if (position === "last" || position === "first" || position === "empty") {
        parentEl = refEl;
    }
    else if (position === "before" || position === "after") {
        parentEl = refEl.parentNode;
        if (!parentEl) {
            throw new Error("dom-native ERROR - The referenceElement " + refEl + " does not have a parentNode. Cannot insert " + position);
        }
    }
    //// 2) We determine if we have a nextSibling or not
    // if "first", we try to see if there is a first child
    if (position === "first") {
        nextSibling = first(refEl); // if this is null, then, it will just do an appendChild
        // Note: this might be a text node but this is fine in this context.
    }
    // if "before", then, the refEl is the nextSibling
    else if (position === "before") {
        nextSibling = refEl;
    }
    // if "after", try to find the next Sibling (if not found, it will be just a appendChild to add last)
    else if (position === "after") {
        nextSibling = next(refEl);
    }
    //// 3) We append the newEl
    // if we have a next sibling, we insert it before
    if (nextSibling) {
        parentEl.insertBefore(newEl, nextSibling);
    }
    // otherwise, we just do a append last
    else {
        if (position === "empty") {
            // NOTE: the assumption here is that innerHTML will go faster than iterating through the lastChild, but for DocumentFragment, no choice
            if (parentEl instanceof HTMLElement) {
                parentEl.innerHTML = '';
            }
            else if (parentEl instanceof DocumentFragment) {
                while (parentEl.lastChild) {
                    parentEl.removeChild(parentEl.lastChild);
                }
            }
        }
        parentEl.appendChild(newEl);
    }
    return result;
}
// #endregion --- append
//# sourceMappingURL=dom.js.map